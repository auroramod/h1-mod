#pragma once
#include <d3d11.h>
#include <xaudio2fx.h>

#define assert_sizeof(__ASSET__, __SIZE__) static_assert(sizeof(__ASSET__) == __SIZE__)
#define assert_offsetof(__ASSET__, __VARIABLE__, __OFFSET__) static_assert(offsetof(__ASSET__, __VARIABLE__) == __OFFSET__)

namespace database
{
	typedef float vec_t;
	typedef vec_t vec2_t[2];
	typedef vec_t vec3_t[3];
	typedef vec_t vec4_t[4];

	typedef std::int32_t scr_string_t;

	enum XAssetType
	{
		ASSET_TYPE_PHYSPRESET,
		ASSET_TYPE_PHYSCOLLMAP,
		ASSET_TYPE_PHYSWATERPRESET,
		ASSET_TYPE_PHYSWORLDMAP,
		ASSET_TYPE_PHYSCONSTRAINT,
		ASSET_TYPE_XANIMPARTS,
		ASSET_TYPE_XMODEL_SURFS,
		ASSET_TYPE_XMODEL,
		ASSET_TYPE_MATERIAL,
		ASSET_TYPE_COMPUTESHADER,
		ASSET_TYPE_VERTEXSHADER,
		ASSET_TYPE_HULLSHADER,
		ASSET_TYPE_DOMAINSHADER,
		ASSET_TYPE_PIXELSHADER,
		ASSET_TYPE_VERTEXDECL,
		ASSET_TYPE_TECHNIQUE_SET,
		ASSET_TYPE_IMAGE,
		ASSET_TYPE_SOUND,
		ASSET_TYPE_SOUND_SUBMIX,
		ASSET_TYPE_SOUND_CURVE,
		ASSET_TYPE_LPF_CURVE,
		ASSET_TYPE_REVERB_CURVE,
		ASSET_TYPE_SOUND_CONTEXT,
		ASSET_TYPE_LOADED_SOUND,
		ASSET_TYPE_CLIPMAP,
		ASSET_TYPE_COMWORLD,
		ASSET_TYPE_GLASSWORLD,
		ASSET_TYPE_PATHDATA,
		ASSET_TYPE_VEHICLE_TRACK,
		ASSET_TYPE_MAP_ENTS,
		ASSET_TYPE_FXWORLD,
		ASSET_TYPE_GFXWORLD,
		ASSET_TYPE_LIGHT_DEF,
		ASSET_TYPE_UI_MAP,
		ASSET_TYPE_MENULIST,
		ASSET_TYPE_MENU,
		ASSET_TYPE_ANIMCLASS,
		ASSET_TYPE_LOCALIZE_ENTRY,
		ASSET_TYPE_ATTACHMENT,
		ASSET_TYPE_WEAPON,
		ASSET_TYPE_SNDDRIVER_GLOBALS,
		ASSET_TYPE_FX,
		ASSET_TYPE_IMPACT_FX,
		ASSET_TYPE_SURFACE_FX,
		ASSET_TYPE_AITYPE,
		ASSET_TYPE_MPTYPE,
		ASSET_TYPE_CHARACTER,
		ASSET_TYPE_XMODELALIAS,
		ASSET_TYPE_RAWFILE,
		ASSET_TYPE_SCRIPTFILE,
		ASSET_TYPE_STRINGTABLE,
		ASSET_TYPE_LEADERBOARD,
		ASSET_TYPE_VIRTUAL_LEADERBOARD,
		ASSET_TYPE_STRUCTURED_DATA_DEF,
		ASSET_TYPE_DDL,
		ASSET_TYPE_PROTO,
		ASSET_TYPE_TRACER,
		ASSET_TYPE_VEHICLE,
		ASSET_TYPE_ADDON_MAP_ENTS,
		ASSET_TYPE_NET_CONST_STRINGS,
		ASSET_TYPE_REVERB_PRESET,
		ASSET_TYPE_LUA_FILE,
		ASSET_TYPE_SCRIPTABLE,
		ASSET_TYPE_EQUIPMENT_SND_TABLE,
		ASSET_TYPE_VECTORFIELD,
		ASSET_TYPE_DOPPLER_PRESET,
		ASSET_TYPE_PARTICLE_SIM_ANIMATION,
		ASSET_TYPE_LASER,
		ASSET_TYPE_SKELETON_SCRIPT,
		ASSET_TYPE_CLUT,
		ASSET_TYPE_TTF,
		ASSET_TYPE_COUNT
	};

	struct FxEffectDef;
	struct GfxImage;
	struct XModel;

	struct Statement_s;
	struct MenuEventHandlerSet;
	struct menuDef_t;

	struct GfxLightDef;

	struct Bounds
	{
		vec3_t midPoint;
		vec3_t halfSize;
	};

	struct GfxColorFloat
	{
		float array[4];
	};

	union GfxColor
	{
		unsigned char array[4];
		unsigned int packed;
	};

	union GfxColorHdr
	{
		unsigned short array[4];
		unsigned __int64 packed;
	};

	enum PhysPresetScaling : std::int32_t
	{
		PHYSPRESET_SCALING_LINEAR = 0x0,
		PHYSPRESET_SCALING_QUADRATIC = 0x1,
		PHYSPRESET_SCALING_COUNT = 0x2,
	};

	struct PhysPreset
	{
		const char* name;
		int type;
		float mass;
		float bounce;
		float friction;
		float bulletForceScale;
		float explosiveForceScale;
		float explosiveSpinScale;
		int unk2; // 42001553
		const char* sndAliasPrefix;
		float piecesSpreadFraction;
		float piecesUpwardVelocity;
		float minMomentum;
		float maxMomentum;
		float minVolume;
		float maxVolume;
		float minPitch;
		float maxPitch;
		PhysPresetScaling volumeType;
		PhysPresetScaling pitchType;
		bool tempDefaultToCylinder;
		bool perSurfaceSndAlias;
	}; assert_sizeof(PhysPreset, 0x60);
	assert_offsetof(PhysPreset, sndAliasPrefix, 40);

	typedef std::int8_t dm_int8;
	typedef std::uint8_t dm_uint8;
	typedef std::int16_t dm_int16;
	typedef std::uint16_t dm_uint16;
	typedef std::int32_t dm_int32;
	typedef std::uint32_t dm_uint32;
	typedef std::int64_t dm_int64;
	typedef std::uint64_t dm_uint64;
	typedef float dm_float32;

	struct dmFloat3
	{
		dm_float32 x;
		dm_float32 y;
		dm_float32 z;
	};

	struct dmFloat4
	{
		dm_float32 x;
		dm_float32 y;
		dm_float32 z;
		dm_float32 w;
	};

	struct dmMeshNode_anon_fields
	{
		unsigned int axis : 2;
		unsigned int triangleCount : 4;
		unsigned int index : 26;
	};

	union dmMeshNode_anon
	{
		dmMeshNode_anon_fields fields;
		unsigned int packed;
	};

	struct dmMeshNode
	{
		dm_int16 lowerX;
		dm_int16 lowerY;
		dm_int16 lowerZ;
		dm_int16 upperX;
		dm_int16 upperY;
		dm_int16 upperZ;
		dmMeshNode_anon anon;
	}; assert_sizeof(dmMeshNode, 16);

	struct dmMeshTriangle
	{
		dm_int32 i1;
		dm_int32 i2;
		dm_int32 i3;
		dm_int32 w1;
		dm_int32 w2;
		dm_int32 w3;
		dm_int32 materialIndex;
		dm_int32 collisionFlags;
	}; assert_sizeof(dmMeshTriangle, 32);

	struct dmMeshData
	{
		dmMeshNode* m_pRoot;
		dmFloat4* m_aVertices;
		dmMeshTriangle* m_aTriangles;
		dmFloat3 m_center;
		dmFloat3 m_extents;
		dmFloat3 m_unquantize;
		dm_int32 m_nodeCount;
		dm_int32 m_vertexCount;
		dm_int32 m_triangleCount;
		dm_int32 m_height;
		dm_int32 contents;
	}; assert_sizeof(dmMeshData, 0x50);

	struct dmSubEdge
	{
		dm_int8 twinOffset;
		dm_uint8 tail;
		dm_uint8 left;
		dm_uint8 next;
	}; assert_sizeof(dmSubEdge, 4);

	struct dmPlane
	{
		dmFloat3 normal;
		dm_float32 offset;
	};

	struct dmPolytopeData
	{
		dmFloat4* m_aVertices; // count: m_vertexCount
		dmPlane* m_aPlanes; // count: m_faceCount
		dm_uint16* m_surfaceTypes; // count: m_faceCount // ALWAYS 0
		dm_uint16* m_vertexMaterials; // count: m_vertexCount // ALWAYS 0
		dmSubEdge* m_aSubEdges; // count: m_subEdgeCount
		dm_uint8* m_aFaceSubEdges; // count: m_faceCount
		dmFloat3 m_centroid;
		dm_int32 m_vertexCount;
		dm_int32 m_faceCount;
		dm_int32 m_subEdgeCount;
		dm_float32 m_volume;
		dm_float32 m_area;
		dmFloat3 unk1;
		dmFloat3 unk2;
		int contents;
		int pad2;
	}; assert_sizeof(dmPolytopeData, 0x70);

	struct PhysGeomInfo
	{
		dmPolytopeData* data;
	};

	struct PhysMass
	{
		float centerOfMass[3];
		float momentsOfInertia[3];
		float productsOfInertia[3];
	};

	struct PhysCollmap
	{
		const char* name;
		unsigned int count;
		PhysGeomInfo* geoms;
		PhysMass mass;
		Bounds bounds;
	}; assert_sizeof(PhysCollmap, 0x58);

	struct PhysWaterPreset
	{
		const char* name;
		char __pad0[64];
		FxEffectDef* fx0;
		FxEffectDef* fx1;
		FxEffectDef* fx2;
		FxEffectDef* fx3;
		FxEffectDef* fx4;
		FxEffectDef* fx5;
		FxEffectDef* fx6;
	}; assert_sizeof(PhysWaterPreset, 0x80);

	struct PhysWaterVolumeDef
	{
		PhysWaterPreset* physWaterPreset;
		char __pad0[12];
		scr_string_t string;
		short brushModelIndex;
		char __pad1[6];
	}; assert_sizeof(PhysWaterVolumeDef, 0x20);
	assert_offsetof(PhysWaterVolumeDef, string, 20);

	struct PhysBrushModelPacked
	{
		std::uint64_t p;
	};

	struct PhysBrushModelFields
	{
		short polytopeIndex;
		short unk;
		short worldIndex;
		short meshIndex;
	};

	union PhysBrushModel
	{
		PhysBrushModelPacked packed;
		PhysBrushModelFields fields;
	}; assert_sizeof(PhysBrushModel, 8);

	struct PhysWorld // PhysicsWorld
	{
		const char* name;
		PhysBrushModel* brushModels;
		dmPolytopeData* polytopeDatas;
		dmMeshData* meshDatas;
		PhysWaterVolumeDef* waterVolumeDefs;
		unsigned int brushModelCount;
		unsigned int polytopeCount;
		unsigned int meshDataCount;
		unsigned int waterVolumeDefCount;
	}; assert_sizeof(PhysWorld, 0x38);

	struct PhysConstraint
	{
		const char* name;
		char __pad0[32];
	}; assert_sizeof(PhysConstraint, 0x28);

	struct Packed128
	{
		std::uint64_t p0;
		std::uint64_t p1;
	};

	struct GfxDrawSurfFields
	{
		unsigned __int64 objectId : 16; // p0 >> 0
		unsigned __int64 pad0 : 20;
		unsigned __int64 reflectionProbeIndex : 8;
		unsigned __int64 hasGfxEntIndex : 1;
		unsigned __int64 customIndex : 5; // p0 >> 45
		unsigned __int64 materialSortedIndex : 14; // p0 >> 50
		unsigned __int64 tessellation : 2; // p1 >> 0
		unsigned __int64 prepass : 2; // p1 >> 2
		unsigned __int64 pad1 : 4;
		unsigned __int64 useHeroLighting : 1;
		unsigned __int64 sceneLightEnvIndex : 16;
		unsigned __int64 viewModelRender : 1;
		unsigned __int64 surfType : 4;
		unsigned __int64 primarySortKey : 6; // p1 >> 30
		unsigned __int64 unused : 28;
	};

	union GfxDrawSurf
	{
		GfxDrawSurfFields fields;
		Packed128 packed;
	};

	enum MaterialTechniqueType : std::int32_t
	{
		TECHNIQUE_STANDARD_BEGIN = 0,

		TECHNIQUE_ZPREPASS = 0,
		TECHNIQUE_ZPREPASS_VELOCITY_RIGID = 1,
		TECHNIQUE_ZPREPASS_VELOCITY_SKINNED = 2,
		TECHNIQUE_ZPREPASS_HIDIR = 3,
		TECHNIQUE_ZPREPASS_HIDIR_VELOCITY_RIGID = 4,
		TECHNIQUE_ZPREPASS_HIDIR_VELOCITY_SKINNED = 5,
		TECHNIQUE_BUILD_SHADOWMAP_DEPTH = 6,
		TECHNIQUE_BUILD_SHADOWMAP_COLOR = 7,
		TECHNIQUE_UNLIT = 8,
		TECHNIQUE_EMISSIVE = 9,
		TECHNIQUE_EMISSIVE_DFOG = 10,
		TECHNIQUE_EMISSIVE_SHADOW = 11,
		TECHNIQUE_EMISSIVE_SHADOW_DFOG = 12,
		TECHNIQUE_LIT = 13,
		TECHNIQUE_LIT_DIR = 14,
		TECHNIQUE_LIT_DIR_SHADOW = 15,
		TECHNIQUE_LIT_SPOT = 16,
		TECHNIQUE_LIT_SPOT_SHADOW = 17,
		TECHNIQUE_LIT_SPOT_SHADOW_CUCOLORIS = 18,
		TECHNIQUE_LIT_OMNI = 19,
		TECHNIQUE_LIT_OMNI_SHADOW = 20,
		TECHNIQUE_LIT_DYNAMIC_BRANCHING_CUCOLORIS = 21,
		TECHNIQUE_LIT_SUN_DYNAMIC_BRANCHING_CUCOLORIS = 22,
		TECHNIQUE_LIT_DYNAMIC_BRANCHING = 23,
		TECHNIQUE_LIT_SUN_DYNAMIC_BRANCHING = 24,
		TECHNIQUE_LIT_DFOG = 25,
		TECHNIQUE_LIT_DIR_DFOG = 26,
		TECHNIQUE_LIT_DIR_SHADOW_DFOG = 27,
		TECHNIQUE_LIT_SPOT_DFOG = 28,
		TECHNIQUE_LIT_SPOT_SHADOW_DFOG = 29,
		TECHNIQUE_LIT_SPOT_SHADOW_CUCOLORIS_DFOG = 30,
		TECHNIQUE_LIT_OMNI_DFOG = 31,
		TECHNIQUE_LIT_OMNI_SHADOW_DFOG = 32,
		TECHNIQUE_LIT_DYNAMIC_BRANCHING_CUCOLORIS_DFOG = 33,
		TECHNIQUE_LIT_SUN_DYNAMIC_BRANCHING_CUCOLORIS_DFOG = 34,
		TECHNIQUE_LIT_DYNAMIC_BRANCHING_DFOG = 35,
		TECHNIQUE_LIT_SUN_DYNAMIC_BRANCHING_DFOG = 36,
		TECHNIQUE_LIGHT_SPOT = 37,
		TECHNIQUE_LIGHT_OMNI = 38,
		TECHNIQUE_LIGHT_SPOT_SHADOW = 39,
		TECHNIQUE_LIGHT_SPOT_SHADOW_CUCOLORIS = 40,
		// 41
		// 42
		TECHNIQUE_LIGHT_SPOT_DFOG = 43,
		TECHNIQUE_LIGHT_OMNI_DFOG = 44,
		TECHNIQUE_LIGHT_SPOT_SHADOW_DFOG = 45,
		TECHNIQUE_LIGHT_SPOT_SHADOW_CUCOLORIS_DFOG = 46,
		// 47
		// 48
		TECHNIQUE_FAKELIGHT_NORMAL = 49,
		TECHNIQUE_FAKELIGHT_VIEW = 50,
		TECHNIQUE_SUNLIGHT_PREVIEW = 51,
		TECHNIQUE_CASE_TEXTURE = 52,
		TECHNIQUE_WIREFRAME_SOLID = 53,
		TECHNIQUE_WIREFRAME_SHADED = 54,
		TECHNIQUE_THERMAL = 55,
		TECHNIQUE_CTQ = 56,
		TECHNIQUE_VELOCITY_RIGID = 57,
		TECHNIQUE_VELOCITY_SKINNED = 58,
		TECHNIQUE_DEBUG_BUMPMAP = 59,

		TECHNIQUE_STANDARD_LAST = 59,
		TECHNIQUE_INSTANCED_BEGIN = 60,

		TECHNIQUE_INSTANCED_ZPREPASS = 60,
		TECHNIQUE_INSTANCED_ZPREPASS_VELOCITY_RIGID = 61,
		TECHNIQUE_INSTANCED_ZPREPASS_VELOCITY_SKINNED = 62,
		TECHNIQUE_INSTANCED_ZPREPASS_HIDIR = 63,
		TECHNIQUE_INSTANCED_ZPREPASS_HIDIR_VELOCITY_RIGID = 64,
		TECHNIQUE_INSTANCED_ZPREPASS_HIDIR_VELOCITY_SKINNED = 65,
		TECHNIQUE_INSTANCED_BUILD_SHADOWMAP_DEPTH = 66,
		TECHNIQUE_INSTANCED_BUILD_SHADOWMAP_COLOR = 67,
		TECHNIQUE_INSTANCED_UNLIT = 68,
		TECHNIQUE_INSTANCED_EMISSIVE = 69,
		TECHNIQUE_INSTANCED_EMISSIVE_DFOG = 70,
		TECHNIQUE_INSTANCED_EMISSIVE_SHADOW = 71,
		TECHNIQUE_INSTANCED_EMISSIVE_SHADOW_DFOG = 72,
		TECHNIQUE_INSTANCED_LIT = 73,
		TECHNIQUE_INSTANCED_LIT_DIR = 74,
		TECHNIQUE_INSTANCED_LIT_DIR_SHADOW = 75,
		TECHNIQUE_INSTANCED_LIT_SPOT = 76,
		TECHNIQUE_INSTANCED_LIT_SPOT_SHADOW = 77,
		TECHNIQUE_INSTANCED_LIT_SPOT_SHADOW_CUCOLORIS = 78,
		TECHNIQUE_INSTANCED_LIT_OMNI = 79,
		TECHNIQUE_INSTANCED_LIT_OMNI_SHADOW = 80,
		TECHNIQUE_INSTANCED_LIT_DYNAMIC_BRANCHING_CUCOLORIS = 81,
		TECHNIQUE_INSTANCED_LIT_SUN_DYNAMIC_BRANCHING_CUCOLORIS = 82,
		TECHNIQUE_INSTANCED_LIT_DYNAMIC_BRANCHING = 83,
		TECHNIQUE_INSTANCED_LIT_SUN_DYNAMIC_BRANCHING = 84,
		TECHNIQUE_INSTANCED_LIT_DFOG = 85,
		TECHNIQUE_INSTANCED_LIT_DIR_DFOG = 86,
		TECHNIQUE_INSTANCED_LIT_DIR_SHADOW_DFOG = 87,
		TECHNIQUE_INSTANCED_LIT_SPOT_DFOG = 88,
		TECHNIQUE_INSTANCED_LIT_SPOT_SHADOW_DFOG = 89,
		TECHNIQUE_INSTANCED_LIT_SPOT_SHADOW_CUCOLORIS_DFOG = 90,
		TECHNIQUE_INSTANCED_LIT_OMNI_DFOG = 91,
		TECHNIQUE_INSTANCED_LIT_OMNI_SHADOW_DFOG = 92,
		TECHNIQUE_INSTANCED_LIT_DYNAMIC_BRANCHING_CUCOLORIS_DFOG = 93,
		TECHNIQUE_INSTANCED_LIT_SUN_DYNAMIC_BRANCHING_CUCOLORIS_DFOG = 94,
		TECHNIQUE_INSTANCED_LIT_DYNAMIC_BRANCHING_DFOG = 95,
		TECHNIQUE_INSTANCED_LIT_SUN_DYNAMIC_BRANCHING_DFOG = 96,
		TECHNIQUE_INSTANCED_LIGHT_SPOT = 97,
		TECHNIQUE_INSTANCED_LIGHT_OMNI = 98,
		TECHNIQUE_INSTANCED_LIGHT_SPOT_SHADOW = 99,
		TECHNIQUE_INSTANCED_LIGHT_SPOT_SHADOW_CUCOLORIS = 100,
		// 101
		// 102
		TECHNIQUE_INSTANCED_LIGHT_SPOT_DFOG = 103,
		TECHNIQUE_INSTANCED_LIGHT_OMNI_DFOG = 104,
		TECHNIQUE_INSTANCED_LIGHT_SPOT_SHADOW_DFOG = 105,
		TECHNIQUE_INSTANCED_LIGHT_SPOT_SHADOW_CUCOLORIS_DFOG = 106,
		// 107
		// 108
		TECHNIQUE_INSTANCED_FAKELIGHT_NORMAL = 109,
		TECHNIQUE_INSTANCED_FAKELIGHT_VIEW = 110,
		TECHNIQUE_INSTANCED_SUNLIGHT_PREVIEW = 111,
		TECHNIQUE_INSTANCED_CASE_TEXTURE = 112,
		TECHNIQUE_INSTANCED_WIREFRAME_SOLID = 113,
		TECHNIQUE_INSTANCED_WIREFRAME_SHADED = 114,
		TECHNIQUE_INSTANCED_THERMAL = 115,
		TECHNIQUE_INSTANCED_CTQ = 116,
		TECHNIQUE_INSTANCED_VELOCITY_RIGID = 117,
		TECHNIQUE_INSTANCED_VELOCITY_SKINNED = 118,
		TECHNIQUE_INSTANCED_DEBUG_BUMPMAP = 119,

		TECHNIQUE_INSTANCED_LAST = 119,
		TECHNIQUE_SUBDIV_PATCH_BEGIN = 120,

		TECHNIQUE_SUBDIV_PATCH_ZPREPASS = 120,
		TECHNIQUE_SUBDIV_PATCH_ZPREPASS_VELOCITY_RIGID = 121,
		TECHNIQUE_SUBDIV_PATCH_ZPREPASS_VELOCITY_SKINNED = 122,
		TECHNIQUE_SUBDIV_PATCH_ZPREPASS_HIDIR = 123,
		TECHNIQUE_SUBDIV_PATCH_ZPREPASS_HIDIR_VELOCITY_RIGID = 124,
		TECHNIQUE_SUBDIV_PATCH_ZPREPASS_HIDIR_VELOCITY_SKINNED = 125,
		TECHNIQUE_SUBDIV_PATCH_BUILD_SHADOWMAP_DEPTH = 126,
		TECHNIQUE_SUBDIV_PATCH_BUILD_SHADOWMAP_COLOR = 127,
		TECHNIQUE_SUBDIV_PATCH_UNLIT = 128,
		TECHNIQUE_SUBDIV_PATCH_EMISSIVE = 129,
		TECHNIQUE_SUBDIV_PATCH_EMISSIVE_DFOG = 130,
		TECHNIQUE_SUBDIV_PATCH_EMISSIVE_SHADOW = 131,
		TECHNIQUE_SUBDIV_PATCH_EMISSIVE_SHADOW_DFOG = 132,
		TECHNIQUE_SUBDIV_PATCH_LIT = 133,
		TECHNIQUE_SUBDIV_PATCH_LIT_DIR = 134,
		TECHNIQUE_SUBDIV_PATCH_LIT_DIR_SHADOW = 135,
		TECHNIQUE_SUBDIV_PATCH_LIT_SPOT = 136,
		TECHNIQUE_SUBDIV_PATCH_LIT_SPOT_SHADOW = 137,
		TECHNIQUE_SUBDIV_PATCH_LIT_SPOT_SHADOW_CUCOLORIS = 138,
		TECHNIQUE_SUBDIV_PATCH_LIT_OMNI = 139,
		TECHNIQUE_SUBDIV_PATCH_LIT_OMNI_SHADOW = 140,
		TECHNIQUE_SUBDIV_PATCH_LIT_DYNAMIC_BRANCHING_CUCOLORIS = 141,
		TECHNIQUE_SUBDIV_PATCH_LIT_SUN_DYNAMIC_BRANCHING_CUCOLORIS = 142,
		TECHNIQUE_SUBDIV_PATCH_LIT_DYNAMIC_BRANCHING = 143,
		TECHNIQUE_SUBDIV_PATCH_LIT_SUN_DYNAMIC_BRANCHING = 144,
		TECHNIQUE_SUBDIV_PATCH_LIT_DFOG = 145,
		TECHNIQUE_SUBDIV_PATCH_LIT_DIR_DFOG = 146,
		TECHNIQUE_SUBDIV_PATCH_LIT_DIR_SHADOW_DFOG = 147,
		TECHNIQUE_SUBDIV_PATCH_LIT_SPOT_DFOG = 148,
		TECHNIQUE_SUBDIV_PATCH_LIT_SPOT_SHADOW_DFOG = 149,
		TECHNIQUE_SUBDIV_PATCH_LIT_SPOT_SHADOW_CUCOLORIS_DFOG = 150,
		TECHNIQUE_SUBDIV_PATCH_LIT_OMNI_DFOG = 151,
		TECHNIQUE_SUBDIV_PATCH_LIT_OMNI_SHADOW_DFOG = 152,
		TECHNIQUE_SUBDIV_PATCH_LIT_DYNAMIC_BRANCHING_CUCOLORIS_DFOG = 153,
		TECHNIQUE_SUBDIV_PATCH_LIT_SUN_DYNAMIC_BRANCHING_CUCOLORIS_DFOG = 154,
		TECHNIQUE_SUBDIV_PATCH_LIT_DYNAMIC_BRANCHING_DFOG = 155,
		TECHNIQUE_SUBDIV_PATCH_LIT_SUN_DYNAMIC_BRANCHING_DFOG = 156,
		TECHNIQUE_SUBDIV_PATCH_LIGHT_SPOT = 157,
		TECHNIQUE_SUBDIV_PATCH_LIGHT_OMNI = 158,
		TECHNIQUE_SUBDIV_PATCH_LIGHT_SPOT_SHADOW = 159,
		TECHNIQUE_SUBDIV_PATCH_LIGHT_SPOT_SHADOW_CUCOLORIS = 160,
		// 161
		// 162
		TECHNIQUE_SUBDIV_PATCH_LIGHT_SPOT_DFOG = 163,
		TECHNIQUE_SUBDIV_PATCH_LIGHT_OMNI_DFOG = 164,
		TECHNIQUE_SUBDIV_PATCH_LIGHT_SPOT_SHADOW_DFOG = 165,
		TECHNIQUE_SUBDIV_PATCH_LIGHT_SPOT_SHADOW_CUCOLORIS_DFOG = 166,
		// 167
		// 168
		TECHNIQUE_SUBDIV_PATCH_FAKELIGHT_NORMAL = 169,
		TECHNIQUE_SUBDIV_PATCH_FAKELIGHT_VIEW = 170,
		TECHNIQUE_SUBDIV_PATCH_SUNLIGHT_PREVIEW = 171,
		TECHNIQUE_SUBDIV_PATCH_CASE_TEXTURE = 172,
		TECHNIQUE_SUBDIV_PATCH_WIREFRAME_SOLID = 173,
		TECHNIQUE_SUBDIV_PATCH_WIREFRAME_SHADED = 174,
		TECHNIQUE_SUBDIV_PATCH_THERMAL = 175,
		TECHNIQUE_SUBDIV_PATCH_CTQ = 176,
		TECHNIQUE_SUBDIV_PATCH_VELOCITY_RIGID = 177,
		TECHNIQUE_SUBDIV_PATCH_VELOCITY_SKINNED = 178,
		TECHNIQUE_SUBDIV_PATCH_DEBUG_BUMPMAP = 179,

		TECHNIQUE_SUBDIV_PATCH_LAST = 180,
		TECHNIQUE_NO_DISPLACEMENT_BEGIN = 180,

		TECHNIQUE_NO_DISPLACEMENT_ZPREPASS = 180,
		TECHNIQUE_NO_DISPLACEMENT_ZPREPASS_VELOCITY_RIGID = 181,
		TECHNIQUE_NO_DISPLACEMENT_ZPREPASS_VELOCITY_SKINNED = 182,
		TECHNIQUE_NO_DISPLACEMENT_ZPREPASS_HIDIR = 183,
		TECHNIQUE_NO_DISPLACEMENT_ZPREPASS_HIDIR_VELOCITY_RIGID = 184,
		TECHNIQUE_NO_DISPLACEMENT_ZPREPASS_HIDIR_VELOCITY_SKINNED = 185,
		TECHNIQUE_NO_DISPLACEMENT_BUILD_SHADOWMAP_DEPTH = 186,
		TECHNIQUE_NO_DISPLACEMENT_BUILD_SHADOWMAP_COLOR = 187,
		TECHNIQUE_NO_DISPLACEMENT_UNLIT = 188,
		TECHNIQUE_NO_DISPLACEMENT_EMISSIVE = 189,
		TECHNIQUE_NO_DISPLACEMENT_EMISSIVE_DFOG = 190,
		TECHNIQUE_NO_DISPLACEMENT_EMISSIVE_SHADOW = 191,
		TECHNIQUE_NO_DISPLACEMENT_EMISSIVE_SHADOW_DFOG = 192,
		TECHNIQUE_NO_DISPLACEMENT_LIT = 193,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DIR = 194,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DIR_SHADOW = 195,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SPOT = 196,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SPOT_SHADOW = 197,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SPOT_SHADOW_CUCOLORIS = 198,
		TECHNIQUE_NO_DISPLACEMENT_LIT_OMNI = 199,
		TECHNIQUE_NO_DISPLACEMENT_LIT_OMNI_SHADOW = 200,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DYNAMIC_BRANCHING_CUCOLORIS = 201,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SUN_DYNAMIC_BRANCHING_CUCOLORIS = 202,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DYNAMIC_BRANCHING = 203,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SUN_DYNAMIC_BRANCHING = 204,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DFOG = 205,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DIR_DFOG = 206,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DIR_SHADOW_DFOG = 207,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SPOT_DFOG = 208,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SPOT_SHADOW_DFOG = 209,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SPOT_SHADOW_CUCOLORIS_DFOG = 210,
		TECHNIQUE_NO_DISPLACEMENT_LIT_OMNI_DFOG = 211,
		TECHNIQUE_NO_DISPLACEMENT_LIT_OMNI_SHADOW_DFOG = 212,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DYNAMIC_BRANCHING_CUCOLORIS_DFOG = 213,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SUN_DYNAMIC_BRANCHING_CUCOLORIS_DFOG = 214,
		TECHNIQUE_NO_DISPLACEMENT_LIT_DYNAMIC_BRANCHING_DFOG = 215,
		TECHNIQUE_NO_DISPLACEMENT_LIT_SUN_DYNAMIC_BRANCHING_DFOG = 216,
		TECHNIQUE_NO_DISPLACEMENT_LIGHT_SPOT = 217,
		TECHNIQUE_NO_DISPLACEMENT_LIGHT_OMNI = 218,
		TECHNIQUE_NO_DISPLACEMENT_LIGHT_SPOT_SHADOW = 219,
		TECHNIQUE_NO_DISPLACEMENT_LIGHT_SPOT_SHADOW_CUCOLORIS = 220,
		// 221
		// 222
		TECHNIQUE_NO_DISPLACEMENT_LIGHT_SPOT_DFOG = 223,
		TECHNIQUE_NO_DISPLACEMENT_LIGHT_OMNI_DFOG = 224,
		TECHNIQUE_NO_DISPLACEMENT_LIGHT_SPOT_SHADOW_DFOG = 225,
		TECHNIQUE_NO_DISPLACEMENT_LIGHT_SPOT_SHADOW_CUCOLORIS_DFOG = 226,
		// 227
		// 228
		TECHNIQUE_NO_DISPLACEMENT_FAKELIGHT_NORMAL = 229,
		TECHNIQUE_NO_DISPLACEMENT_FAKELIGHT_VIEW = 230,
		TECHNIQUE_NO_DISPLACEMENT_SUNLIGHT_PREVIEW = 231,
		TECHNIQUE_NO_DISPLACEMENT_CASE_TEXTURE = 232,
		TECHNIQUE_NO_DISPLACEMENT_WIREFRAME_SOLID = 233,
		TECHNIQUE_NO_DISPLACEMENT_WIREFRAME_SHADED = 234,
		TECHNIQUE_NO_DISPLACEMENT_THERMAL = 235,
		TECHNIQUE_NO_DISPLACEMENT_CTQ = 236,
		TECHNIQUE_NO_DISPLACEMENT_VELOCITY_RIGID = 237,
		TECHNIQUE_NO_DISPLACEMENT_VELOCITY_SKINNED = 238,
		TECHNIQUE_NO_DISPLACEMENT_DEBUG_BUMPMAP = 239,

		TECHNIQUE_NO_DISPLACEMENT_LAST = 240,

		TECHNIQUE_COUNT = 240,
		TECHNIQUE_TOTAL_COUNT = 241,
		TECHNIQUE_NONE = 242,
	};

	enum MaterialConstSource : std::int32_t
	{
		CONST_SRC_CODE_LIGHT_POSITION,
		CONST_SRC_CODE_LIGHT_DIFFUSE,
		CONST_SRC_CODE_LIGHT_PHYSICALSIZE,
		CONST_SRC_CODE_LIGHT_FADEOFFSET,
		CONST_SRC_CODE_LIGHT_SPECULAR,
		CONST_SRC_CODE_LIGHT_SPOTDIR,
		CONST_SRC_CODE_LIGHT_SPOTFACTORS,
		CONST_SRC_CODE_LIGHT_FALLOFF_PLACEMENT,
		CONST_SRC_CODE_LIGHT_CUCOLORIS_ANIM,
		CONST_SRC_CODE_LIGHT_POSITION1,
		CONST_SRC_CODE_LIGHT_DIFFUSE1,
		CONST_SRC_CODE_LIGHT_PHYSICALSIZE1,
		CONST_SRC_CODE_LIGHT_FADEOFFSET1,
		CONST_SRC_CODE_LIGHT_SPECULAR1,
		CONST_SRC_CODE_LIGHT_SPOTDIR1,
		CONST_SRC_CODE_LIGHT_SPOTFACTORS1,
		CONST_SRC_CODE_LIGHT_FALLOFF_PLACEMENT1,
		CONST_SRC_CODE_LIGHT_CUCOLORIS_ANIM1,
		CONST_SRC_CODE_LIGHT_POSITION2,
		CONST_SRC_CODE_LIGHT_DIFFUSE2,
		CONST_SRC_CODE_LIGHT_PHYSICALSIZE2,
		CONST_SRC_CODE_LIGHT_FADEOFFSET2,
		CONST_SRC_CODE_LIGHT_SPECULAR2,
		CONST_SRC_CODE_LIGHT_SPOTDIR2,
		CONST_SRC_CODE_LIGHT_SPOTFACTORS2,
		CONST_SRC_CODE_LIGHT_FALLOFF_PLACEMENT2,
		CONST_SRC_CODE_LIGHT_CUCOLORIS_ANIM2,
		CONST_SRC_CODE_LIGHT_POSITION3,
		CONST_SRC_CODE_LIGHT_DIFFUSE3,
		CONST_SRC_CODE_LIGHT_PHYSICALSIZE3,
		CONST_SRC_CODE_LIGHT_FADEOFFSET3,
		CONST_SRC_CODE_LIGHT_SPECULAR3,
		CONST_SRC_CODE_LIGHT_SPOTDIR3,
		CONST_SRC_CODE_LIGHT_SPOTFACTORS3,
		CONST_SRC_CODE_LIGHT_FALLOFF_PLACEMENT3,
		CONST_SRC_CODE_LIGHT_CUCOLORIS_ANIM3,
		CONST_SRC_CODE_LIGHT_POSITION_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_POSITION_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_POSITION_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_POSITION_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_DIFFUSE_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_DIFFUSE_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_DIFFUSE_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_DIFFUSE_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_PHYSICALSIZE_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_PHYSICALSIZE_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_PHYSICALSIZE_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_PHYSICALSIZE_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_FADEOFFSET_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_FADEOFFSET_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_FADEOFFSET_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_FADEOFFSET_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_SPECULAR_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_SPECULAR_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_SPECULAR_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_SPECULAR_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_SPOTDIR_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_SPOTDIR_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_SPOTDIR_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_SPOTDIR_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_SPOTFACTORS_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_SPOTFACTORS_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_SPOTFACTORS_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_SPOTFACTORS_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_CUCOLORIS_ANIM_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_CUCOLORIS_ANIM_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_CUCOLORIS_ANIM_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_CUCOLORIS_ANIM_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_FALLOFF_PLACEMENT_DB_ARRAY_0,
		CONST_SRC_CODE_LIGHT_FALLOFF_PLACEMENT_DB_ARRAY_1,
		CONST_SRC_CODE_LIGHT_FALLOFF_PLACEMENT_DB_ARRAY_2,
		CONST_SRC_CODE_LIGHT_FALLOFF_PLACEMENT_DB_ARRAY_3,
		CONST_SRC_CODE_LIGHT_DYN_COUNT,
		CONST_SRC_CODE_LIGHT_DYN_TYPES,
		CONST_SRC_CODE_LIGHT_DYN_SHADOW_TYPES,
		CONST_SRC_CODE_PARTICLE_CLOUD_COLOR,
		CONST_SRC_CODE_GAMETIME,
		CONST_SRC_CODE_SYSTEMTIME,
		CONST_SRC_CODE_GENERIC_MATERIAL_DATA,
		CONST_SRC_CODE_EYEOFFSET,
		CONST_SRC_CODE_WORLD_MATRIX_EYE_OFFSET,
		CONST_SRC_CODE_EMBLEM_LUT_SELECTOR,
		CONST_SRC_CODE_MODEL_VELOCITY_PARMS,
		CONST_SRC_CODE_MODEL_VELOCITY_SKINNED_PARMS,
		CONST_SRC_CODE_POSTFX_CONTROL0,
		CONST_SRC_CODE_POSTFX_CONTROL1,
		CONST_SRC_CODE_POSTFX_CONTROL2,
		CONST_SRC_CODE_POSTFX_CONTROL3,
		CONST_SRC_CODE_POSTFX_CONTROL4,
		CONST_SRC_CODE_POSTFX_CONTROL5,
		CONST_SRC_CODE_POSTFX_CONTROL6,
		CONST_SRC_CODE_POSTFX_CONTROL7,
		CONST_SRC_CODE_POSTFX_CONTROL8,
		CONST_SRC_CODE_POSTFX_CONTROL9,
		CONST_SRC_CODE_POSTFX_CONTROLA,
		CONST_SRC_CODE_POSTFX_CONTROLB,
		CONST_SRC_CODE_POSTFX_CONTROLC,
		CONST_SRC_CODE_POSTFX_CONTROLD,
		CONST_SRC_CODE_POSTFX_CONTROLE,
		CONST_SRC_CODE_POSTFX_CONTROLF,
		CONST_SRC_CODE_SCRIPT_PARMS,
		CONST_SRC_CODE_EFFECT_MODEL_COLOR,
		CONST_SRC_CODE_EFFECT_MODEL_COLOR_EMISSIVE,
		CONST_SRC_CODE_FILTER_TAP_0,
		CONST_SRC_CODE_FILTER_TAP_1,
		CONST_SRC_CODE_FILTER_TAP_2,
		CONST_SRC_CODE_FILTER_TAP_3,
		CONST_SRC_CODE_FILTER_TAP_4,
		CONST_SRC_CODE_FILTER_TAP_5,
		CONST_SRC_CODE_FILTER_TAP_6,
		CONST_SRC_CODE_FILTER_TAP_7,
		CONST_SRC_CODE_FILTER_TAP_8,
		CONST_SRC_CODE_FILTER_TAP_9,
		CONST_SRC_CODE_FILTER_TAP_10,
		CONST_SRC_CODE_FILTER_TAP_11,
		CONST_SRC_CODE_COLOR_MATRIX_R,
		CONST_SRC_CODE_COLOR_MATRIX_G,
		CONST_SRC_CODE_COLOR_MATRIX_B,
		CONST_SRC_CODE_RENDER_TARGET_SIZE,
		CONST_SRC_CODE_RENDER_SOURCE_SIZE,
		CONST_SRC_CODE_VEIL_PARAMS,
		CONST_SRC_CODE_FXAA_RCPFRAMEOPT,
		CONST_SRC_CODE_VOLUME_LIGHT_SCATTER_1,
		CONST_SRC_CODE_VOLUME_LIGHT_SCATTER_2,
		CONST_SRC_CODE_VOLUME_LIGHT_SCATTER_3,
		CONST_SRC_CODE_MODEL_LIGHTMAP_PARAMS,
		CONST_SRC_CODE_NEARPLANE_ORG,
		CONST_SRC_CODE_NEARPLANE_DX,
		CONST_SRC_CODE_NEARPLANE_DY,
		CONST_SRC_CODE_SSAO_POWER_BB_SHARPNESS_STEP,
		CONST_SRC_CODE_SSAO_COLOR_COEFF,
		CONST_SRC_CODE_SSAO_FALLOFF_DEPTH_SCALE,
		CONST_SRC_CODE_SSAO_UV_TO_ROT_SCALE_AND_FADE,
		CONST_SRC_CODE_SSAO_SAMPLE_MAT_SCALE,
		CONST_SRC_CODE_SSAO_DEPTH_OFFSET_REJECT,
		CONST_SRC_CODE_LIT2D_LIGHTDIRX2,
		CONST_SRC_CODE_LIT2D_SPECHALFANGLEDIRX2,
		CONST_SRC_CODE_LIT2D_AMBIENTCOLOR,
		CONST_SRC_CODE_LIT2D_DIFFUSECOLOR,
		CONST_SRC_CODE_LIT2D_SPECCOLOR_SPECEXPONENT,
		CONST_SRC_CODE_LIT2D_ADDITIVECOLOR,
		CONST_SRC_CODE_LIT2D_BLOODSPATTER_AMBIENTCOLOR,
		CONST_SRC_CODE_LIT2D_BLOODSPATTER_DIFFUSECOLOR,
		CONST_SRC_CODE_LIT2D_BLOODSPATTER_SPECCOLOR_SPECEXPONENT,
		CONST_SRC_CODE_LIT2D_BLOODSPATTER_ADDITIVECOLOR,
		CONST_SRC_CODE_LIT2D_HUDBLOOD_COLOR,
		CONST_SRC_CODE_LIT2D_HUDBLOOD_COLOR_THIN,
		CONST_SRC_CODE_DOF_EQUATION_VIEWMODEL_AND_FAR_BLUR,
		CONST_SRC_CODE_DOF_EQUATION_SCENE,
		CONST_SRC_CODE_DOF_LERP_SCALE,
		CONST_SRC_CODE_DOF_LERP_BIAS,
		CONST_SRC_CODE_DOF_ROW_DELTA,
		CONST_SRC_CODE_DOF_EQUATION,
		CONST_SRC_CODE_DOF_PARAMS,
		CONST_SRC_CODE_DOF_TILE_PARAMS,
		CONST_SRC_CODE_FRAME_COUNT_PARAMS,
		CONST_SRC_CODE_MOTION_MATRIX_X,
		CONST_SRC_CODE_MOTION_MATRIX_Y,
		CONST_SRC_CODE_MOTION_MATRIX_W,
		CONST_SRC_CODE_SSR_PREV_FRAME_VIEWPROJECTION_MATRIX_R0,
		CONST_SRC_CODE_SSR_PREV_FRAME_VIEWPROJECTION_MATRIX_R1,
		CONST_SRC_CODE_SSR_PREV_FRAME_VIEWPROJECTION_MATRIX_R2,
		CONST_SRC_CODE_SSR_PREV_FRAME_VIEWPROJECTION_MATRIX_R3,
		CONST_SRC_CODE_PREV_EYEPOSITION_TRANSFORM,
		CONST_SRC_CODE_SCREEN_SPACE_REFLECTION_PARAMETERS,
		CONST_SRC_CODE_CLIP_SPACE_LOOKUP_SCALE_AND_OFFSET,
		CONST_SRC_CODE_SSR_CLIP_TO_FADE_SCALE_OFFSET_PS,
		CONST_SRC_CODE_SSS_MRT_OFF_SHADER_OFF,
		CONST_SRC_CODE_MDAO_VIEWTOOCCLUDER_MATRIX_R0,
		CONST_SRC_CODE_MDAO_VIEWTOOCCLUDER_MATRIX_R1,
		CONST_SRC_CODE_MDAO_VIEWTOOCCLUDER_MATRIX_R2,
		CONST_SRC_CODE_MDAO_VIEWTOOCCLUDER_MATRIX_R3,
		CONST_SRC_CODE_MDAO_WORLDTOOCCLUDERFRAME_MATRIX_R0,
		CONST_SRC_CODE_MDAO_WORLDTOOCCLUDERFRAME_MATRIX_R1,
		CONST_SRC_CODE_MDAO_WORLDTOOCCLUDERFRAME_MATRIX_R2,
		CONST_SRC_CODE_MDAO_WORLDTOOCCLUDERFRAME_MATRIX_R3,
		CONST_SRC_CODE_MDAO_SCREEN_PARAMS,
		CONST_SRC_CODE_MDAO_CAMERA_PARAMS,
		CONST_SRC_CODE_MDAO_LOOKUP_PARAMS,
		CONST_SRC_CODE_MDAO_VOLUME_PARAMS,
		CONST_SRC_CODE_DISTORTION_SAMPLE_LIMITS_PS,
		CONST_SRC_CODE_SCOPE_SAMPLE_LIMITS_PS,
		CONST_SRC_CODE_UV_TO_PREV_SCALED_CLIP_MAT_C0_PS,
		CONST_SRC_CODE_UV_TO_PREV_SCALED_CLIP_MAT_C1_PS,
		CONST_SRC_CODE_UV_TO_PREV_SCALED_CLIP_MAT_C3_PS,
		CONST_SRC_CODE_PREV_FRAME_VIEWPROJECTION_MATRIX_R0,
		CONST_SRC_CODE_PREV_FRAME_VIEWPROJECTION_MATRIX_R1,
		CONST_SRC_CODE_PREV_FRAME_VIEWPROJECTION_MATRIX_R2,
		CONST_SRC_CODE_PREV_FRAME_VIEWPROJECTION_MATRIX_R3,
		CONST_SRC_CODE_PREV_FRAME_WORLD_MATRIX_EYE_OFFSET,
		CONST_SRC_CODE_STATIC_VELOCITY_PARMS,
		CONST_SRC_CODE_MOTION_BLUR_HQ_PARAMS,
		CONST_SRC_CODE_MOTION_BLUR_HQ_TILE_MAX_PARAMS,
		CONST_SRC_CODE_MB_UV_TO_PREV_SCALED_CLIP_MAT_C0_PS,
		CONST_SRC_CODE_MB_UV_TO_PREV_SCALED_CLIP_MAT_C1_PS,
		CONST_SRC_CODE_MB_UV_TO_PREV_SCALED_CLIP_MAT_C3_PS,
		CONST_SRC_CODE_SHADOWMAP_SWITCH_PARTITION_ARRAY_0,
		CONST_SRC_CODE_SHADOWMAP_SWITCH_PARTITION_ARRAY_1,
		CONST_SRC_CODE_SHADOWMAP_DISTANCE_BIAS,
		CONST_SRC_CODE_SHADOWMAP_SCALE,
		CONST_SRC_CODE_SHADOWMAP_PARTITION_UV_OFFSET,
		CONST_SRC_CODE_SHADOWMAP_CASCADE_MASK,
		CONST_SRC_CODE_SHADOWMAP_DISTANCE_BLEND,
		CONST_SRC_CODE_ZNEAR,
		CONST_SRC_CODE_LIGHTING_LOOKUP_SCALE,
		CONST_SRC_CODE_INV_SCENE_PROJECTION,
		CONST_SRC_CODE_RIM_LIGHT_0_DIR,
		CONST_SRC_CODE_RIM_LIGHT_0_COLOR,
		CONST_SRC_CODE_RIM_LIGHT_1_DIR,
		CONST_SRC_CODE_RIM_LIGHT_1_COLOR,
		CONST_SRC_CODE_RIM_LIGHT_TECHNIQUE,
		CONST_SRC_CODE_DEBUG_BUMPMAP,
		CONST_SRC_CODE_MATERIAL_COLOR,
		CONST_SRC_CODE_FOG,
		CONST_SRC_CODE_FOG_COLOR_LINEAR,
		CONST_SRC_CODE_FOG_COLOR_GAMMA,
		CONST_SRC_CODE_FOG_SUN_CONSTS,
		CONST_SRC_CODE_FOG_SUN_COLOR_LINEAR,
		CONST_SRC_CODE_FOG_SUN_COLOR_GAMMA,
		CONST_SRC_CODE_FOG_SUN_DIR,
		CONST_SRC_CODE_FOG_SKY_FOG,
		CONST_SRC_CODE_FOG_HEIGHT_FOG,
		CONST_SRC_CODE_ATMOS_FOG_PARMS_0,
		CONST_SRC_CODE_ATMOS_FOG_PARMS_1,
		CONST_SRC_CODE_ATMOS_FOG_PARMS_2,
		CONST_SRC_CODE_ATMOS_FOG_PARMS_3,
		CONST_SRC_CODE_ATMOS_FOG_PARMS_4,
		CONST_SRC_CODE_ATMOS_FOG_PARMS_5,
		CONST_SRC_CODE_ATMOS_FOG_PARMS_6,
		CONST_SRC_CODE_FOG_SKY_DIR,
		CONST_SRC_CODE_FOG_DEPTHHACK,
		CONST_SRC_CODE_GLOW_SETUP,
		CONST_SRC_CODE_GLOW_APPLY,
		CONST_SRC_CODE_GLOW_SETUP_ALT_COLOR_SCALE,
		CONST_SRC_CODE_COLOR_BIAS,
		CONST_SRC_CODE_COLOR_TINT_BASE,
		CONST_SRC_CODE_COLOR_TINT_DELTA,
		CONST_SRC_CODE_COLOR_TINT_QUADRATIC_DELTA,
		CONST_SRC_CODE_PERCEPTUAL_PARMS,
		CONST_SRC_CODE_FILMIC_PARMS,
		CONST_SRC_CODE_FILMIC_SHOULDER_PARMS,
		CONST_SRC_CODE_FILMIC_TOE_PARMS,
		CONST_SRC_CODE_TONEMAP_PARMS,
		CONST_SRC_CODE_HDR_STAGE_PARMS,
		CONST_SRC_CODE_UI3D_UV_SETUP_0,
		CONST_SRC_CODE_UI3D_UV_SETUP_1,
		CONST_SRC_CODE_UI3D_UV_SETUP_2,
		CONST_SRC_CODE_UI3D_UV_SETUP_3,
		CONST_SRC_CODE_UI3D_UV_SETUP_4,
		CONST_SRC_CODE_UI3D_UV_SETUP_5,
		CONST_SRC_CODE_HUDFX_PARMS,
		CONST_SRC_CODE_HUDFX_PARMS2,
		CONST_SRC_CODE_SSSS_PARAMS,
		CONST_SRC_CODE_SSSS_SCALE,
		CONST_SRC_CODE_SSSS_KERNEL_0,
		CONST_SRC_CODE_SSSS_KERNEL_1,
		CONST_SRC_CODE_SSSS_KERNEL_2,
		CONST_SRC_CODE_SSSS_KERNEL_3,
		CONST_SRC_CODE_SSSS_KERNEL_4,
		CONST_SRC_CODE_SSSS_KERNEL_5,
		CONST_SRC_CODE_SSSS_KERNEL_6,
		CONST_SRC_CODE_SSSS_KERNEL_7,
		CONST_SRC_CODE_SSSS_KERNEL_8,
		CONST_SRC_CODE_SSSS_KERNEL_9,
		CONST_SRC_CODE_SSSS_KERNEL_10,
		CONST_SRC_CODE_SSSS_KERNEL_11,
		CONST_SRC_CODE_SSSS_KERNEL_12,
		CONST_SRC_CODE_OUTDOOR_FEATHER_PARMS,
		CONST_SRC_CODE_ENVMAP_PARMS,
		CONST_SRC_CODE_SUN_SHADOWMAP_PIXEL_ADJUST_ARRAY_0,
		CONST_SRC_CODE_SUN_SHADOWMAP_PIXEL_ADJUST_ARRAY_1,
		CONST_SRC_CODE_SUN_SHADOWMAP_PIXEL_ADJUST_ARRAY_2,
		CONST_SRC_CODE_SUN_SHADOWMAP_CASCADE_V_CLAMP,
		CONST_SRC_CODE_SUN_SHADOWMAP_NEAR_FAR_PLANE,
		CONST_SRC_CODE_SPOT_SHADOWMAP_PIXEL_ADJUST,
		CONST_SRC_CODE_SPOT_SHADOWMAP_PIXEL_ADJUST_1,
		CONST_SRC_CODE_SPOT_SHADOWMAP_PIXEL_ADJUST_2,
		CONST_SRC_CODE_SPOT_SHADOWMAP_PIXEL_ADJUST_3,
		CONST_SRC_CODE_SPOT_SHADOWMAP_PIXEL_ADJUST_ARRAY_0,
		CONST_SRC_CODE_SPOT_SHADOWMAP_PIXEL_ADJUST_ARRAY_1,
		CONST_SRC_CODE_SPOT_SHADOWMAP_PIXEL_ADJUST_ARRAY_2,
		CONST_SRC_CODE_SPOT_SHADOWMAP_PIXEL_ADJUST_ARRAY_3,
		CONST_SRC_CODE_SPOT_SHADOWMAP_ZTRANSFORM,
		CONST_SRC_CODE_SPOT_SHADOWMAP_ZTRANSFORM_1,
		CONST_SRC_CODE_SPOT_SHADOWMAP_ZTRANSFORM_2,
		CONST_SRC_CODE_SPOT_SHADOWMAP_ZTRANSFORM_3,
		CONST_SRC_CODE_SPOT_SHADOWMAP_ZTRANSFORM_ARRAY_0,
		CONST_SRC_CODE_SPOT_SHADOWMAP_ZTRANSFORM_ARRAY_1,
		CONST_SRC_CODE_SPOT_SHADOWMAP_ZTRANSFORM_ARRAY_2,
		CONST_SRC_CODE_SPOT_SHADOWMAP_ZTRANSFORM_ARRAY_3,
		CONST_SRC_CODE_COMPOSITE_FX_DISTORTION,
		CONST_SRC_CODE_POSTFX_FADE_EFFECT,
		CONST_SRC_CODE_SCENE_UV_MULT,
		CONST_SRC_CODE_SCENE_VIEW_MULT,
		CONST_SRC_CODE_TEXCOORD_CLAMP_0,
		CONST_SRC_CODE_TEXCOORD_CLAMP_1,
		CONST_SRC_CODE_VIEWPORT_DIMENSIONS,
		CONST_SRC_CODE_FRAMEBUFFER_READ,
		CONST_SRC_CODE_THERMAL_COLOR_OFFSET,
		CONST_SRC_CODE_THERMAL_FADE_CONTROL,
		CONST_SRC_CODE_THERMAL_FADE_COLOR,
		CONST_SRC_CODE_PLAYLIST_POPULATION_PARAMS,
		CONST_SRC_CODE_TESSELLATION_PARMS,
		CONST_SRC_CODE_TESSELLATION_PARMS2,
		CONST_SRC_CODE_EYE_PARAMETER_DVAR,
		CONST_SRC_CODE_MP_RIM_PARAMETER_DVAR1,
		CONST_SRC_CODE_MP_RIM_PARAMETER_DVAR2,
		CONST_SRC_CODE_HEAD_ROT_MAT_R0,
		CONST_SRC_CODE_HEAD_ROT_MAT_R1,
		CONST_SRC_CODE_HEAD_ROT_MAT_R2,
		CONST_SRC_CODE_GUN_SIGHT_COLOR,
		CONST_SRC_CODE_GUN_RETICLE_COLOR,
		CONST_SRC_CODE_BASE_LIGHTING_COORDS,
		CONST_SRC_CODE_LIGHT_PROBE_AMBIENT,
		CONST_SRC_CODE_CLIP_SPACE_LOOKUP_SCALE,
		CONST_SRC_CODE_CLIP_SPACE_LOOKUP_OFFSET,
		CONST_SRC_CODE_PARTICLE_CLOUD_TEXTURE_ATLAS_SETTINGS,
		CONST_SRC_CODE_PARTICLE_CLOUD_VEL_WORLD,
		CONST_SRC_CODE_PARTICLE_CLOUD_MATRIX0,
		CONST_SRC_CODE_PARTICLE_CLOUD_MATRIX1,
		CONST_SRC_CODE_PARTICLE_CLOUD_MATRIX2,
		CONST_SRC_CODE_PARTICLE_CLOUD_SPARK_COLOR0,
		CONST_SRC_CODE_PARTICLE_CLOUD_SPARK_COLOR1,
		CONST_SRC_CODE_PARTICLE_CLOUD_SPARK_COLOR2,
		CONST_SRC_CODE_PARTICLE_FOUNTAIN_PARM0,
		CONST_SRC_CODE_PARTICLE_FOUNTAIN_PARM1,
		CONST_SRC_CODE_LIT2D_BLOODSPATTER_FADESHARPNESS,
		CONST_SRC_CODE_BLUR_SCENE_PIXEL_POS_TO_UV,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_0,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_1,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_2,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_3,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_4,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_5,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_6,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_7,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_8,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_9,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_10,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_11,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_12,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_13,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_14,
		CONST_SRC_CODE_REACTIVEMOTION_CENTERS_15,
		CONST_SRC_CODE_DEPTH_FROM_CLIP,
		CONST_SRC_CODE_CODE_MESH_ARG_0,
		CONST_SRC_CODE_CODE_MESH_ARG_1,
		CONST_SRC_CODE_CODE_MESH_ARG_3,
		CONST_SRC_CODE_CODE_MESH_ARG_4,
		CONST_SRC_CODE_SCRIPT_CONST0,
		CONST_SRC_CODE_VIEW_MATRIX,
		CONST_SRC_CODE_INVERSE_VIEW_MATRIX,
		CONST_SRC_CODE_TRANSPOSE_VIEW_MATRIX,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_VIEW_MATRIX,
		CONST_SRC_CODE_PROJECTION_MATRIX,
		CONST_SRC_CODE_INVERSE_PROJECTION_MATRIX,
		CONST_SRC_CODE_TRANSPOSE_PROJECTION_MATRIX,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_PROJECTION_MATRIX,
		CONST_SRC_CODE_VIEW_PROJECTION_MATRIX,
		CONST_SRC_CODE_INVERSE_VIEW_PROJECTION_MATRIX,
		CONST_SRC_CODE_TRANSPOSE_VIEW_PROJECTION_MATRIX,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_VIEW_PROJECTION_MATRIX,
		CONST_SRC_CODE_SHADOW_LOOKUP_MATRIX,
		CONST_SRC_CODE_INVERSE_SHADOW_LOOKUP_MATRIX,
		CONST_SRC_CODE_TRANSPOSE_SHADOW_LOOKUP_MATRIX,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_SHADOW_LOOKUP_MATRIX,
		CONST_SRC_CODE_SHADOW_LOOKUP_MATRIX1,
		CONST_SRC_CODE_INVERSE_SHADOW_LOOKUP_MATRIX1,
		CONST_SRC_CODE_TRANSPOSE_SHADOW_LOOKUP_MATRIX1,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_SHADOW_LOOKUP_MATRIX1,
		CONST_SRC_CODE_SHADOW_LOOKUP_MATRIX2,
		CONST_SRC_CODE_INVERSE_SHADOW_LOOKUP_MATRIX2,
		CONST_SRC_CODE_TRANSPOSE_SHADOW_LOOKUP_MATRIX2,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_SHADOW_LOOKUP_MATRIX2,
		CONST_SRC_CODE_SHADOW_LOOKUP_MATRIX3,
		CONST_SRC_CODE_INVERSE_SHADOW_LOOKUP_MATRIX3,
		CONST_SRC_CODE_TRANSPOSE_SHADOW_LOOKUP_MATRIX3,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_SHADOW_LOOKUP_MATRIX3,
		CONST_SRC_CODE_WORLD_OUTDOOR_LOOKUP_MATRIX,
		CONST_SRC_CODE_INVERSE_WORLD_OUTDOOR_LOOKUP_MATRIX,
		CONST_SRC_CODE_TRANSPOSE_WORLD_OUTDOOR_LOOKUP_MATRIX,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_OUTDOOR_LOOKUP_MATRIX,
		CONST_SRC_CODE_PREV_FRAME_WORLD_MATRIX,
		CONST_SRC_CODE_PREV_FRAME_INVERSE_WORLD_MATRIX,
		CONST_SRC_CODE_PREV_FRAME_TRANSPOSE_WORLD_MATRIX,
		CONST_SRC_CODE_PREV_FRAME_INVERSE_TRANSPOSE_WORLD_MATRIX,
		CONST_SRC_CODE_WORLD_MATRIX0,
		CONST_SRC_CODE_INVERSE_WORLD_MATRIX0,
		CONST_SRC_CODE_TRANSPOSE_WORLD_MATRIX0,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_MATRIX0,
		CONST_SRC_CODE_WORLD_VIEW_MATRIX0,
		CONST_SRC_CODE_INVERSE_WORLD_VIEW_MATRIX0,
		CONST_SRC_CODE_TRANSPOSE_WORLD_VIEW_MATRIX0,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_VIEW_MATRIX0,
		CONST_SRC_CODE_WORLD_VIEW_PROJECTION_MATRIX0,
		CONST_SRC_CODE_INVERSE_WORLD_VIEW_PROJECTION_MATRIX0,
		CONST_SRC_CODE_TRANSPOSE_WORLD_VIEW_PROJECTION_MATRIX0,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_VIEW_PROJECTION_MATRIX0,
		CONST_SRC_CODE_WORLD_MATRIX1,
		CONST_SRC_CODE_INVERSE_WORLD_MATRIX1,
		CONST_SRC_CODE_TRANSPOSE_WORLD_MATRIX1,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_MATRIX1,
		CONST_SRC_CODE_WORLD_VIEW_MATRIX1,
		CONST_SRC_CODE_INVERSE_WORLD_VIEW_MATRIX1,
		CONST_SRC_CODE_TRANSPOSE_WORLD_VIEW_MATRIX1,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_VIEW_MATRIX1,
		CONST_SRC_CODE_WORLD_VIEW_PROJECTION_MATRIX1,
		CONST_SRC_CODE_INVERSE_WORLD_VIEW_PROJECTION_MATRIX1,
		CONST_SRC_CODE_TRANSPOSE_WORLD_VIEW_PROJECTION_MATRIX1,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_VIEW_PROJECTION_MATRIX1,
		CONST_SRC_CODE_WORLD_MATRIX2,
		CONST_SRC_CODE_INVERSE_WORLD_MATRIX2,
		CONST_SRC_CODE_TRANSPOSE_WORLD_MATRIX2,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_MATRIX2,
		CONST_SRC_CODE_WORLD_VIEW_MATRIX2,
		CONST_SRC_CODE_INVERSE_WORLD_VIEW_MATRIX2,
		CONST_SRC_CODE_TRANSPOSE_WORLD_VIEW_MATRIX2,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_VIEW_MATRIX2,
		CONST_SRC_CODE_WORLD_VIEW_PROJECTION_MATRIX2,
		CONST_SRC_CODE_INVERSE_WORLD_VIEW_PROJECTION_MATRIX2,
		CONST_SRC_CODE_TRANSPOSE_WORLD_VIEW_PROJECTION_MATRIX2,
		CONST_SRC_CODE_INVERSE_TRANSPOSE_WORLD_VIEW_PROJECTION_MATRIX2,
		CONST_SRC_TOTAL_COUNT,
		CONST_SRC_NONE,
	};

	enum MaterialTextureSource : std::int32_t
	{
		TEXTURE_SRC_CODE_BLACK,
		TEXTURE_SRC_CODE_WHITE,
		TEXTURE_SRC_CODE_IDENTITY_NORMAL_MAP,
		TEXTURE_SRC_CODE_MODEL_LIGHTING,
		TEXTURE_SRC_CODE_LIGHTMAP_PRIMARY,
		TEXTURE_SRC_CODE_LIGHTMAP_SECONDARY,
		TEXTURE_SRC_CODE_SHADOWMAP_SUN,
		TEXTURE_SRC_CODE_TRANS_SHADOWMAP_SUN,
		TEXTURE_SRC_CODE_SHADOWMAP_SPOT,
		TEXTURE_SRC_CODE_SHADOWMAP_SPOT_1,
		TEXTURE_SRC_CODE_SHADOWMAP_SPOT_2,
		TEXTURE_SRC_CODE_SHADOWMAP_SPOT_3,
		TEXTURE_SRC_CODE_FEEDBACK,
		TEXTURE_SRC_CODE_RESOLVED_POST_SUN,
		TEXTURE_SRC_CODE_SSR_BUFFER,
		TEXTURE_SRC_CODE_HQ_SSR_DEPTH,
		TEXTURE_SRC_CODE_BLUR_DISTORTION_BUFFER,
		TEXTURE_SRC_CODE_RESOLVED_SCENE,
		TEXTURE_SRC_CODE_POST_EFFECT_0,
		TEXTURE_SRC_CODE_POST_EFFECT_1,
		TEXTURE_SRC_CODE_LIGHT_ATTENUATION,
		TEXTURE_SRC_CODE_LIGHT_CUCOLORIS,
		TEXTURE_SRC_CODE_LIGHT_ATTENUATION1,
		TEXTURE_SRC_CODE_LIGHT_CUCOLORIS1,
		TEXTURE_SRC_CODE_LIGHT_ATTENUATION2,
		TEXTURE_SRC_CODE_LIGHT_CUCOLORIS2,
		TEXTURE_SRC_CODE_LIGHT_ATTENUATION3,
		TEXTURE_SRC_CODE_LIGHT_CUCOLORIS3,
		TEXTURE_SRC_CODE_OUTDOOR,
		TEXTURE_SRC_CODE_FLOATZ,
		TEXTURE_SRC_CODE_PROCESSED_FLOATZ,
		TEXTURE_SRC_CODE_RAW_FLOATZ,
		TEXTURE_SRC_CODE_FLOATZ_STENCIL,
		TEXTURE_SRC_CODE_RAW_STENCIL,
		TEXTURE_SRC_CODE_HALF_PARTICLES,
		TEXTURE_SRC_CODE_HALF_PARTICLES_Z,
		TEXTURE_SRC_CODE_CASE_TEXTURE,
		TEXTURE_SRC_CODE_CINEMATIC_Y,
		TEXTURE_SRC_CODE_CINEMATIC_CR,
		TEXTURE_SRC_CODE_CINEMATIC_CB,
		TEXTURE_SRC_CODE_CINEMATIC_A,
		TEXTURE_SRC_CODE_CINEMATIC_CBCR,
		TEXTURE_SRC_CODE_REFLECTION_PROBE,
		TEXTURE_SRC_CODE_DALTONIZE_CLUT,
		TEXTURE_SRC_CODE_CLUT,
		TEXTURE_SRC_CODE_LINEAR_CLAMP,
		TEXTURE_SRC_CODE_POINT_CLAMP,
		TEXTURE_SRC_CODE_BLUR_SCENE_SAVE,
		TEXTURE_SRC_CODE_RANDOM_ROTATIONS,
		TEXTURE_SRC_CODE_SSAO,
		TEXTURE_SRC_CODE_POSTFX_TEXTURE_0,
		TEXTURE_SRC_CODE_POSTFX_TEXTURE_1,
		TEXTURE_SRC_CODE_POSTFX_TEXTURE_2,
		TEXTURE_SRC_CODE_POSTFX_TEXTURE_3,
		TEXTURE_SRC_CODE_MSAA_SCENE,
		TEXTURE_SRC_CODE_DEPTH_BLUR_0,
		TEXTURE_SRC_CODE_DEPTH_BLUR_1,
		TEXTURES_SRC_CODE_DEFAULT_DEPTH,
		TEXTURE_SRC_CODE_SCENE_VELOCITY,
		TEXTURE_SRC_CODE_SCENE_VELOCITY_TILE0,
		TEXTURE_SRC_CODE_SCENE_VELOCITY_TILE1,
		TEXTURE_SRC_CODE_DOF_FLOATZ,
		TEXTURE_SRC_CODE_DOF_HALF_PREPASS,
		TEXTURE_SRC_CODE_DOF_HALF_COLOR,
		TEXTURE_SRC_CODE_DOF_HALF_ALPHA,
		TEXTURE_SRC_CODE_DOF_TILE0,
		TEXTURE_SRC_CODE_DOF_TILE1,
		TEXTURE_SRC_CODE_SCENE_SPECULAR,
		TEXTURE_SRC_CODE_SCENE_ALBEDO,
		TEXTURE_SRC_CODE_GENERIC_FLOAT_DATA,
		TEXTURE_SRC_CODE_UI3D,
		TEXTURE_SRC_CODE_STREAMING_LOADING,
		TEXTURE_SRC_CODE_MDAO_HDIR,
		TEXTURE_SRC_CODE_MDAO_DEPTH,
		TEXTURE_SRC_CODE_MDAO_OCCLUSION_VOLUME,
		TEXTURE_SRC_CODE_MDAO_LOOKUP,
		TEXTURE_SRC_CODE_TEXTURE_0,
		TEXTURE_SRC_CODE_COMPOSITE_RESULT,
		TEXTURE_SRC_CODE_FONT_CACHE,
		TEXTURE_SRC_CODE_COUNT,
	};

	enum MaterialWorldVertexFormat : std::int32_t
	{
		MTL_WORLDVERT_T1 = 0x0,
		MTL_WORLDVERT_T2N1D0 = 0x1,
		MTL_WORLDVERT_T2N1D1 = 0x2,
		MTL_WORLDVERT_T2N1D2 = 0x3,
		MTL_WORLDVERT_T2N2D0 = 0x4,
		MTL_WORLDVERT_T2N2D1 = 0x5,
		MTL_WORLDVERT_T2N2D2 = 0x6,
		MTL_WORLDVERT_T3N1D0 = 0x7,
		MTL_WORLDVERT_T3N1D1 = 0x8,
		MTL_WORLDVERT_T3N1D2 = 0x9,
		MTL_WORLDVERT_T3N1D3 = 0xA,
		MTL_WORLDVERT_T3N2D0 = 0xB,
		MTL_WORLDVERT_T3N2D1 = 0xC,
		MTL_WORLDVERT_T3N2D2 = 0xD,
		MTL_WORLDVERT_T3N2D3 = 0xE,
		MTL_WORLDVERT_T3N3D0 = 0xF,
		MTL_WORLDVERT_T3N3D1 = 0x10,
		MTL_WORLDVERT_T3N3D2 = 0x11,
		MTL_WORLDVERT_T3N3D3 = 0x12,
		MTL_WORLDVERT_T4N1D0 = 0x13,
		MTL_WORLDVERT_T4N1D1 = 0x14,
		MTL_WORLDVERT_T4N1D2 = 0x15,
		MTL_WORLDVERT_T4N1D3 = 0x16,
		MTL_WORLDVERT_T4N1D4 = 0x17,
		MTL_WORLDVERT_T4N2D0 = 0x18,
		MTL_WORLDVERT_T4N2D1 = 0x19,
		MTL_WORLDVERT_T4N2D2 = 0x1A,
		MTL_WORLDVERT_T4N2D3 = 0x1B,
		MTL_WORLDVERT_T4N2D4 = 0x1C,
		MTL_WORLDVERT_T4N3D0 = 0x1D,
		MTL_WORLDVERT_T4N3D1 = 0x1E,
		MTL_WORLDVERT_T4N3D2 = 0x1F,
		MTL_WORLDVERT_T4N3D3 = 0x20,
		MTL_WORLDVERT_T4N3D4 = 0x21,
		MTL_WORLDVERT_T4N4D0 = 0x22,
		MTL_WORLDVERT_T4N4D1 = 0x23,
		MTL_WORLDVERT_T4N4D2 = 0x24,
		MTL_WORLDVERT_T4N4D3 = 0x25,
		MTL_WORLDVERT_T4N4D4 = 0x26,
		MTL_WORLDVERT_T5N1D0 = 0x27,
		MTL_WORLDVERT_T5N1D1 = 0x28,
		MTL_WORLDVERT_T5N1D2 = 0x29,
		MTL_WORLDVERT_T5N1D3 = 0x2A,
		MTL_WORLDVERT_T5N1D4 = 0x2B,
		MTL_WORLDVERT_T5N1D5 = 0x2C,
		MTL_WORLDVERT_T5N2D0 = 0x2D,
		MTL_WORLDVERT_T5N2D1 = 0x2E,
		MTL_WORLDVERT_T5N2D2 = 0x2F,
		MTL_WORLDVERT_T5N2D3 = 0x30,
		MTL_WORLDVERT_T5N2D4 = 0x31,
		MTL_WORLDVERT_T5N2D5 = 0x32,
		MTL_WORLDVERT_T5N3D0 = 0x33,
		MTL_WORLDVERT_T5N3D1 = 0x34,
		MTL_WORLDVERT_T5N3D2 = 0x35,
		MTL_WORLDVERT_T5N3D3 = 0x36,
		MTL_WORLDVERT_T5N3D4 = 0x37,
		MTL_WORLDVERT_T5N3D5 = 0x38,
		MTL_WORLDVERT_T5N4D0 = 0x39,
		MTL_WORLDVERT_T5N4D1 = 0x3A,
		MTL_WORLDVERT_T5N4D2 = 0x3B,
		MTL_WORLDVERT_T5N4D3 = 0x3C,
		MTL_WORLDVERT_T5N4D4 = 0x3D,
		MTL_WORLDVERT_T5N4D5 = 0x3E,
		MTL_WORLDVERT_T5N5D0 = 0x3F,
		MTL_WORLDVERT_T5N5D1 = 0x40,
		MTL_WORLDVERT_T5N5D2 = 0x41,
		MTL_WORLDVERT_T5N5D3 = 0x42,
		MTL_WORLDVERT_T5N5D4 = 0x43,
		MTL_WORLDVERT_T5N5D5 = 0x44,
		MTL_WORLDVERT_T6N1D0 = 0x45,
		MTL_WORLDVERT_T6N1D1 = 0x46,
		MTL_WORLDVERT_T6N1D2 = 0x47,
		MTL_WORLDVERT_T6N1D3 = 0x48,
		MTL_WORLDVERT_T6N1D4 = 0x49,
		MTL_WORLDVERT_T6N1D5 = 0x4A,
		MTL_WORLDVERT_T6N1D6 = 0x4B,
		MTL_WORLDVERT_T6N2D0 = 0x4C,
		MTL_WORLDVERT_T6N2D1 = 0x4D,
		MTL_WORLDVERT_T6N2D2 = 0x4E,
		MTL_WORLDVERT_T6N2D3 = 0x4F,
		MTL_WORLDVERT_T6N2D4 = 0x50,
		MTL_WORLDVERT_T6N2D5 = 0x51,
		MTL_WORLDVERT_T6N2D6 = 0x52,
		MTL_WORLDVERT_T6N3D0 = 0x53,
		MTL_WORLDVERT_T6N3D1 = 0x54,
		MTL_WORLDVERT_T6N3D2 = 0x55,
		MTL_WORLDVERT_T6N3D3 = 0x56,
		MTL_WORLDVERT_T6N3D4 = 0x57,
		MTL_WORLDVERT_T6N3D5 = 0x58,
		MTL_WORLDVERT_T6N3D6 = 0x59,
		MTL_WORLDVERT_T6N4D0 = 0x5A,
		MTL_WORLDVERT_T6N4D1 = 0x5B,
		MTL_WORLDVERT_T6N4D2 = 0x5C,
		MTL_WORLDVERT_T6N4D3 = 0x5D,
		MTL_WORLDVERT_T6N4D4 = 0x5E,
		MTL_WORLDVERT_T6N4D5 = 0x5F,
		MTL_WORLDVERT_T6N4D6 = 0x60,
		MTL_WORLDVERT_T6N5D0 = 0x61,
		MTL_WORLDVERT_T6N5D1 = 0x62,
		MTL_WORLDVERT_T6N5D2 = 0x63,
		MTL_WORLDVERT_T6N5D3 = 0x64,
		MTL_WORLDVERT_T6N5D4 = 0x65,
		MTL_WORLDVERT_T6N5D5 = 0x66,
		MTL_WORLDVERT_T6N5D6 = 0x67,
		MTL_WORLDVERT_T7N1D0 = 0x68,
		MTL_WORLDVERT_T7N1D1 = 0x69,
		MTL_WORLDVERT_T7N1D2 = 0x6A,
		MTL_WORLDVERT_T7N1D3 = 0x6B,
		MTL_WORLDVERT_T7N1D4 = 0x6C,
		MTL_WORLDVERT_T7N1D5 = 0x6D,
		MTL_WORLDVERT_T7N1D6 = 0x6E,
		MTL_WORLDVERT_T7N1D7 = 0x6F,
		MTL_WORLDVERT_T7N2D0 = 0x70,
		MTL_WORLDVERT_T7N2D1 = 0x71,
		MTL_WORLDVERT_T7N2D2 = 0x72,
		MTL_WORLDVERT_T7N2D3 = 0x73,
		MTL_WORLDVERT_T7N2D4 = 0x74,
		MTL_WORLDVERT_T7N2D5 = 0x75,
		MTL_WORLDVERT_T7N2D6 = 0x76,
		MTL_WORLDVERT_T7N2D7 = 0x77,
		MTL_WORLDVERT_T7N3D0 = 0x78,
		MTL_WORLDVERT_T7N3D1 = 0x79,
		MTL_WORLDVERT_T7N3D2 = 0x7A,
		MTL_WORLDVERT_T7N3D3 = 0x7B,
		MTL_WORLDVERT_T7N3D4 = 0x7C,
		MTL_WORLDVERT_T7N3D5 = 0x7D,
		MTL_WORLDVERT_T7N3D6 = 0x7E,
		MTL_WORLDVERT_T7N3D7 = 0x7F,
		MTL_WORLDVERT_T7N4D0 = 0x80,
		MTL_WORLDVERT_T7N4D1 = 0x81,
		MTL_WORLDVERT_T7N4D2 = 0x82,
		MTL_WORLDVERT_T7N4D3 = 0x83,
		MTL_WORLDVERT_T7N4D4 = 0x84,
		MTL_WORLDVERT_T7N4D5 = 0x85,
		MTL_WORLDVERT_T7N4D6 = 0x86,
		MTL_WORLDVERT_T7N4D7 = 0x87,
		MTL_WORLDVERT_T7N5D0 = 0x88,
		MTL_WORLDVERT_T7N5D1 = 0x89,
		MTL_WORLDVERT_T7N5D2 = 0x8A,
		MTL_WORLDVERT_T7N5D3 = 0x8B,
		MTL_WORLDVERT_T7N5D4 = 0x8C,
		MTL_WORLDVERT_T7N5D5 = 0x8D,
		MTL_WORLDVERT_T7N5D6 = 0x8E,
		MTL_WORLDVERT_T7N5D7 = 0x8F,
		MTL_WORLDVERT_T8N1D0 = 0x90,
		MTL_WORLDVERT_T8N1D1 = 0x91,
		MTL_WORLDVERT_T8N1D2 = 0x92,
		MTL_WORLDVERT_T8N1D3 = 0x93,
		MTL_WORLDVERT_T8N1D4 = 0x94,
		MTL_WORLDVERT_T8N1D5 = 0x95,
		MTL_WORLDVERT_T8N1D6 = 0x96,
		MTL_WORLDVERT_T8N1D7 = 0x97,
		MTL_WORLDVERT_T8N1D8 = 0x98,
		MTL_WORLDVERT_T8N2D0 = 0x99,
		MTL_WORLDVERT_T8N2D1 = 0x9A,
		MTL_WORLDVERT_T8N2D2 = 0x9B,
		MTL_WORLDVERT_T8N2D3 = 0x9C,
		MTL_WORLDVERT_T8N2D4 = 0x9D,
		MTL_WORLDVERT_T8N2D5 = 0x9E,
		MTL_WORLDVERT_T8N2D6 = 0x9F,
		MTL_WORLDVERT_T8N2D7 = 0xA0,
		MTL_WORLDVERT_T8N2D8 = 0xA1,
		MTL_WORLDVERT_T8N3D0 = 0xA2,
		MTL_WORLDVERT_T8N3D1 = 0xA3,
		MTL_WORLDVERT_T8N3D2 = 0xA4,
		MTL_WORLDVERT_T8N3D3 = 0xA5,
		MTL_WORLDVERT_T8N3D4 = 0xA6,
		MTL_WORLDVERT_T8N3D5 = 0xA7,
		MTL_WORLDVERT_T8N3D6 = 0xA8,
		MTL_WORLDVERT_T8N3D7 = 0xA9,
		MTL_WORLDVERT_T8N3D8 = 0xAA,
		MTL_WORLDVERT_T8N4D0 = 0xAB,
		MTL_WORLDVERT_T8N4D1 = 0xAC,
		MTL_WORLDVERT_T8N4D2 = 0xAD,
		MTL_WORLDVERT_T8N4D3 = 0xAE,
		MTL_WORLDVERT_T8N4D4 = 0xAF,
		MTL_WORLDVERT_T8N4D5 = 0xB0,
		MTL_WORLDVERT_T8N4D6 = 0xB1,
		MTL_WORLDVERT_T8N4D7 = 0xB2,
		MTL_WORLDVERT_T8N4D8 = 0xB3,
		MTL_WORLDVERT_T8N5D0 = 0xB4,
		MTL_WORLDVERT_T8N5D1 = 0xB5,
		MTL_WORLDVERT_T8N5D2 = 0xB6,
		MTL_WORLDVERT_T8N5D3 = 0xB7,
		MTL_WORLDVERT_T8N5D4 = 0xB8,
		MTL_WORLDVERT_T8N5D5 = 0xB9,
		MTL_WORLDVERT_T8N5D6 = 0xBA,
		MTL_WORLDVERT_T8N5D7 = 0xBB,
		MTL_WORLDVERT_T8N5D8 = 0xBC,
		MTL_WORLDVERT_T9N1D0 = 0xBD,
		MTL_WORLDVERT_T9N1D1 = 0xBE,
		MTL_WORLDVERT_T9N1D2 = 0xBF,
		MTL_WORLDVERT_T9N1D3 = 0xC0,
		MTL_WORLDVERT_T9N1D4 = 0xC1,
		MTL_WORLDVERT_T9N1D5 = 0xC2,
		MTL_WORLDVERT_T9N1D6 = 0xC3,
		MTL_WORLDVERT_T9N1D7 = 0xC4,
		MTL_WORLDVERT_T9N1D8 = 0xC5,
		MTL_WORLDVERT_T9N2D0 = 0xC6,
		MTL_WORLDVERT_T9N2D1 = 0xC7,
		MTL_WORLDVERT_T9N2D2 = 0xC8,
		MTL_WORLDVERT_T9N2D3 = 0xC9,
		MTL_WORLDVERT_T9N2D4 = 0xCA,
		MTL_WORLDVERT_T9N2D5 = 0xCB,
		MTL_WORLDVERT_T9N2D6 = 0xCC,
		MTL_WORLDVERT_T9N2D7 = 0xCD,
		MTL_WORLDVERT_T9N2D8 = 0xCE,
		MTL_WORLDVERT_T9N3D0 = 0xCF,
		MTL_WORLDVERT_T9N3D1 = 0xD0,
		MTL_WORLDVERT_T9N3D2 = 0xD1,
		MTL_WORLDVERT_T9N3D3 = 0xD2,
		MTL_WORLDVERT_T9N3D4 = 0xD3,
		MTL_WORLDVERT_T9N3D5 = 0xD4,
		MTL_WORLDVERT_T9N3D6 = 0xD5,
		MTL_WORLDVERT_T9N3D7 = 0xD6,
		MTL_WORLDVERT_T9N3D8 = 0xD7,
		MTL_WORLDVERT_T9N4D0 = 0xD8,
		MTL_WORLDVERT_T9N4D1 = 0xD9,
		MTL_WORLDVERT_T9N4D2 = 0xDA,
		MTL_WORLDVERT_T9N4D3 = 0xDB,
		MTL_WORLDVERT_T9N4D4 = 0xDC,
		MTL_WORLDVERT_T9N4D5 = 0xDD,
		MTL_WORLDVERT_T9N4D6 = 0xDE,
		MTL_WORLDVERT_T9N4D7 = 0xDF,
		MTL_WORLDVERT_T9N4D8 = 0xE0,
		MTL_WORLDVERT_T9N5D0 = 0xE1,
		MTL_WORLDVERT_T9N5D1 = 0xE2,
		MTL_WORLDVERT_T9N5D2 = 0xE3,
		MTL_WORLDVERT_T9N5D3 = 0xE4,
		MTL_WORLDVERT_T9N5D4 = 0xE5,
		MTL_WORLDVERT_T9N5D5 = 0xE6,
		MTL_WORLDVERT_T9N5D6 = 0xE7,
		MTL_WORLDVERT_T9N5D7 = 0xE8,
		MTL_WORLDVERT_T9N5D8 = 0xE9,
		MTL_WORLDVERT_COUNT = 0xEA,
	};

	enum MaterialVertexDeclType : std::int32_t
	{
		VERTDECL_GENERIC = 0,
		VERTDECL_PACKED = 1,
		VERTDECL_PACKED_VERTLIT = 4,
		VERTDECL_PACKED_MLMAP = 5,
		VERTDECL_COUNT = 250,
	};

	enum MaterialStreamRoutingSource : std::int32_t
	{
		STREAM_SRC_POSITION = 0x0,
		STREAM_SRC_COLOR = 0x1,
		STREAM_SRC_TEXCOORD_0 = 0x2,
		STREAM_SRC_NORMAL = 0x3,
		STREAM_SRC_TANGENT = 0x4,
		STREAM_SRC_COUNT = 0x17,
	};

	enum MaterialStreamRoutingDestination : std::int32_t
	{
		STREAM_DST_POSITION = 0x0,
		STREAM_DST_NORMAL = 0x1,
		STREAM_DST_COUNT = 0x21,
	};

	struct GfxComputeShaderLoadDef
	{
		unsigned char* program;
		unsigned int programSize;
		char __pad[4];
	};

	struct ComputeShaderProgram
	{
		ID3D11ComputeShader* cs;
		GfxComputeShaderLoadDef loadDef;
	};

	struct ComputeShader
	{
		const char* name;
		ComputeShaderProgram prog;
	}; assert_sizeof(ComputeShader, 0x20);

	struct GfxVertexShaderLoadDef
	{
		unsigned char* program;
		unsigned int programSize;
		unsigned int microCodeCrc;
	};

	struct MaterialVertexShaderProgram
	{
		ID3D11VertexShader* vs;
		GfxVertexShaderLoadDef loadDef;
	};

	struct MaterialVertexShader
	{
		const char* name;
		MaterialVertexShaderProgram prog;
	}; assert_sizeof(MaterialVertexShader, 0x20);

	struct GfxPixelShaderLoadDef
	{
		unsigned char* program;
		unsigned int programSize;
		unsigned int microCodeCrc;
	};

	struct MaterialPixelShaderProgram
	{
		ID3D11PixelShader* ps;
		GfxPixelShaderLoadDef loadDef;
	};

	struct MaterialPixelShader
	{
		const char* name;
		MaterialPixelShaderProgram prog;
	}; assert_sizeof(MaterialPixelShader, 0x20);

	struct GfxHullShaderLoadDef
	{
		unsigned char* program;
		unsigned int programSize;
		char __pad[4];
	};

	struct MaterialHullShaderProgram
	{
		ID3D11HullShader* hs;
		GfxHullShaderLoadDef loadDef;
	};

	struct MaterialHullShader
	{
		const char* name;
		MaterialHullShaderProgram prog;
	}; assert_sizeof(MaterialHullShader, 0x20);

	struct GfxDomainShaderLoadDef
	{
		unsigned char* program;
		unsigned int programSize;
		char __pad[4];
	};

	struct MaterialDomainShaderProgram
	{
		ID3D11DomainShader* ds;
		GfxDomainShaderLoadDef loadDef;
	};

	struct MaterialDomainShader
	{
		const char* name;
		MaterialDomainShaderProgram prog;
	}; assert_sizeof(MaterialDomainShader, 0x20);

	struct MaterialArgumentCodeConst
	{
		unsigned short index;
		unsigned char firstRow;
		unsigned char rowCount;
	};

	union MaterialArgumentDef
	{
		float* literalConst;
		MaterialArgumentCodeConst codeConst;
		unsigned int codeSampler;
		unsigned int nameHash;
	};

	enum MaterialShaderArgumentType : std::uint8_t
	{
		MTL_ARG_CODE_CONST = 0x0,
		MTL_ARG_CODE_TEXTURE = 0x1,
		MTL_ARG_CODE_SAMPLER = 0x2,
		MTL_ARG_MATERIAL_CONST = 0x3,
		MTL_ARG_LITERAL_CONST = 0x4,
		MTL_ARG_MATERIAL_TEXTURE = 0x5,
		MTL_ARG_MATERIAL_SAMPLER = 0x6,
		MTL_ARG_COUNT = 0x7,
	};

	struct MaterialShaderArgument
	{
		unsigned char type;
		unsigned char shader;
		unsigned short dest;
		MaterialArgumentDef u;
	}; assert_sizeof(MaterialShaderArgument, 0x10);

	struct MaterialStreamRouting
	{
		unsigned char source;
		unsigned char dest;
		unsigned char mask;
	};

	struct MaterialVertexStreamRouting
	{
		MaterialStreamRouting data[32];
		ID3D11InputLayout* decl[250];
	};

	struct MaterialVertexDeclaration
	{
		const char* name;
		unsigned char streamCount;
		bool hasOptionalSource;
		MaterialVertexStreamRouting routing;
	}; assert_sizeof(MaterialVertexDeclaration, 0x840);

	struct MaterialPass
	{
		MaterialVertexShader* vertexShader;
		MaterialVertexDeclaration* vertexDecl;
		MaterialHullShader* hullShader;
		MaterialDomainShader* domainShader;
		MaterialPixelShader* pixelShader;
		unsigned char pixelOutputMask;
		unsigned char perPrimArgCount;
		unsigned char perObjArgCount;
		unsigned char stableArgCount;
		unsigned short perPrimArgSize;
		unsigned short perObjArgSize;
		unsigned short stableArgSize;
		unsigned short zone;
		unsigned char perPrimConstantBuffer;
		unsigned char perObjConstantBuffer;
		unsigned char stableConstantBuffer;
		unsigned int customBufferFlags;
		unsigned char customSamplerFlags;
		unsigned char precompiledIndex;
		unsigned char stageConfig;
		MaterialShaderArgument* args;
	};

	enum MaterialTechniqueFlags : std::uint16_t
	{
		MTL_TECHFLAG_NEEDS_RESOLVED_POST_SUN = 0x1,
		MTL_TECHFLAG_NEEDS_RESOLVED_SCENE = 0x2,
	};

	struct MaterialTechniqueHeader
	{
		const char* name;
		unsigned short flags;
		unsigned short passCount;
	};

	struct MaterialTechnique
	{
		MaterialTechniqueHeader hdr;
		MaterialPass passArray[1];
	};

	struct MaterialTechniqueSet
	{
		const char* name;
		unsigned short flags;
		unsigned char worldVertFormat;
		unsigned char preDisplacementOnlyCount;
		MaterialTechnique* techniques[240];
	}; assert_sizeof(MaterialTechniqueSet, 0x790);

	struct WaterWritable
	{
		float floatTime;
	};

	struct water_t
	{
		WaterWritable writable;
		float* H0X;
		float* H0Y;
		float* wTerm;
		int M;
		int N;
		float Lx;
		float Lz;
		float gravity;
		float windvel;
		float winddir[2];
		float amplitude;
		GfxImage* image;
		GfxImage* stagingImage;
	};

	union MaterialTextureDefInfo
	{
		GfxImage* image;
		water_t* water;
	};

	enum MaterialSamplerState : std::uint8_t
	{
		SAMPLER_FILTER_SHIFT = 0x0,
		SAMPLER_FILTER_NEAREST = 0x1,
		SAMPLER_FILTER_LINEAR = 0x2,
		SAMPLER_FILTER_ANISO2X = 0x3,
		SAMPLER_FILTER_ANISO4X = 0x4,
		SAMPLER_FILTER_CMP = 0x5,
		SAMPLER_FILTER_ANISO16X = 0x6,
		SAMPLER_FILTER_MASK = 0x7,
		SAMPLER_MIPMAP_SHIFT = 0x3,
		SAMPLER_MIPMAP_DISABLED = 0x0,
		SAMPLER_MIPMAP_NEAREST = 0x8,
		SAMPLER_MIPMAP_LINEAR = 0x10,
		SAMPLER_MIPMAP_BESPOKE = 0x18,
		SAMPLER_MIPMAP_COUNT = 0x3,
		SAMPLER_MIPMAP_MASK = 0x18,
		SAMPLER_CLAMP_U_SHIFT = 0x5,
		SAMPLER_CLAMP_V_SHIFT = 0x6,
		SAMPLER_CLAMP_W_SHIFT = 0x7,
		SAMPLER_CLAMP_U = 0x20,
		SAMPLER_CLAMP_V = 0x40,
		SAMPLER_CLAMP_W = 0x80,
		SAMPLER_CLAMP_MASK = 0xE0,
	};

	struct MaterialTextureDef
	{
		unsigned int nameHash;
		char nameStart;
		char nameEnd;
		unsigned char samplerState;
		unsigned char semantic;
		MaterialTextureDefInfo u;
	}; assert_sizeof(MaterialTextureDef, 0x10);

	struct MaterialConstantDef
	{
		unsigned int nameHash;
		char name[12];
		float literal[4];
	}; assert_sizeof(MaterialConstantDef, 0x20);

	enum GfxStateBitRawBitsIndex : std::uint32_t
	{
		GFXS_RAWBITS_CULL_INDEX = 0,
		GFXS_RAWBITS_DEPTH_STENCIL_INDEX = 1,
		GFXS_RAWBITS_UNK2_INDEX = 2,
		GFXS_RAWBITS_BLEND_INDEX = 3,
		GFXS_RAWBITS_UNK4_INDEX = 4,
		GFXS_RAWBITS_UNK5_INDEX = 5,
		GFXS_RAWBITS_COUNT = 6
	};

	enum GfxStateBitRawBits0 : std::uint32_t
	{
		GFXS0_ATEST_DISABLE = 0x1,
		GFXS0_ATEST_SHIFT = 0x1,
		GFXS0_ATEST_GT_0 = 0x2,
		GFXS0_ATEST_LT_128 = 0x4,
		GFXS0_ATEST_GE_128 = 0x6,
		GFXS0_ATEST_MASK = 0x6,
		GFXS0_CULL_SHIFT = 0x3,
		GFXS0_CULL_NONE = 0x8,
		GFXS0_CULL_BACK = 0x10,
		GFXS0_CULL_FRONT = 0x18,
		GFXS0_CULL_MASK = 0x18,
		GFXS0_POLYMODE_LINE = 0x20,
		GFXS0_GAMMAWRITE = 0x40,
	};

	enum GfxStateBitRawBits1 : std::uint32_t
	{
		GFXS1_DEPTHWRITE = 0x1,
		GFXS1_DEPTHTEST_SHIFT = 0x1,
		GFXS1_DEPTHTEST_ALWAYS = 0x0,
		GFXS1_DEPTHTEST_LESS = 0x2,
		GFXS1_DEPTHTEST_EQUAL = 0x4,
		GFXS1_DEPTHTEST_LESSEQUAL = 0x6,
		GFXS1_DEPTHTEST_GREAT = 0x8,
		GFXS1_DEPTHTEST_GREATEQUAL = 0xA,
		GFXS1_DEPTHTEST_DISABLE = 0xC,
		GFXS1_DEPTHTEST_MASK = 0xE,
		GFXS1_POLYGON_OFFSET_SHIFT = 0x4,
		GFXS1_POLYGON_OFFSET_0 = 0x0,
		GFXS1_POLYGON_OFFSET_1 = 0x10,
		GFXS1_POLYGON_OFFSET_2 = 0x20,
		GFXS1_POLYGON_OFFSET_SHADOWMAP = 0x30,
		GFXS1_POLYGON_OFFSET_MASK = 0x30,
		GFXS1_STENCIL_FRONT_ENABLE = 0x40,
		GFXS1_STENCIL_BACK_ENABLE = 0x80,
		GFXS1_STENCIL_MASK = 0xC0,
		GFXS1_STENCIL_FRONT_PASS_SHIFT = 0x8,
		GFXS1_STENCIL_FRONT_FAIL_SHIFT = 0xB,
		GFXS1_STENCIL_FRONT_ZFAIL_SHIFT = 0xE,
		GFXS1_STENCIL_FRONT_FUNC_SHIFT = 0x11,
		GFXS1_STENCIL_FRONT_MASK = 0xFFF00,
		GFXS1_STENCIL_BACK_PASS_SHIFT = 0x14,
		GFXS1_STENCIL_BACK_FAIL_SHIFT = 0x17,
		GFXS1_STENCIL_BACK_ZFAIL_SHIFT = 0x1A,
		GFXS1_STENCIL_BACK_FUNC_SHIFT = 0x1D,
		GFXS1_STENCIL_BACK_MASK = 0xFFF00000,
		GFXS1_STENCILFUNC_FRONTBACK_MASK = 0xE00E0000,
		GFXS1_STENCILOP_FRONTBACK_MASK = 0x1FF1FF00,
	};

	enum GfxStateBitRawBits2 : std::uint32_t
	{
		GFXS2_STENCIL_READMASK_SHIFT = 0x0,
		GFXS2_STENCIL_READMASK_BITS = 0x8,
		GFXS2_STENCIL_READMASK_MASK = 0xFF,
		GFXS2_STENCIL_WRITEMASK_SHIFT = 0x8,
		GFXS2_STENCIL_WRITEMASK_BITS = 0x8,
		GFXS2_STENCIL_WRITEMASK_MASK = 0xFF,
		GFXS2_STENCIL_REF_SHIFT = 0x10,
		GFXS2_STENCIL_REF_BITS = 0x8,
		GFXS2_STENCIL_REF_MASK = 0xFF,
		GFXS2_STENCIL_REF_ZERO = 0x0,
		GFXS2_STENCIL_REF_BIT_0 = 0x10000,
		GFXS2_STENCIL_REF_BIT_1 = 0x20000,
		GFXS2_STENCIL_REF_BIT_2 = 0x40000,
		GFXS2_STENCIL_REF_BIT_3 = 0x80000,
		GFXS2_STENCIL_REF_BIT_4 = 0x100000,
		GFXS2_STENCIL_REF_BIT_5 = 0x200000,
		GFXS2_STENCIL_REF_BIT_6 = 0x400000,
		GFXS2_STENCIL_REF_BIT_7 = 0x800000,
	};

	enum GfxStateBitRawBits3 : std::uint32_t
	{
		GFXS3_SRCBLEND_RGB_SHIFT = 0x0,
		GFXS3_SRCBLEND_RGB_MASK = 0xF,
		GFXS3_DSTBLEND_RGB_SHIFT = 0x4,
		GFXS3_DSTBLEND_RGB_MASK = 0xF0,
		GFXS3_BLENDOP_RGB_SHIFT = 0x8,
		GFXS3_BLENDOP_RGB_MASK = 0x700,
		GFXS3_BLEND_RGB_MASK = 0x7FF,
		GFXS3_SRCBLEND_ALPHA_SHIFT = 0xC,
		GFXS3_SRCBLEND_ALPHA_MASK = 0xF000,
		GFXS3_DSTBLEND_ALPHA_SHIFT = 0x10,
		GFXS3_DSTBLEND_ALPHA_MASK = 0xF0000,
		GFXS3_BLENDOP_ALPHA_SHIFT = 0x14,
		GFXS3_BLENDOP_ALPHA_MASK = 0x700000,
		GFXS3_BLEND_ALPHA_MASK = 0x7FF000,
		GFXS3_BLEND_COLORWRITE_SHIFT = 0x18,
		GFXS3_BLEND_COLORWRITE_R = 0x1000000,
		GFXS3_BLEND_COLORWRITE_G = 0x2000000,
		GFXS3_BLEND_COLORWRITE_B = 0x4000000,
		GFXS3_BLEND_COLORWRITE_A = 0x8000000,
		GFXS3_BLEND_COLORWRITE_RGB = 0x7000000,
		GFXS3_BLEND_COLORWRITE_MASK = 0xF000000,
		GFXS3_DEPTHWRITE_OPAQUE = 0x10000000,
	};

	enum GfxStateBitRawBits4 : std::uint32_t
	{
		// blend1
	};

	enum GfxStateBitRawBits5 : std::uint32_t
	{
		// blend2
	};

	enum GfxStencilOp
	{
		GFXS_STENCILOP_KEEP = 0x0,
		GFXS_STENCILOP_ZERO = 0x1,
		GFXS_STENCILOP_REPLACE = 0x2,
		GFXS_STENCILOP_INCRSAT = 0x3,
		GFXS_STENCILOP_DECRSAT = 0x4,
		GFXS_STENCILOP_INVERT = 0x5,
		GFXS_STENCILOP_INCR = 0x6,
		GFXS_STENCILOP_DECR = 0x7,

		GFXS_STENCILOP_COUNT = 0x8,
		GFXS_STENCILOP_MASK = 0x7
	};

	enum GfxStencilFunc
	{
		GFXS_STENCILFUNC_NEVER = 0x0,
		GFXS_STENCILFUNC_LESS = 0x1,
		GFXS_STENCILFUNC_EQUAL = 0x2,
		GFXS_STENCILFUNC_LESSEQUAL = 0x3,
		GFXS_STENCILFUNC_GREATER = 0x4,
		GFXS_STENCILFUNC_NOTEQUAL = 0x5,
		GFXS_STENCILFUNC_GREATEREQUAL = 0x6,
		GFXS_STENCILFUNC_ALWAYS = 0x7,

		GFXS_STENCILFUNC_COUNT = 0x8,
		GFXS_STENCILFUNC_MASK = 0x7,
	};

	struct GfxStateBitsRawBits
	{
		GfxStateBitRawBits0 loadbit0;
		GfxStateBitRawBits1 loadbit1;
		GfxStateBitRawBits2 loadbit2;
		GfxStateBitRawBits3 loadbit3;
		GfxStateBitRawBits4 loadbit4;
		GfxStateBitRawBits5 loadbit5;
	};

	union GfxStateBitsRaw
	{
		GfxStateBitsRawBits flags;
		std::uint32_t loadBits[6];
	};

	enum GfxDepthStencilMode : std::int32_t
	{
		GFX_DEPTH_STENCIL_MODE_DEFAULT = 0,
		GFX_DEPTH_STENCIL_MODE_HUD_OUTLINE_ZFAIL = 1,
		GFX_DEPTH_STENCIL_MODE_MOTION_BLUR_HQ = 2,
		GFX_DEPTH_STENCIL_MODE_DEPTH_HACK = 3,
		GFX_DEPTH_STENCIL_MODE_UNK = 4,
		GFX_DEPTH_STENCIL_MODE_FORCE_DEPTH_WRITE = 5,
		GFX_DEPTH_STENCIL_MODE_FORCE_DEPTH_WRITE_HUD_OUTLINE_ZFAIL = 6,
		GFX_DEPTH_STENCIL_MODE_CACHED_SPOT_STENCIL_INCR_SAT = 7,
		GFX_DEPTH_STENCIL_MODE_CACHED_SPOT_STENCIL_INCR_SAT_CLEAR_DEPTH = 8,
		GFX_DEPTH_STENCIL_MODE_CACHED_SPOT_STENCIL_FULL_MASK = 9,
		GFX_DEPTH_STENCIL_MODE_COUNT = 10,
	};

	enum RasterizerState : std::uint8_t
	{
		RASTERIZER_STATE_CULL_SHIFT = 0x0,
		RASTERIZER_STATE_CULL_MASK = 0x3,
		RASTERIZER_STATE_POLYGON_OFFSET_SHIFT = 0x2,
		RASTERIZER_STATE_POLYGON_OFFSET_MASK = 0xC,
		RASTERIZER_STATE_POLYMODE_LINE_SHIFT = 0x4,
		RASTERIZER_STATE_POLYMODE_LINE_MASK = 0x10,
		RASTERIZER_STATE_INDEX_MASK = 0x1F,
		RASTERIZER_STATE_ATEST_SHIFT = 0x5,
		RASTERIZER_STATE_ATEST_MASK = 0x60,
		RASTERIZER_STATE_GAMMAWRITE_SHIFT = 0x7,
		RASTERIZER_STATE_GAMMAWRITE_MASK = 0x80,
	};

	struct GfxStateBits
	{
		unsigned int loadBits[6]; // loadbits[3], blendstatebits[3]
		unsigned short zone;
		unsigned char depthStencilState[10];
		unsigned char blendState;
		unsigned char rasterizerState;
		char __pad0[2];
	}; assert_sizeof(GfxStateBits, 0x28);

	struct MaterialConstantBufferDef
	{
		unsigned int vsDataSize;
		unsigned int hsDataSize;
		unsigned int dsDataSize;
		unsigned int psDataSize;
		unsigned int vsOffsetDataSize;
		unsigned int hsOffsetDataSize;
		unsigned int dsOffsetDataSize;
		unsigned int psOffsetDataSize;
		unsigned char* vsData;
		unsigned char* hsData;
		unsigned char* dsData;
		unsigned char* psData;
		unsigned short* vsOffsetData;
		unsigned short* hsOffsetData;
		unsigned short* dsOffsetData;
		unsigned short* psOffsetData;
		ID3D11Buffer* vsConstantBuffer;
		ID3D11Buffer* hsConstantBuffer;
		ID3D11Buffer* dsConstantBuffer;
		ID3D11Buffer* psConstantBuffer;
	};

	enum MaterialGameFlags : std::uint8_t
	{
		MTL_GAMEFLAG_NONE = 0x0,
		MTL_GAMEFLAG_1 = 0x1,
		MTL_GAMEFLAG_2 = 0x2,
		MTL_GAMEFLAG_4 = 0x4,
		MTL_GAMEFLAG_8 = 0x8,
		MTL_GAMEFLAG_10 = 0x10,
		MTL_GAMEFLAG_20 = 0x20,
		MTL_GAMEFLAG_CASTS_SHADOW = 0x40,
		MTL_GAMEFLAG_EFFECT = 0x80,
	};

	enum MaterialSortKey : std::uint8_t
	{
		MTL_SORTKEY_NONE = 0,
		MTL_SORTKEY_OPAQUE_AMBIENT = 1,
		MTL_SORTKEY_OPAQUE = 2,
		MTL_SORTKEY_SKY = 3,
		MTL_SORTKEY_SUN = 4,

		MTL_SORTKEY_UNKNOWN5 = 5,
		MTL_SORTKEY_UNKNOWN6 = 6,

		MTL_SORTKEY_LIT_DECAL = 7, // c

		MTL_SORTKEY_UNKNOWN8 = 8,
		MTL_SORTKEY_UNKNOWN9 = 9,
		MTL_SORTKEY_UNKNOWN10 = 10,
		MTL_SORTKEY_UNKNOWN11 = 11,
		MTL_SORTKEY_UNKNOWN12 = 12,
		MTL_SORTKEY_UNKNOWN13 = 13,

		MTL_SORTKEY_WEAPON_IMPACT = 14,

		MTL_SORTKEY_UNKNOWN15 = 15,
		MTL_SORTKEY_UNKNOWN16 = 16,

		MTL_SORTKEY_TOP_DECAL = 17, // c
		MTL_SORTKEY_HAIR = 18, // c

		MTL_SORTKEY_UNKNOWN19 = 19, // blend/additive
		MTL_SORTKEY_UNKNOWN20 = 20,
		MTL_SORTKEY_UNKNOWN21 = 21,
		MTL_SORTKEY_UNKNOWN22 = 22,
		MTL_SORTKEY_UNKNOWN23 = 23,
		MTL_SORTKEY_UNKNOWN24 = 24,
		MTL_SORTKEY_UNKNOWN25 = 25,

		MTL_SORTKEY_WINDOW_INSIDE = 26,
		MTL_SORTKEY_WINDOW_OUTSIDE = 27,

		MTL_SORTKEY_UNKNOWN28 = 28,
		MTL_SORTKEY_UNKNOWN29 = 29,
		MTL_SORTKEY_UNKNOWN30 = 30,
		MTL_SORTKEY_UNKNOWN31 = 31,
		MTL_SORTKEY_UNKNOWN32 = 32,
		MTL_SORTKEY_UNKNOWN33 = 33, // impact glass / impact riotshield
		MTL_SORTKEY_UNKNOWN34 = 34,
		MTL_SORTKEY_UNKNOWN35 = 35,
		MTL_SORTKEY_UNKNOWN36 = 36,
		MTL_SORTKEY_UNKNOWN37 = 37,
		MTL_SORTKEY_UNKNOWN38 = 38,
		MTL_SORTKEY_UNKNOWN39 = 39,
		MTL_SORTKEY_UNKNOWN40 = 40,
		MTL_SORTKEY_UNKNOWN41 = 41,
		MTL_SORTKEY_UNKNOWN42 = 42,

		MTL_SORTKEY_EFFECT_DECAL = 43, // c

		MTL_SORTKEY_UNKNOWN44 = 44,
		MTL_SORTKEY_UNKNOWN45 = 45,
		MTL_SORTKEY_UNKNOWN46 = 46,
		MTL_SORTKEY_UNKNOWN47 = 47,
		MTL_SORTKEY_UNKNOWN48 = 48,
		MTL_SORTKEY_UNKNOWN49 = 49,
		MTL_SORTKEY_UNKNOWN50 = 50,
		MTL_SORTKEY_UNKNOWN51 = 51,
		MTL_SORTKEY_UNKNOWN52 = 52, // overlay

		MTL_SORTKEY_EFFECT_AUTO = 53, // c

		MTL_SORTKEY_UNKNOWN54 = 54,
		MTL_SORTKEY_UNKNOWN55 = 55,
		MTL_SORTKEY_UNKNOWN56 = 56, // additive

		MTL_SORT_PRIMARY_COUNT = 0x40,
	};

	enum SurfaceTypeBits : std::uint64_t
	{
		SURFTYPE_BITS_DEFAULT = 0x0,
		SURFTYPE_BITS_BARK = 0x1,
		SURFTYPE_BITS_BRICK = 0x2,
		SURFTYPE_BITS_CARPET = 0x4,
		SURFTYPE_BITS_CLOTH = 0x8,
		SURFTYPE_BITS_CONCRETE = 0x10,
		SURFTYPE_BITS_DIRT = 0x20,
		SURFTYPE_BITS_FLESH = 0x40,
		SURFTYPE_BITS_FOLIAGE_DEBRIS = 0x80,
		SURFTYPE_BITS_GLASS = 0x100,
		SURFTYPE_BITS_GRASS = 0x200,
		SURFTYPE_BITS_GRAVEL = 0x400,
		SURFTYPE_BITS_ICE = 0x800,
		SURFTYPE_BITS_METAL_SOLID = 0x1000,
		SURFTYPE_BITS_METAL_GRATE = 0x2000,
		SURFTYPE_BITS_MUD = 0x4000,
		SURFTYPE_BITS_PAPER = 0x8000,
		SURFTYPE_BITS_PLASTER = 0x10000,
		SURFTYPE_BITS_ROCK = 0x20000,
		SURFTYPE_BITS_SAND = 0x40000,
		SURFTYPE_BITS_SNOW = 0x80000,
		SURFTYPE_BITS_WATER_WAIST = 0x100000,
		SURFTYPE_BITS_WOOD_SOLID = 0x200000,
		SURFTYPE_BITS_ASPHALT = 0x400000,
		SURFTYPE_BITS_CERAMIC = 0x800000,
		SURFTYPE_BITS_PLASTIC_SOLID = 0x1000000,
		SURFTYPE_BITS_RUBBER = 0x2000000,
		SURFTYPE_BITS_FRUIT = 0x4000000,
		SURFTYPE_BITS_PAINTEDMETAL = 0x8000000,
		SURFTYPE_BITS_RIOTSHIELD = 0x10000000,
		SURFTYPE_BITS_SLUSH = 0x20000000,
		SURFTYPE_BITS_ASPHALT_WET = 0x40000000,
		SURFTYPE_BITS_ASPHALT_DEBRIS = 0x80000000,
		SURFTYPE_BITS_CONCRETE_WET = 0x100000000,
		SURFTYPE_BITS_CONCRETE_DEBRIS = 0x200000000,
		SURFTYPE_BITS_FOLIAGE_VEGETATION = 0x400000000,
		SURFTYPE_BITS_FOLIAGE_LEAVES = 0x800000000,
		SURFTYPE_BITS_GRASS_TALL = 0x1000000000,
		SURFTYPE_BITS_METAL_HOLLOW = 0x2000000000,
		SURFTYPE_BITS_METAL_VEHICLE = 0x4000000000,
		SURFTYPE_BITS_METAL_THIN = 0x8000000000,
		SURFTYPE_BITS_METAL_WET = 0x10000000000,
		SURFTYPE_BITS_METAL_DEBRIS = 0x20000000000,
		SURFTYPE_BITS_PLASTIC_HOLLOW = 0x40000000000,
		SURFTYPE_BITS_PLASTIC_TARP = 0x80000000000,
		SURFTYPE_BITS_ROCK_WET = 0x100000000000,
		SURFTYPE_BITS_ROCK_DEBRIS = 0x200000000000,
		SURFTYPE_BITS_WATER_ANKLE = 0x400000000000,
		SURFTYPE_BITS_WATER_KNEE = 0x800000000000,
		SURFTYPE_BITS_WOOD_HOLLOW = 0x1000000000000,
		SURFTYPE_BITS_WOOD_WET = 0x2000000000000,
		SURFTYPE_BITS_WOOD_DEBRIS = 0x4000000000000,
		SURFTYPE_BITS_CUSHION = 0x8000000000000,
	};

	struct MaterialInfo
	{
		const char* name;
		unsigned char gameFlags;
		unsigned char sortKey;
		unsigned char textureAtlasRowCount;
		unsigned char textureAtlasColumnCount;
		unsigned char textureAtlasFrameBlend;
		unsigned char textureAtlasAsArray;
		unsigned char renderFlags;
		GfxDrawSurf drawSurf;
		SurfaceTypeBits surfaceTypeBits;
		unsigned int hashIndex;
	}; assert_sizeof(MaterialInfo, 48);

	enum MaterialStateFlags : std::uint8_t
	{
		STATE_FLAG_CULL_BACK = 0x1,
		STATE_FLAG_DECAL = 0x4,
		STATE_FLAG_WRITES_DEPTH = 0x8,
		STATE_FLAG_USES_DEPTH_BUFFER = 0x10,
		STATE_FLAG_USES_STENCIL_BUFFER = 0x20,
	};

	enum GfxCameraRegionType : std::uint8_t
	{
		CAMERA_REGION_LIT_OPAQUE = 0x0,
		CAMERA_REGION_LIT_OPAQUE_SSS = 0x1,
		CAMERA_REGION_LIT_DECAL = 0x2,
		CAMERA_REGION_LIT_TRANS = 0x3,
		CAMERA_REGION_EMISSIVE = 0x4,
		CAMERA_REGION_DEPTH_HACK = 0x5,
		CAMERA_REGION_DEPTH_HACK_TRANS = 0x6,
		CAMERA_REGION_DEPTH_HACK_SSS = 0x7,
		CAMERA_REGION_PRE_DEPTH_HACK = 0x8,
		CAMERA_REGION_PRE_DEPTH_HACK_SSS = 0x9,
		CAMERA_REGION_PRE_OPAQUE = 0xA,
		CAMERA_REGION_PRE_SSS = 0xB,
		CAMERA_REGION_COUNT = 0xC,
		CAMERA_REGION_NONE = 0xC,
	};

	enum MaterialType : std::uint8_t
	{
		MTL_TYPE_DEFAULT = 0x0, // ""
		MTL_TYPE_MODEL = 0x1, // "m"
		MTL_TYPE_MODEL_GREY = 0x2, // "me"
		MTL_TYPE_MODEL_VERTCOL = 0x3, // "mc"
		MTL_TYPE_MODEL_VERTCOL_GREY = 0x4, // "mce"
		MTL_TYPE_MODEL_VERTLIT = 0xD, // "mv"
		MTL_TYPE_MODEL_VERTLIT_VERTCOL = 0xE, // "mvc"
		MTL_TYPE_MODEL_LMAP = 0x13, // "ml"
		MTL_TYPE_MODEL_LMAP_VERTCOL = 0x14, // "mlc"
		MTL_TYPE_MODEL_SUBDIV = 0x19, // "ms"
		MTL_TYPE_MODEL_SUBDIV_VERTCOL = 0x1A, // "msc"
		MTL_TYPE_MODEL_SUBDIV_VERTLIT = 0x1F, // "msv"
		MTL_TYPE_WORLD = 0x23, // "w"
		MTL_TYPE_WORLD_VERTCOL = 0x24, // "wc"
		MTL_TYPE_COUNT = 0x24,
	};

	enum MaterialAssetFlags : std::uint8_t
	{
		MTL_ASSETFLAG_NONE = 0x0,
		MTL_ASSETFLAG_CB_IS_WRITABLE = 0x1,
	};

	struct Material
	{
		union
		{
			const char* name;
			MaterialInfo info;
		};
		unsigned char stateBitsEntry[240];
		unsigned char textureCount;
		unsigned char constantCount;
		unsigned char stateBitsCount;
		unsigned char stateFlags;
		unsigned char cameraRegion;
		unsigned char materialType;
		unsigned char layerCount;
		unsigned char assetFlags;
		MaterialTechniqueSet* techniqueSet;
		MaterialTextureDef* textureTable;
		MaterialConstantDef* constantTable;
		GfxStateBits* stateBitsTable;
		unsigned char constantBufferIndex[240];
		MaterialConstantBufferDef* constantBufferTable;
		unsigned char constantBufferCount;
		const char** subMaterials;
	}; assert_sizeof(Material, 0x250);

	struct GfxImageLoadDef
	{
		char levelCount;
		char numElements;
		char pad[2];
		int flags;
		int format;
		int resourceSize;
		char data[1];
	};

	struct GfxTexture
	{
		union
		{
			ID3D11Texture1D* linemap;
			ID3D11Texture2D* map;
			ID3D11Texture3D* volmap;
			ID3D11Texture2D* cubemap;
			GfxImageLoadDef* loadDef;
		};
		ID3D11ShaderResourceView* shaderView;
		ID3D11ShaderResourceView* shaderViewAlternate;
	};

	struct PicMip
	{
		unsigned char platform[2];
	};

	struct CardMemory
	{
		unsigned char platform[2];
	};

	struct GfxImageStreamLevelCountAndSize
	{
		int pixelSize : 26;
		int levelCount : 6;
	};

	struct GfxImageStreamData
	{
		unsigned short width;
		unsigned short height;
		GfxImageStreamLevelCountAndSize levelCountAndSize;
	};

	enum MapType : std::uint8_t
	{
		MAPTYPE_NONE = 0x0,
		MAPTYPE_INVALID1 = 0x1,
		MAPTYPE_1D = 0x2,
		MAPTYPE_2D = 0x3,
		MAPTYPE_3D = 0x4,
		MAPTYPE_CUBE = 0x5,
		MAPTYPE_ARRAY = 0x6,
		MAPTYPE_COUNT = 0x7,
	};

	enum IMG_TS : std::uint8_t
	{
		TS_2D = 0x0,
		TS_FUNCTION = 0x1,
		TS_COLOR_MAP = 0x2,
		TS_DETAIL_MAP = 0x3,
		TS_UNUSED_2 = 0x4,
		TS_NORMAL_MAP = 0x5,
		TS_UNUSED_3 = 0x6,
		TS_UNUSED_4 = 0x7,
		TS_SPECULAR_MAP = 0x8,
		TS_UNUSED_5 = 0x9,
		TS_OCEANFLOW_DISPLACEMENT_MAP = 0xA,
		TS_WATER_MAP = 0xB,
		TS_OCEAN_DISPLACEMENT_MAP = 0xC,
		TS_DISPLACEMENT_MAP = 0xD,
		TS_PARALLAX_MAP = 0xE,
		TS_COUNT = 0xF,
	};

	enum IMG_CATEGORY : std::uint8_t
	{
		IMG_CATEGORY_UNKNOWN = 0x0,
		IMG_CATEGORY_AUTO_GENERATED = 0x1,
		IMG_CATEGORY_LIGHTMAP = 0x2,
		IMG_CATEGORY_LOAD_FROM_FILE = 0x3,
		IMG_CATEGORY_RAW = 0x4,
		IMG_CATEGORY_FIRST_UNMANAGED = 0x5,
		IMG_CATEGORY_WATER = 0x5,
		IMG_CATEGORY_RENDERTARGET = 0x6,
		IMG_CATEGORY_TEMP = 0x7,
	};

	enum IMAGE_FLAG : std::uint8_t
	{
		IMAGE_FLAG_USE_SRGB_READS = 0x1,
		IMAGE_FLAG_NOMIPMAPS = 0x2,
		IMAGE_FLAG_DELAY_LOAD_PIXELS = 0x4,
		IMAGE_FLAG_PARABOLOID = 0x8,
		IMAGE_FLAG_HEATMAP = 0x10,
		IMAGE_FLAG_STAGING = 0x20,
		IMAGE_FLAG_TRANSIENT = 0x40,
	};

	struct GfxImage
	{
		GfxTexture texture;
		DXGI_FORMAT imageFormat;
		MapType mapType;
		unsigned char semantic;
		unsigned char category;
		unsigned char flags;
		PicMip picmip;
		CardMemory cardMemory;
		unsigned int dataLen1;
		unsigned int dataLen2;
		unsigned short width;
		unsigned short height;
		unsigned short depth;
		unsigned short numElements; // arraySize
		unsigned char levelCount; // mipLevels
		unsigned char streamed;
		char __pad1[2];
		unsigned char* pixelData;
		GfxImageStreamData streams[4];
		const char* name;
	}; assert_sizeof(GfxImage, 0x68);

	enum snd_alias_type_t : std::int8_t
	{
		SAT_UNKNOWN = 0x0,
		SAT_LOADED = 0x1,
		SAT_STREAMED = 0x2,
		SAT_PRIMED = 0x3,
		SAT_COUNT = 0x4,
	};

	struct StreamFileNameRaw
	{
		const char* dir;
		const char* name;
	};

	struct StreamFileNamePacked
	{
		unsigned __int64 offset;
		unsigned __int64 length;
	};

	union StreamFileInfo
	{
		StreamFileNameRaw raw;
		StreamFileNamePacked packed;
	};

	struct StreamFileName
	{
		bool isLocalized;
		bool isStreamed;
		unsigned short fileIndex;
		StreamFileInfo info;
	};

	struct StreamedSound
	{
		StreamFileName filename;
		unsigned int totalMsec;
	};

	enum LoadedSoundFormat : std::int16_t
	{
		SND_FORMAT_PCM = 0x1,
		SND_FORMAT_FLAC = 0x6,
	};

	struct LoadedSoundInfo
	{
		char* data;
		unsigned int sampleRate;
		unsigned int dataByteCount;
		unsigned int numSamples;
		char channels;
		char numBits;
		char blockAlign;
		short format;
		int loadedSize;
	}; assert_sizeof(LoadedSoundInfo, 0x20);

	struct LoadedSound
	{
		const char* name;
		StreamFileName filename;
		LoadedSoundInfo info;
	}; assert_sizeof(LoadedSound, 0x40);

	struct PrimedSound
	{
		LoadedSound* loadedPart;
		StreamFileName streamedPart;
		int dataOffset; // not sure
		int totalSize; // not sure
	}; assert_sizeof(PrimedSound, 0x28);

	union SoundFileRef
	{
		LoadedSound* loadSnd;
		StreamedSound streamSnd;
		PrimedSound primedSnd;
	};

	struct SoundFile
	{
		snd_alias_type_t type;
		bool exists;
		SoundFileRef u;
	};

	struct SndContext
	{
		const char* name;
		unsigned char priority;
		char __pad0[7];
	};

	struct SndCurve
	{
		bool isDefault;
		union
		{
			const char* filename;
			const char* name;
		};
		unsigned short knotCount;
		float knots[16][2];
	}; assert_sizeof(SndCurve, 0x98);

	struct SpeakerLevels
	{
		char speaker;
		char numLevels;
		float levels[2];
	};

	struct ChannelMap
	{
		int speakerCount;
		SpeakerLevels speakers[6];
	};

	struct SpeakerMap
	{
		bool isDefault;
		const char* name;
		unsigned char orientation;
		ChannelMap channelMaps[2][2];
	}; assert_sizeof(SpeakerMap, 0x148);

	struct DopplerPreset
	{
		const char* name;
		float speedOfSound;
		float playerVelocityScale;
		float minPitch;
		float maxPitch;
		float smoothing;
	}; assert_sizeof(DopplerPreset, 0x20);

	enum snd_alias_flag
	{
		SND_ALIAS_FLAG_LOOPING = 0x1, // >> 0
		SND_ALIAS_FLAG_IS_MASTER = 0x2, // >> 1
		SND_ALIAS_FLAG_IS_SLAVE = 0x4, // >> 2
		SND_ALIAS_FLAG_FULLDRY = 0x8, // >> 3
		SND_ALIAS_FLAG_NO_WET_LEVEL = 0x10, // >> 4
		SND_ALIAS_FLAG_RANDOM_LOOPING = 0x20, // >> 5
		SND_ALIAS_FLAG_SPATIALIZED_RANGE_CHECK = 0x40, // >> 6
		SND_ALIAS_FLAG_SPATIALIZED_IS3D = 0x80, // >> 7
		SND_ALIAS_FLAG_SPATIALIZED_MASK = 0xC0,
		SND_ALIAS_FLAG_UNK100 = 0x100, // >> 8
		SND_ALIAS_FLAG_UNK200 = 0x200, // >> 9
		SND_ALIAS_FLAG_INHERIT_PITCH = 0x400, // >> 10
		SND_ALIAS_FLAG_INHERIT_VOLUME = 0x800, // >> 11
		SND_ALIAS_FLAG_USE_CONTEXT_LIST = 0x1000, // >> 12
		SND_ALIAS_FLAG_USE_NO_PANNING_2D = 0x2000, // >> 13
		SND_ALIAS_FLAG_USE_OLD_PANNING = 0x4000, // >> 14
		SND_ALIAS_FLAG_USE_NO_PANNING_3D = 0x8000, // >> 15
		SND_ALIAS_FLAG_TYPE_SHIFT = 0x10000, // >> 16
		SND_ALIAS_FLAG_TYPE_MASK = 0x70000,
	};

	union SoundAliasFlags
	{
		struct packed
		{
			unsigned int looping : 1;
			unsigned int isMaster : 1;
			unsigned int isSlave : 1;
			unsigned int fullDryLevel : 1;
			unsigned int noWetLevel : 1;
			unsigned int randomLooping : 1;
			unsigned int spatializedRangeCheck : 1;
			unsigned int spatializedIs3D : 1;
			unsigned int unk9 : 2; // seems to be set, but cannot find any references for use
			unsigned int inheritPitch : 1;
			unsigned int inheritVolume : 1;
			unsigned int useContextList : 1;
			unsigned int useNoPanning2D : 1;
			unsigned int useOldPanning : 1;
			unsigned int useNoPanning3D : 1;
			unsigned int type : 3;
			unsigned int unused : 13;
		} packed;
		unsigned int intValue;
	};

	enum SoundDspBus : std::int8_t
	{
		SND_DSPBUS_DEFAULT,
		SND_DSPBUS_WEAPONS,
		SND_DSPBUS_WEAPONS_DIST,
		SND_DSPBUS_AMBIENCE,
		SND_DSPBUS_EMITTERS,
		SND_DSPBUS_QUADS,
		SND_DSPBUS_MUSIC,
		SND_DSPBUS_FOLEY,
		SND_DSPBUS_EXPLOSIONS,
		SND_DSPBUS_EXPLOSIONS_CRITICAL,
		SND_DSPBUS_TACTICAL,
		SND_DSPBUS_TACTICAL_SPECIAL,
		SND_DSPBUS_VEHICLES,
		SND_DSPBUS_AIR_VEHICLES,
		SND_DSPBUS_INT_VEHICLES_1,
		SND_DSPBUS_INT_VEHICLES_2,
		SND_DSPBUS_VOICES,
		SND_DSPBUS_VOICES_CRITICAL,
		SND_DSPBUS_VOICES_UNFILTERED,
		SND_DSPBUS_ANIMALS,
		SND_DSPBUS_PHYSICS,
		SND_DSPBUS_BATTLECHATTER,
		SND_DSPBUS_INTERFACE,
		SND_DSPBUS_SCRIPTED,
		SND_DSPBUS_SCRIPTED1,
		SND_DSPBUS_SCRIPTED2,
		SND_DSPBUS_SCRIPTED3,
		SND_DSPBUS_SCRIPTED4,
		SND_DSPBUS_SCRIPTED5,
		SND_DSPBUS_UNOCCLUDED,
		SND_DSPBUS_WHIZBYS,
		SND_DSPBUS_NOTIMESCALE,

		SND_DSPBUS_COUNT,
	};

	enum SoundVolMod : std::int16_t
	{
		SND_VOLMOD_DEFAULT,
		SND_VOLMOD_HUD,
		SND_VOLMOD_FRONTEND_SFX,
		SND_VOLMOD_FRONTEND_MUSIC,
		SND_VOLMOD_SP_HIT_ALERT_NPC,
		SND_VOLMOD_MUSIC,
		SND_VOLMOD_MUSIC2,
		SND_VOLMOD_MUSIC_BIG,
		SND_VOLMOD_MUSIC_EMITTER,
		SND_VOLMOD_AMB_QUAD,
		SND_VOLMOD_AMB_DIST,
		SND_VOLMOD_AMB_DAMB,
		SND_VOLMOD_AMB_DAMB_BIG,
		SND_VOLMOD_AMB_EMITTER,
		SND_VOLMOD_AMB_EMITTER_INT,
		SND_VOLMOD_AMB_EMITTER_EXT,
		SND_VOLMOD_PHYSICS,
		SND_VOLMOD_BODYFALL,
		SND_VOLMOD_BODYFALL_MECH,
		SND_VOLMOD_FOLEY_PLR,
		SND_VOLMOD_FOLEY_PLR_SPECIAL,
		SND_VOLMOD_MP_FOLEY_PLR,
		SND_VOLMOD_FOLEY_NPC,
		SND_VOLMOD_FOLEY_MECH,
		SND_VOLMOD_FOLEYMP_NPC,
		SND_VOLMOD_WPN_FOLEY_PLR,
		SND_VOLMOD_WPN_FOLEY_NPC,
		SND_VOLMOD_WPN_FOLEY_MECH,
		SND_VOLMOD_FOOTSTEP_PLR,
		SND_VOLMOD_FOOTSTEP_PLR_SPECIAL,
		SND_VOLMOD_FOOTSTEP_WATER_PLR,
		SND_VOLMOD_FOOTSTEP_NPC,
		SND_VOLMOD_FOOTSTEP_MECH,
		SND_VOLMOD_MP_FOOTSTEP_PLR,
		SND_VOLMOD_MP_FOOTSTEP_NPC,
		SND_VOLMOD_MELEE_PLR,
		SND_VOLMOD_MELEE_NPC,
		SND_VOLMOD_MELEE_HIT,
		SND_VOLMOD_PLR_INTERNAL,
		SND_VOLMOD_DEATHS_DOOR,
		SND_VOLMOD_CHATTER_FRIENDLY,
		SND_VOLMOD_CHATTER_ENEMY,
		SND_VOLMOD_CHATTER_ATLAS,
		SND_VOLMOD_VOX_FRIENDLY,
		SND_VOLMOD_VOX_ENEMY,
		SND_VOLMOD_DIALOG,
		SND_VOLMOD_DIALOG_RADIO,
		SND_VOLMOD_DIALOG_CRITICAL,
		SND_VOLMOD_DIALOG_AMB,
		SND_VOLMOD_DESTRUCT,
		SND_VOLMOD_EXPLOSION,
		SND_VOLMOD_EXPLOSION_GRENADE,
		SND_VOLMOD_EXPLOSION_FLASHBANG,
		SND_VOLMOD_EXPLOSION_ROCKET,
		SND_VOLMOD_EXPLOSION_CAR,
		SND_VOLMOD_EXPLOSION_CRITICAL,
		SND_VOLMOD_EXPLOSION_DEBRIS,
		SND_VOLMOD_IMPACT_CRITICAL,
		SND_VOLMOD_BULLET_IMPACT_GEO,
		SND_VOLMOD_BULLET_IMPACT_PLR,
		SND_VOLMOD_BULLET_IMPACT_NPC,
		SND_VOLMOD_MP_BULLET_IMPACT_GEO,
		SND_VOLMOD_MP_BULLET_IMPACT_PLR,
		SND_VOLMOD_MP_BULLET_IMPACT_NPC,
		SND_VOLMOD_BULLET_WHIZBY,
		SND_VOLMOD_MP_BULLET_WHIZBY,
		SND_VOLMOD_BULLET_IMPACT_SPECIAL,
		SND_VOLMOD_VEHICLE_PLR,
		SND_VOLMOD_VEHICLE_PLR_SPECIAL,
		SND_VOLMOD_VEHICLE_NPC,
		SND_VOLMOD_VEHICLE_NPC_SPECIAL,
		SND_VOLMOD_VEHICLE_AVM_PLR,
		SND_VOLMOD_VEHICLE_AVM_NPC,
		SND_VOLMOD_WPN_VEHICLE_PLR,
		SND_VOLMOD_WPN_VEHICLE_NPC,
		SND_VOLMOD_VEHICLE,
		SND_VOLMOD_VEHICLE_AIRCRAFT,
		SND_VOLMOD_VEHICLE_PDRONE,
		SND_VOLMOD_VEHICLE_DRONE_SWARM,
		SND_VOLMOD_VEHICLE_AMB,
		SND_VOLMOD_GRENADEBOUNCE,
		SND_VOLMOD_MP_GRENADEBOUNCE,
		SND_VOLMOD_SHELLCASINGS,
		SND_VOLMOD_MP_SHELLCASINGS,
		SND_VOLMOD_WPN_PLR,
		SND_VOLMOD_WPN_PLR_SPECIAL,
		SND_VOLMOD_WPN_NPC_SPECIAL,
		SND_VOLMOD_MP_WPN_PLR,
		SND_VOLMOD_WPN_NPC,
		SND_VOLMOD_MP_WPN_NPC,
		SND_VOLMOD_WPN_PROJECTILE,
		SND_VOLMOD_MP_WPN_PROJECTILE,
		SND_VOLMOD_WPN_PLR_SHOT_SPECIAL,
		SND_VOLMOD_WPN_PLR_SHOT,
		SND_VOLMOD_WPN_PLR_MECH,
		SND_VOLMOD_WPN_PLR_SUB,
		SND_VOLMOD_WPN_PLR_TAIL,
		SND_VOLMOD_WPN_NPC_SHOT,
		SND_VOLMOD_WPN_NPC_MECH,
		SND_VOLMOD_WPN_NPC_SUB,
		SND_VOLMOD_WPN_NPC_TAIL,
		SND_VOLMOD_WPN_NPC_DIST,
		SND_VOLMOD_TACTICAL_PLR,
		SND_VOLMOD_TACTICAL_NPC,
		SND_VOLMOD_TACTICAL_PLR_SPECIAL,
		SND_VOLMOD_TACTICAL_NPC_SPECIAL,
		SND_VOLMOD_ATTACK_DOG,
		SND_VOLMOD_BIG_MOMENT,
		SND_VOLMOD_SCRIPTED1,
		SND_VOLMOD_SCRIPTED2,
		SND_VOLMOD_SCRIPTED3,
		SND_VOLMOD_SCRIPTED4,
		SND_VOLMOD_SCRIPTED5,
		SND_VOLMOD_SCRIPTED6,
		SND_VOLMOD_SCRIPTED7,
		SND_VOLMOD_SCRIPTED8,
		SND_VOLMOD_SCRIPTED9,
		SND_VOLMOD_SCRIPTED10,
		SND_VOLMOD_FULLVOLUME,
		SND_VOLMOD_MP_PRE_EVENT,
		SND_VOLMOD_MP_POST_EVENT,
		SND_VOLMOD_MP_SPLASH_NOTIFY,
		SND_VOLMOD_MP_HIT_MARKER,
		SND_VOLMOD_MP_PERK_QUIET,
		SND_VOLMOD_MW3_AMB_DAMB,
		SND_VOLMOD_MW3_AMB_EMITTER,
		SND_VOLMOD_MW3_AMB_QUAD,
		SND_VOLMOD_MW3_BODYFALL,
		SND_VOLMOD_MW3_BULLET_IMPACT_GEO,
		SND_VOLMOD_MW3_BULLET_IMPACT_NPC,
		SND_VOLMOD_MW3_BULLET_IMPACT_PLR,
		SND_VOLMOD_MW3_BULLET_WHIZBY,
		SND_VOLMOD_MW3_CHATTER_ENEMY,
		SND_VOLMOD_MW3_CHATTER_FRIENDLY,
		SND_VOLMOD_MW3_DEPRECATED_DEFAULT,
		SND_VOLMOD_MW3_DEPRECATED_MAX,
		SND_VOLMOD_MW3_DEPRECATED_NA,
		SND_VOLMOD_MW3_DESTRUCT,
		SND_VOLMOD_MW3_DIALOG,
		SND_VOLMOD_MW3_DIALOG_AMB,
		SND_VOLMOD_MW3_DIALOG_CRITICAL,
		SND_VOLMOD_MW3_DIALOG_RADIO,
		SND_VOLMOD_MW3_EXPLOSION,
		SND_VOLMOD_MW3_EXPLOSION_CAR,
		SND_VOLMOD_MW3_EXPLOSION_FLASHBANG,
		SND_VOLMOD_MW3_EXPLOSION_GRENADE,
		SND_VOLMOD_MW3_EXPLOSION_ROCKET,
		SND_VOLMOD_MW3_FOLEY_NPC,
		SND_VOLMOD_MW3_FOOTSTEP_NPC,
		SND_VOLMOD_MW3_FRONTEND_SFX,
		SND_VOLMOD_MW3_FULLVOLUME,
		SND_VOLMOD_MW3_GRENADEBOUNCE,
		SND_VOLMOD_MW3_MELEE_NPC,
		SND_VOLMOD_MW3_MP_BULLET_IMPACT_GEO,
		SND_VOLMOD_MW3_MP_BULLET_IMPACT_NPC,
		SND_VOLMOD_MW3_MP_FOLEY_NPC,
		SND_VOLMOD_MW3_MP_FOOTSTEP_NPC,
		SND_VOLMOD_MW3_MP_WPN_NPC,
		SND_VOLMOD_MW3_MUSIC,
		SND_VOLMOD_MW3_PHYSICS,
		SND_VOLMOD_MW3_SCRIPTED1,
		SND_VOLMOD_MW3_SCRIPTED2,
		SND_VOLMOD_MW3_SCRIPTED3,
		SND_VOLMOD_MW3_SCRIPTED4,
		SND_VOLMOD_MW3_SCRIPTED5,
		SND_VOLMOD_MW3_SHELLCASINGS,
		SND_VOLMOD_MW3_VEHICLE,
		SND_VOLMOD_MW3_VEHICLE_PLR,
		SND_VOLMOD_MW3_VEHICLE_NPC,
		SND_VOLMOD_MW3_VOX_ENEMY,
		SND_VOLMOD_MW3_VOX_FRIENDLY,
		SND_VOLMOD_MW3_WPN_FOLEY_NPC,
		SND_VOLMOD_MW3_WPN_FOLEY_PLR,
		SND_VOLMOD_MW3_FOOTSTEP_PLR,
		SND_VOLMOD_MW3_WPN_NPC,
		SND_VOLMOD_MW3_WPN_PLR,
		SND_VOLMOD_MW3_WPN_PROJECTILE,
		SND_VOLMOD_MW3_WPN_VEHICLE_NPC,
		SND_VOLMOD_MW3_WPN_VEHICLE_PLR,

		SND_VOLMOD_COUNT,
	};

	struct snd_alias_t
	{
		const char* aliasName;
		const char* subtitle;
		const char* secondaryAliasName;
		const char* chainAliasName;
		SoundFile* soundFile;
		const char* squelchName;
		short polyCount;
		short polyGlobalCount;
		char polyEntityType;
		char polyGlobalType;
		unsigned char dspBusIndex;
		unsigned char priority;
		int playCount;
		int polyClass;
		int unk;
		float volMin;
		float volMax;
		short volModIndex;
		//char __padding0[2]; // padding
		float pitchMin;
		float pitchMax;
		float distMin;
		float distMax;
		float velocityMin;
		int flags;
		unsigned char masterPriority;
		float masterPercentage;
		float slavePercentage;
		unsigned char playbackPercentage;
		//char __padding1[3]; // padding
		float probability;
		unsigned char variationType; // value: 0-4
		//char __padding2[3]; // padding
		SndContext* sndContext;
		int sequence;
		float lfePercentage;
		float centerPercentage;
		int startDelay;
		SndCurve* volumeFalloffCurve;
		float envelopMin;
		float envelopMax;
		SndCurve* lpfCurve;
		SndCurve* reverbSendCurve;
		SpeakerMap* speakerMap;
		float wetMixOverride;
		float focusPercentage;
		float smartpanDistance2d;
		float smartpanDistance3d;
		float smartpanAttenuation3d;
		float minSmartpan2dContribution;
		short stereo3DAngle;
		//char __padding3[2]; // padding
		float stereo3DStart;
		float stereo3DEnd;
		unsigned char allowDoppler;
		//char __padding4[3]; // padding
		DopplerPreset* dopplerPreset;
		float threshold;
		int lockedLoopTime;
	}; assert_sizeof(snd_alias_t, 0xF8);
	assert_offsetof(snd_alias_t, soundFile, 32);
	assert_offsetof(snd_alias_t, sndContext, 128);
	assert_offsetof(snd_alias_t, volumeFalloffCurve, 152);
	assert_offsetof(snd_alias_t, lpfCurve, 168);
	assert_offsetof(snd_alias_t, reverbSendCurve, 176);
	assert_offsetof(snd_alias_t, speakerMap, 184);
	assert_offsetof(snd_alias_t, dopplerPreset, 232);

	struct snd_alias_context_list
	{
		unsigned char aliasOffset;
		unsigned char count;
	}; assert_sizeof(snd_alias_context_list, 2);

	struct snd_alias_list_t
	{
		union
		{
			const char* aliasName;
			const char* name;
		};
		snd_alias_t* head;
		snd_alias_context_list* contextList;
		unsigned char count;
		unsigned char contextListCount;
	}; assert_sizeof(snd_alias_list_t, 0x20);

	struct LocalizeEntry
	{
		const char* value;
		const char* name;
	}; assert_sizeof(LocalizeEntry, 0x10);

	struct TriggerModel
	{
		int contents;
		unsigned short hullCount;
		unsigned short firstHull;
	}; assert_sizeof(TriggerModel, 8);

	struct TriggerHull
	{
		Bounds bounds;
		int contents;
		unsigned short slabCount;
		unsigned short firstSlab;
	}; assert_sizeof(TriggerHull, 32);

	struct TriggerSlab
	{
		float dir[3];
		float midPoint;
		float halfSize;
	}; assert_sizeof(TriggerSlab, 20);

	struct MapTriggers
	{
		unsigned int count;
		TriggerModel* models;
		unsigned int hullCount;
		TriggerHull* hulls;
		unsigned int slabCount;
		TriggerSlab* slabs;
	}; assert_sizeof(MapTriggers, 0x30);

	struct ClientTriggerAabbNode
	{
		Bounds bounds;
		unsigned short firstChild;
		unsigned short childCount;
	}; assert_sizeof(ClientTriggerAabbNode, 28);

	enum clientTriggerType_t : std::int32_t
	{
		CLIENT_TRIGGER_NONE = 0x0,
		CLIENT_TRIGGER_VISIONSET = 0x1,
		CLIENT_TRIGGER_REVERB = 0x2,
		CLIENT_TRIGGER_AUDIO = 0x4,
		CLIENT_TRIGGER_BLEND_VISION = 0x8,
		CLIENT_TRIGGER_BLEND_AUDIO = 0x10,
		CLIENT_TRIGGER_BLEND_ALL = 0x12,
		CLIENT_TRIGGER_NPC = 0x20,
	};

	struct ClientTriggers
	{
		MapTriggers trigger;
		unsigned short numClientTriggerNodes;
		ClientTriggerAabbNode* clientTriggerAabbTree;
		unsigned int triggerStringLength;
		char* triggerString;
		short* visionSetTriggers;
		short* lightSetTriggers;
		short* clutTriggers;
		short* triggerType;
		vec3_t* origins;
		float* scriptDelay;
		short* audioTriggers;
		short* blendLookup;
		short* unkTriggers;
		short* npcTriggers; // could be wrong
		short* contextTriggers;
		short* waterTriggers;
	}; assert_sizeof(ClientTriggers, 0xB0);

	struct ClientTriggerBlendNode
	{
		float pointA[3];
		float pointB[3];
		unsigned short triggerA;
		unsigned short triggerB;
	}; assert_sizeof(ClientTriggerBlendNode, 28);

	struct ClientTriggerBlend
	{
		unsigned short numClientTriggerBlendNodes;
		ClientTriggerBlendNode* blendNodes;
	}; assert_sizeof(ClientTriggerBlend, 0x10);

	struct SpawnPointEntityRecord
	{
		unsigned short index;
		scr_string_t name;
		scr_string_t target;
		scr_string_t script_noteworthy;
		scr_string_t unknown;
		float origin[3];
		float angles[3];
	};

	struct SpawnPointRecordList
	{
		unsigned short spawnsCount;
		SpawnPointEntityRecord* spawns;
	};

	struct SplinePointEntityRecord
	{
		int splineId;
		int splineNodeId;
		char* splineNodeLabel;
		float splineNodeTension;
		float origin[3];
		float corridorDims[2];
		float tangent[3];
		float distToNextNode;
		vec3_t* positionCubic;
		vec3_t* tangentQuadratic;
	};

	struct SplinePointRecordList
	{
		unsigned short splinePointCount;
		float splineLength;
		SplinePointEntityRecord* splinePoints;
	};

	struct SplineRecordList
	{
		unsigned short splineCount;
		SplinePointRecordList* splines;
	};

	struct MapEnts
	{
		const char* name;
		char* entityString;
		int numEntityChars;
		MapTriggers trigger;
		ClientTriggers clientTrigger;
		ClientTriggerBlend clientTriggerBlend;
		SpawnPointRecordList spawnList;
		SplineRecordList splineList;
	}; assert_sizeof(MapEnts, 0x128);

	struct RawFile
	{
		const char* name;
		int compressedLen;
		int len;
		const char* buffer;
	}; assert_sizeof(RawFile, 0x18);

	struct ScriptFile
	{
		const char* name;
		int compressedLen;
		int len;
		int bytecodeLen;
		const char* buffer;
		char* bytecode;
	}; assert_sizeof(ScriptFile, 0x28);

	struct StringTableCell
	{
		const char* string;
		int hash;
	};

	struct StringTable
	{
		const char* name;
		int columnCount;
		int rowCount;
		StringTableCell* values;
	}; assert_sizeof(StringTable, 0x18);

	struct StructuredDataEnumEntry
	{
		scr_string_t string;
		unsigned short index;
	};

	struct StructuredDataEnum
	{
		int entryCount;
		int reservedEntryCount;
		StructuredDataEnumEntry* entries;
	};

	enum StructuredDataTypeCategory
	{
		DATA_INT = 0x0,
		DATA_BYTE = 0x1,
		DATA_BOOL = 0x2,
		DATA_STRING = 0x3,
		DATA_ENUM = 0x4,
		DATA_STRUCT = 0x5,
		DATA_INDEXED_ARRAY = 0x6,
		DATA_ENUM_ARRAY = 0x7,
		DATA_FLOAT = 0x8,
		DATA_SHORT = 0x9,
		DATA_COUNT = 0xA,
	};

	union StructuredDataTypeUnion
	{
		unsigned int stringDataLength;
		int enumIndex;
		int structIndex;
		int indexedArrayIndex;
		int enumedArrayIndex;
		int index;
	};

	struct StructuredDataType
	{
		StructuredDataTypeCategory type;
		StructuredDataTypeUnion u;
	};

	enum StructuredDataValidationType
	{
		VALIDATION_NONE = 0x0,
	};

	struct StructuredDataStructProperty
	{
		scr_string_t name;
		StructuredDataType type;
		unsigned int offset;
		StructuredDataValidationType validation;
	};

	struct StructuredDataStruct
	{
		int propertyCount;
		StructuredDataStructProperty* properties;
		int size;
		unsigned int bitOffset;
	};

	struct StructuredDataIndexedArray
	{
		int arraySize;
		StructuredDataType elementType;
		unsigned int elementSize;
	};

	struct StructuredDataEnumedArray
	{
		int enumIndex;
		StructuredDataType elementType;
		unsigned int elementSize;
	};

	struct StructuredDataDef
	{
		int version;
		unsigned int formatChecksum;
		int enumCount;
		StructuredDataEnum* enums;
		int structCount;
		StructuredDataStruct* structs;
		int indexedArrayCount;
		StructuredDataIndexedArray* indexedArrays;
		int enumedArrayCount;
		StructuredDataEnumedArray* enumedArrays;
		StructuredDataType rootType;
		unsigned int size;
	}; assert_sizeof(StructuredDataDef, 0x58);

	struct StructuredDataDefSet
	{
		const char* name;
		unsigned int defCount;
		StructuredDataDef* defs;
	}; assert_sizeof(StructuredDataDefSet, 0x18);

	enum NetConstStringType
	{
		NETCONSTSTRINGTYPE_XMODEL = 0, // mdl
		NETCONSTSTRINGTYPE_MATERIAL = 1, // mat
		NETCONSTSTRINGTYPE_RUMBLE = 2, // rmb
		NETCONSTSTRINGTYPE_VEHICLES = 3, // veh
		NETCONSTSTRINGTYPE_FX = 4, // vfx
		NETCONSTSTRINGTYPE_LOCSTRING = 5, // loc
		NETCONSTSTRINGTYPE_SOUNDALIAS = 6, // snd
		NETCONSTSTRINGTYPE_SUBMIX = 7, // sbx
		NETCONSTSTRINGTYPE_SOUNDALIAS_LOOPING = 8, // snl
		NETCONSTSTRINGTYPE_SHOCK = 9, // shk
		NETCONSTSTRINGTYPE_SCRIPTMENU = 10, // mnu
		NETCONSTSTRINGTYPE_CLIENT_TAGS = 11, // tag
		NETCONSTSTRINGTYPE_HEADICON = 12, // hic
		NETCONSTSTRINGTYPE_NAMEPLATE = 13, // nps
		NETCONSTSTRINGTYPE_MINIMAPICON = 14, // mic
		NETCONSTSTRINGTYPE_LOCSELMAT = 15, // sel
		NETCONSTSTRINGTYPE_WEAPON = 16, // wep
		NETCONSTSTRINGTYPE_ATTACHMENT = 17, // att
		NETCONSTSTRINGTYPE_HINTSTRING = 18, // hnt
		NETCONSTSTRINGTYPE_ANIM = 19, // anm
		NETCONSTSTRINGTYPE_TAGS = 20, // fxt
		NETCONSTSTRINGTYPE_ANIMCLASS = 21, // acl
		NETCONSTSTRINGTYPE_LUI = 22, // lui
		NETCONSTSTRINGTYPE_LASER = 23, // lsr
		NETCONSTSTRINGTYPE_COUNT = 27,
		NETCONSTSTRINGTYPE_NONE = 27,
	};

	enum NetConstStringSource
	{
		NETCONSTSTRINGSOURCE_MAP = 0x0,
		NETCONSTSTRINGSOURCE_PRE_MAP = 0x1,
		NETCONSTSTRINGSOURCE_COMMON = 0x2,
		NETCONSTSTRINGSOURCE_COUNT = 0x3,
		NETCONSTSTRINGSOURCE_NONE = 0x3,
	};

	struct NetConstStrings
	{
		const char* name;
		NetConstStringType stringType;
		NetConstStringSource sourceType;
		unsigned int entryCount;
		const char** stringList;
	}; assert_sizeof(NetConstStrings, 0x20);

	struct LuaFile
	{
		const char* name;
		int len;
		char strippingType;
		const char* buffer;
	}; assert_sizeof(LuaFile, 0x18);

	struct TTFDef
	{
		const char* name;
		int fileLen;
		const char* file;
		void* ftFace;
	}; assert_sizeof(TTFDef, 0x20);

	struct FxParticleSimAnimationHeader
	{
		float playbackRate;
		float duration;
		unsigned int frameCount;
		float minX;
		float minY;
		float minZ;
		float boundsXDelta;
		float boundsYDelta;
		float boundsZDelta;
		float maxWidth;
		float maxHeight;
		unsigned int colorTableSize;
		unsigned int particleDataCount;
		bool evalVisStatePerParticle;
		bool sortParticlesAtRuntime;
	};

	struct FxParticleSimAnimationParticleData
	{
		unsigned short xNormalizedPos;
		unsigned short yNormalizedPos;
		unsigned short zNormalizedPos;
		unsigned short xNormalizedWidth;
		unsigned short yNormalizedHeight;
		unsigned short orientation;
		unsigned short lifetime;
		unsigned short particleID;
		unsigned short xNormalizedPosNextFrame;
		unsigned short yNormalizedPosNextFrame;
		unsigned short zNormalizedPosNextFrame;
		unsigned short xNormalizedWidthNextFrame;
		unsigned short yNormalizedHeightNextFrame;
		short orientationDelta;
		unsigned short colorTableIndex;
		unsigned short nextColorTableIndex;
	};

	struct FxParticleSimAnimationFrame
	{
		unsigned int particleDataOffset;
		unsigned int numActiveParticles;
	};

	struct FxParticleSimAnimation
	{
		const char* name;
		Material* material;
		FxParticleSimAnimationHeader header;
		FxParticleSimAnimationParticleData* particleData;
		FxParticleSimAnimationFrame* frames;
		GfxColorFloat* colorTable;
	};

	enum FxEffectDefFlags : std::uint32_t
	{
		FX_EFFECT_NEEDS_LIGHT_GRID_LIGHTING_AT_SPAWN = 0x1,
		FX_EFFECT_NEEDS_CAST_SHADOW = 0x2,
		FX_EFFECT_NEEDS_LIGHT_GRID_LIGHTING_PER_FRAME = 0x4,
		FX_EFFECT_NEEDS_DYNAMIC_LIGHTING_PER_FRAME = 0x8,
		FX_EFFECT_NEEDS_EMISSIVE_DRAW = 0x10,
		FX_EFFECT_LINK_TO_SUN = 0x40,
		FX_EFFECT_HAS_CAMERA_RELATIVE_ELEM = 0x80,
	};

	enum FxElemType : std::uint8_t
	{
		FX_ELEM_TYPE_SPRITE_BILLBOARD = 0,
		FX_ELEM_TYPE_SPRITE_ORIENTED = 1,
		FX_ELEM_TYPE_SPRITE_ROTATED = 2,
		FX_ELEM_TYPE_TAIL = 3,
		FX_ELEM_TYPE_LINE = 4,
		FX_ELEM_TYPE_TRAIL = 5,
		FX_ELEM_TYPE_FLARE = 6,
		FX_ELEM_TYPE_PARTICLE_SIM_ANIMATION = 7,
		FX_ELEM_TYPE_CLOUD = 8,
		FX_ELEM_TYPE_SPARK_CLOUD = 9,
		FX_ELEM_TYPE_SPARK_FOUNTAIN = 10,
		FX_ELEM_TYPE_MODEL = 11,
		FX_ELEM_TYPE_OMNI_LIGHT = 12,
		FX_ELEM_TYPE_SPOT_LIGHT = 13,
		FX_ELEM_TYPE_SOUND = 14,
		FX_ELEM_TYPE_DECAL = 15,
		FX_ELEM_TYPE_RUNNER = 16,
		FX_ELEM_TYPE_VECTORFIELD = 17,
	};

	enum FxElemLitType : std::uint8_t
	{
		FX_ELEM_LIT_TYPE_NONE = 0x0,
		FX_ELEM_LIT_TYPE_LIGHTGRID_SPAWN_SINGLE = 0x1,
		FX_ELEM_LIT_TYPE_LIGHTGRID_FRAME_SINGLE = 0x2,
		FX_ELEM_LIT_TYPE_LIGHTGRID_FRAME_SPRITE = 0x3,
		FX_ELEM_LIT_TYPE_LIGHTGRID_FRAME_VERTEX = 0x4,
		FX_ELEM_LIT_TYPE_COUNT = 0x5,
	};

	enum FxElemDefFlags : std::uint32_t
	{
		FX_ELEM_SPAWN_RELATIVE_TO_EFFECT = 0x2,
		FX_ELEM_SPAWN_FRUSTUM_CULL = 0x4,
		FX_ELEM_RUNNER_USES_RAND_ROT = 0x8,
		FX_ELEM_SPAWN_OFFSET_NONE = 0x0,
		FX_ELEM_SPAWN_OFFSET_SPHERE = 0x10,
		FX_ELEM_SPAWN_OFFSET_CYLINDER = 0x20,
		FX_ELEM_SPAWN_OFFSET_MASK = 0x30,
		FX_ELEM_RUN_RELATIVE_TO_WORLD = 0x0,
		FX_ELEM_RUN_RELATIVE_TO_SPAWN = 0x40,
		FX_ELEM_RUN_RELATIVE_TO_EFFECT = 0x80,
		FX_ELEM_RUN_RELATIVE_TO_OFFSET = 0xC0,
		FX_ELEM_RUN_RELATIVE_TO_CAMERA = 0x100,
		FX_ELEM_RUN_MASK = 0x1C0,
		FX_ELEM_DIE_ON_TOUCH = 0x200,
		FX_ELEM_DRAW_PAST_FOG = 0x400,
		FX_ELEM_DRAW_WITH_VIEWMODEL = 0x800,
		FX_ELEM_BLOCK_SIGHT = 0x1000,
		FX_ELEM_DRAW_IN_THERMAL_VIEW_ONLY = 0x2000,
		FX_ELEM_TRAIL_ORIENT_BY_VELOCITY = 0x4000,
		FX_ELEM_EMIT_BOLT = 0x80000000,
		FX_ELEM_EMIT_ORIENT_BY_ELEM = 0x8000,
		FX_ELEM_USE_OCCLUSION_QUERY = 0x10000,
		FX_ELEM_USE_CAST_SHADOW = 0x20000,
		FX_ELEM_NODRAW_IN_THERMAL_VIEW = 0x40000,
		FX_ELEM_THERMAL_MASK = 0x42000,
		FX_ELEM_SPAWN_IMPACT_FX_WITH_SURFACE_NAME = 0x80000,
		FX_ELEM_RECEIVE_DYNAMIC_LIGHT = 0x100000,
		FX_ELEM_VOLUMETRIC_TRAIL = 0x200000,
		FX_ELEM_USE_COLLISION = 0x400000,
		FX_ELEM_USE_VECTORFIELDS = 0x800000,
		FX_ELEM_HAS_VELOCITY_GRAPH_LOCAL = 0x1000000,
		FX_ELEM_HAS_VELOCITY_GRAPH_WORLD = 0x2000000,
		FX_ELEM_HAS_GRAVITY = 0x4000000,
		FX_ELEM_USE_MODEL_PHYSICS = 0x8000000,
		FX_ELEM_NONUNIFORM_SCALE = 0x10000000,
		FX_ELEM_CLOUD_SHAPE_CUBE = 0x0,
		FX_ELEM_CLOUD_SHAPE_SPHERE_LARGE = 0x20000000,
		FX_ELEM_CLOUD_SHAPE_SPHERE_MEDIUM = 0x40000000,
		FX_ELEM_CLOUD_SHAPE_SPHERE_SMALL = 0x60000000,
		FX_ELEM_CLOUD_SHAPE_MASK = 0x60000000,
		FX_ELEM_FOUNTAIN_DISABLE_COLLISION = 0x80000000,
	};

	enum FxElemDefExtraFlags : std::uint32_t
	{

	};

	struct FxFloatRange
	{
		float base;
		float amplitude;
	};

	struct FxSpawnDefLooping
	{
		int intervalMsec;
		int count;
	};

	struct FxIntRange
	{
		int base;
		int amplitude;
	};

	struct FxSpawnDefOneShot
	{
		FxIntRange count;
	};

	union FxSpawnDef
	{
		FxSpawnDefLooping looping;
		FxSpawnDefOneShot oneShot;
	};

	struct FxElemAtlas
	{
		unsigned char behavior;
		unsigned char index;
		unsigned char fps;
		unsigned char loopCount;
		unsigned char colIndexBits;
		unsigned char rowIndexBits;
		short entryCount;
	};

	union FxEffectDefRef
	{
		FxEffectDef* handle;
		const char* name;
	};

	struct FxElemVec3Range
	{
		float base[3];
		float amplitude[3];
	};

	struct FxElemVelStateInFrame
	{
		FxElemVec3Range velocity;
		FxElemVec3Range totalDelta;
	};

	struct FxElemVelStateSample
	{
		FxElemVelStateInFrame local;
		FxElemVelStateInFrame world;
	}; assert_sizeof(FxElemVelStateSample, 96);

	struct FxElemVisualState
	{
		float color[4];
		float emissiveScale[3];
		float rotationDelta;
		float rotationTotal;
		float size[2];
		float scale;
		float pivot[2];
	};

	struct FxElemVisStateSample
	{
		FxElemVisualState base;
		FxElemVisualState amplitude;
	}; assert_sizeof(FxElemVisStateSample, 112);

	struct FxElemMarkVisuals
	{
		Material* materials[3]; // mc, wc, wc (auto displacement)
	};

	union FxElemVisuals
	{
		const void* anonymous;
		Material* material;
		XModel* model;
		FxEffectDefRef effectDef;
		const char* soundName;
		const char* vectorFieldName;
		GfxLightDef* lightDef;
		FxParticleSimAnimation* particleSimAnimation;
	};

	union FxElemDefVisuals
	{
		FxElemMarkVisuals* markArray;
		FxElemVisuals* array;
		FxElemVisuals instance;
	};

	struct FxTrailVertex
	{
		float pos[2];
		float normal[2];
		float texCoord[2];
		float radialNormal[2];
	}; assert_sizeof(FxTrailVertex, 32);

	struct FxTrailDef
	{
		int scrollTimeMsec;
		int repeatDist;
		float invSplitDist;
		float invSplitArcDist;
		float invSplitTime;
		float headFadingFactor;
		float tailFadingFactor;
		int vertCount;
		FxTrailVertex* verts;
		int indCount;
		unsigned short* inds;
	}; assert_sizeof(FxTrailDef, 0x38);
	assert_offsetof(FxTrailDef, vertCount, 28);

	struct FxSparkFountainDef
	{
		float gravity;
		float bounceFrac;
		float bounceRand;
		float sparkSpacing;
		float sparkLength;
		int sparkCount;
		float loopTime;
		float velMin;
		float velMax;
		float velConeFrac;
		float restSpeed;
		float boostTime;
		float boostFactor;
	}; assert_sizeof(FxSparkFountainDef, 0x34);

	struct FxSpotLightDef
	{
		float halfFovOuter;
		float halfFovInner;
		float radius;
		float brightness;
		float maxLength;
		int exponent;
		float nearClip;
		float bulbRadius;
		float bulbLength;
		float fadeOffsetRt[2];
		char unk1;
		char opl;
		char unk2;
		char unused;
	};
	assert_sizeof(FxSpotLightDef, 0x30);

	struct FxOmniLightDef
	{
		float bulbRadius;
		float bulbLength;
		float fadeOffsetRt[2];
	};
	assert_sizeof(FxOmniLightDef, 0x10);

	struct FxFlareDef
	{
		float position;
		int angularRotCount;
		int flags;
		FxFloatRange depthScaleRange;
		FxFloatRange depthScaleValue;
		FxFloatRange radialRot;
		FxFloatRange radialScaleX;
		FxFloatRange radialScaleY;
		float dir[3];
		int intensityXIntervalCount;
		int intensityYIntervalCount;
		int srcCosIntensityIntervalCount;
		int srcCosScaleIntervalCount;
		float* intensityX;
		float* intensityY;
		float* srcCosIntensity;
		float* srcCosScale;
	}; assert_sizeof(FxFlareDef, 0x70);

	union FxElemExtendedDefPtr
	{
		char* unknownDef;
		FxTrailDef* trailDef;
		FxSparkFountainDef* sparkFountainDef;
		FxSpotLightDef* spotLightDef;
		FxOmniLightDef* omniLightDef;
		FxFlareDef* flareDef;
	};

	struct FxElemDef
	{
		FxElemDefFlags flags;
		int flags2;
		FxSpawnDef spawn;
		FxFloatRange spawnRange;
		FxFloatRange fadeInRange;
		FxFloatRange fadeOutRange;
		float spawnFrustumCullRadius;
		FxIntRange spawnDelayMsec;
		FxIntRange lifeSpanMsec;
		FxFloatRange spawnOrigin[3];
		FxFloatRange spawnOffsetRadius;
		FxFloatRange spawnOffsetHeight;
		FxFloatRange spawnAngles[3];
		FxFloatRange angularVelocity[3];
		FxFloatRange initialRotation;
		FxFloatRange gravity;
		FxFloatRange reflectionFactor;
		FxElemAtlas atlas;
		FxElemType elemType;
		FxElemLitType elemLitType;
		unsigned char visualCount;
		unsigned char velIntervalCount;
		unsigned char visStateIntervalCount;
		FxElemVelStateSample* velSamples;
		FxElemVisStateSample* visSamples;
		FxElemDefVisuals visuals;
		Bounds collBounds;
		FxEffectDefRef effectOnImpact;
		FxEffectDefRef effectOnDeath;
		FxEffectDefRef effectEmitted;
		FxFloatRange emitDist;
		FxFloatRange emitDistVariance;
		FxElemExtendedDefPtr extended;
		unsigned char sortOrder;
		unsigned char lightingFrac;
		unsigned char useItemClip;
		unsigned char fadeInfo;
		unsigned char fadeOutInfo;
		int randomSeed;
		float emissiveScaleScale;
		float hdrLightingFrac;
		float shadowDensityScale;
		float scatterRatio;
		float volumetricTrailFadeStart;
	}; assert_sizeof(FxElemDef, 0x140);

	struct FxEffectDef
	{
		const char* name;
		int flags;
		int totalSize;
		int msecLoopingLife;
		int elemDefCountLooping;
		int elemDefCountOneShot;
		int elemDefCountEmission;
		float elemMaxRadius;
		float occlusionQueryDepthBias;
		int occlusionQueryFadeIn;
		int occlusionQueryFadeOut;
		FxFloatRange occlusionQueryScaleRange;
		FxElemDef* elemDefs;
	}; assert_sizeof(FxEffectDef, 0x40);

	struct XModelIKData
	{
		unsigned char numSolvers;
		unsigned char numFloatParams;
		unsigned char numIntParams;
		unsigned char numStringParams;
		unsigned char* solverIDs;
		float* floatParams;
		int* intParams;
		scr_string_t* stringParams;
	}; assert_sizeof(XModelIKData, 0x28);

	union SkeletonScriptCode
	{
		unsigned int instruction;
		unsigned int variableIndex;
		float immediateValue;
	};

	struct SkeletonScript
	{
		const char* name;
		XModelIKData ikData;
		unsigned short codeSize;
		SkeletonScriptCode* code;
	}; assert_sizeof(SkeletonScript, 0x40);

	union XAnimDynamicFrames
	{
		unsigned char(*_1)[3];
		unsigned short(*_2)[3];
	};

	union XAnimDynamicIndices
	{
		unsigned char _1[1];
		unsigned short _2[1];
	};

	struct XAnimPartTransFrames
	{
		float mins[3];
		float size[3];
		XAnimDynamicFrames frames;
		XAnimDynamicIndices indices;
	};

	union XAnimPartTransData
	{
		XAnimPartTransFrames frames;
		float frame0[3];
	};

	struct XAnimPartTrans
	{
		unsigned short size;
		unsigned char smallTrans;
		XAnimPartTransData u;
	};

	struct XAnimDeltaPartQuatDataFrames2
	{
		short(*frames)[2];
		XAnimDynamicIndices indices;
	};

	union XAnimDeltaPartQuatData2
	{
		XAnimDeltaPartQuatDataFrames2 frames;
		short frame0[2];
	};

	struct XAnimDeltaPartQuat2
	{
		unsigned short size;
		XAnimDeltaPartQuatData2 u;
	};

	struct XAnimDeltaPartQuatDataFrames
	{
		short(*frames)[4];
		XAnimDynamicIndices indices;
	};

	union XAnimDeltaPartQuatData
	{
		XAnimDeltaPartQuatDataFrames frames;
		short frame0[4];
	};

	struct XAnimDeltaPartQuat
	{
		unsigned short size;
		XAnimDeltaPartQuatData u;
	};

	struct XAnimDeltaPart
	{
		XAnimPartTrans* trans;
		XAnimDeltaPartQuat2* quat2;
		XAnimDeltaPartQuat* quat;
	};

	union XAnimIndices
	{
		unsigned char* _1;
		unsigned short* _2;
		void* data;
	};

	struct XAnimNotifyInfo
	{
		scr_string_t name;
		float time;
	};

	enum XAnimPartsFlags : std::uint8_t
	{
		ANIM_NONE = 0x0,
		ANIM_LOOP = 0x1,
		ANIM_DELTA = 0x2,
		ANIM_DELTA_3D = 0x4,
		ANIM_DEFAULT = 0x8,
	};

	typedef float BlendShapeWeight;

	struct XAnimScriptedViewmodelAnimData
	{
		float blendIn;
		float blendOut;
	};

	struct XAnimParts
	{
		const char* name; // 0
		unsigned short dataByteCount; // 8
		unsigned short dataShortCount; // 10
		unsigned short dataIntCount; // 12
		unsigned short numframes; // 14
		unsigned char flags; // 15
		unsigned char boneCount[12]; // 16
		unsigned char notifyCount; // 29
		unsigned char assetType; // 30
		unsigned char ikType; // 31
		unsigned int randomDataByteCount; // 32
		unsigned int randomDataShortCount; // 36
		unsigned int randomDataIntCount; // 40
		unsigned int indexCount; // 44
		float framerate;  // 48
		float frequency; // 56
		scr_string_t* names; // 56
		char* dataByte; // 64
		short* dataShort; // 72
		int* dataInt; // 80
		short* randomDataShort; // 88
		unsigned char* randomDataByte; // 96
		int* randomDataInt; // 104
		XAnimIndices indices; // 112
		XAnimNotifyInfo* notify; // 120
		XAnimDeltaPart* deltaPart; // 128
		const char* secondaryName; // 136
		unsigned char alternateAnimWeight;
		unsigned char numAlternatives;
		unsigned short blendShapeCount; // 146
		short pad;
		scr_string_t* blendShapeWeightNames; // 152
		char(*blendShapeCoefficientMagnitudes)[3]; // 160
		unsigned short* numberOfBlendShapeKeys; // 168
		unsigned short* blendShapeKeys; // 176
		unsigned short* compressedBlendShapeCoefficients; // 184
		BlendShapeWeight* blendShapeWeights; // 192
		XAnimParts* alternativeAnim; // unused?
		XAnimScriptedViewmodelAnimData* svAmimData; // 208
	}; assert_sizeof(XAnimParts, 0xD8);

	union PackedUnitVec
	{
		unsigned int packed;
		unsigned char array[4];
	};

	union PackedTexCoords
	{
		unsigned int packed;
		unsigned char array[4];
	};

	struct GfxPackedVertex
	{
		float xyz[3];
		float binormalSign;
		GfxColor color;
		PackedTexCoords texCoord;
		PackedUnitVec normal;
		PackedUnitVec tangent;
	};

	struct GfxPackedMotionVertex
	{
		float xyz[3];
		float binormalSignAndHeight;
		GfxColor pieceIndex;
		PackedTexCoords texCoord;
		PackedUnitVec normal;
		PackedUnitVec tangent;
	};

	union GfxVertexUnion0
	{
		GfxPackedVertex* packedVerts0;
		GfxPackedMotionVertex* packedMotionVerts0;
		void* verts0;
	};

	struct Face
	{
		unsigned short v1;
		unsigned short v2;
		unsigned short v3;
	};

	struct XSurfaceCollisionAabb
	{
		unsigned short mins[3];
		unsigned short maxs[3];
	};

	struct XSurfaceCollisionNode
	{
		XSurfaceCollisionAabb aabb;
		unsigned short childBeginIndex;
		unsigned short childCount;
	};

	struct XSurfaceCollisionLeaf
	{
		unsigned short triangleBeginIndex;
	};

	struct XSurfaceCollisionTree
	{
		float trans[3];
		float scale[3];
		unsigned int nodeCount;
		XSurfaceCollisionNode* nodes;
		unsigned int leafCount;
		XSurfaceCollisionLeaf* leafs;
	};

	struct XRigidVertList
	{
		unsigned short boneOffset;
		unsigned short vertCount;
		unsigned short triOffset;
		unsigned short triCount;
		XSurfaceCollisionTree* collisionTree;
	};

	struct UnknownXSurface0
	{
		float xyz[3];
		PackedUnitVec normal;
	};

	struct BlendVertsUnknown
	{
		unsigned short b[15];
		unsigned short blendVertCountIndex; // 30
	}; assert_sizeof(BlendVertsUnknown, 32);

	struct XSubdivRigidVertList
	{
		unsigned int firstFace;
		unsigned int faceCount;
		unsigned int firstRegularPatch;
		unsigned int regularPatchCount;
	};

	struct XSurfaceSubdivLevel
	{
		XSubdivRigidVertList* rigidVertLists;
		unsigned int faceCount;
		unsigned int regularPatchCount;
		unsigned int regularPatchOffset;
		unsigned int facePointCount;
		unsigned int facePointValence4Count;
		unsigned int facePointBufferSize;
		unsigned int edgePointCount;
		unsigned int edgePointSmoothEnd;
		unsigned int edgePointUVBorderEnd;
		unsigned int vertexPointCount;
		unsigned int vertexPointValence4Count;
		unsigned int vertexPointBufferSize;
		unsigned int normalCount;
		unsigned int normalBufferSize;
		unsigned int transitionPointCount;
		unsigned int vertCount;
		unsigned int vertOffset;
		unsigned short* faceIndices;
		unsigned short* regularPatchIndices;
		unsigned int* regularPatchFlags;
		unsigned int* facePoints;
		unsigned int* edgePoints;
		unsigned int* vertexPoints;
		unsigned int* normals;
		unsigned int* transitionPoints;
		float* regularPatchCones;
		ID3D11Buffer* regularPatchIndexBuffer;
		ID3D11Buffer* faceIndexBuffer;
		ID3D11ShaderResourceView* regularPatchIndexBufferView;
		ID3D11ShaderResourceView* regularPatchFlagsView;
		ID3D11ShaderResourceView* facePointsView;
		ID3D11ShaderResourceView* edgePointsView;
		ID3D11ShaderResourceView* vertexPointsView;
		ID3D11ShaderResourceView* normalsView;
		ID3D11ShaderResourceView* transitionPointsView;
		ID3D11ShaderResourceView* regularPatchConesView;
	}; assert_sizeof(XSurfaceSubdivLevel, 0xE8);

	struct GfxSubdivCache
	{
		unsigned int size;
		ID3D11Buffer* subdivCacheBuffer;
		ID3D11ShaderResourceView* subdivCacheView;
	}; assert_sizeof(GfxSubdivCache, 0x18);

	struct XSurfaceSubdivInfo
	{
		XSurfaceSubdivLevel* levels;
		int flags; // maybe
		int totalVertCount; // foreach level: vertCount + VertOffset
		int totalPatchCount; // foreach level: regularPatchCount + regularPatchOffset
		int unk[3];
		GfxSubdivCache cache;
	}; assert_sizeof(XSurfaceSubdivInfo, 0x38);

	struct BlendShapeVert
	{
		float positionOffset[3];
		int vertIndex;
		PackedUnitVec normalOffset;
		PackedUnitVec tangentOffset;
		float tensionS;
		float tensionT;
	};

	struct BlendShape
	{
		unsigned int vertCount;
		BlendShapeVert* verts;
		ID3D11Buffer* blendShapeVertsBuffer;
		ID3D11ShaderResourceView* blendShapeVertsView;
	};

	typedef char alignCompBufByte_t;
	typedef unsigned short alignVertBufFloat16Vec2_t[2];
	typedef unsigned short alignCompBufUShort_t;
	typedef float alignCompBufFloat_t;
	typedef unsigned short XBlendInfo;

	enum XSurfaceFlags : std::uint16_t
	{
		SURF_FLAG_VERTCOL_GREY = 0x1,
		SURF_FLAG_VERTCOL_NONE = 0x2,
		SURF_FLAG_SKINNED = 0x4,
		SURF_FLAG_REACTIVE_MOTION = 0x8,
		SURF_FLAG_LIGHTMAP_COORDS = 0x10,
		SURF_FLAG_TENSION = 0x20,
	};

	struct XSurface
	{
		unsigned short flags;
		unsigned short vertCount;
		unsigned short triCount;
		unsigned char rigidVertListCount;
		unsigned char subdivLevelCount;
		short blendVertCounts[8];
		GfxVertexUnion0 verts0;
		Face* triIndices;
		Face* triIndices2;
		ID3D11Buffer* vb0;
		ID3D11ShaderResourceView* vb0View;
		ID3D11Buffer* indexBuffer;
		XRigidVertList* rigidVertLists;
		UnknownXSurface0* unknown0;
		XBlendInfo* blendVerts;
		BlendVertsUnknown* blendVertsTable;
		ID3D11Buffer* blendVertsBuffer;
		ID3D11ShaderResourceView* blendVertsView;
		alignVertBufFloat16Vec2_t* lmapUnwrap;
		ID3D11Buffer* vblmapBuffer;
		ID3D11ShaderResourceView* vblmapView;
		XSurfaceSubdivInfo* subdiv;
		alignCompBufFloat_t* tensionData;
		alignCompBufUShort_t* tensionAccumTable;
		ID3D11Buffer* tensionAccumTableBuffer;
		ID3D11ShaderResourceView* tensionAccumTableView;
		ID3D11Buffer* tensionDataBuffer;
		ID3D11ShaderResourceView* tensionDataView;
		ID3D11ShaderResourceView* indexBufferView;
		BlendShape* blendShapes;
		unsigned int blendShapesCount;
		unsigned int vertexLightingIndex;
		float quantizeScale;
		int partBits[8];
		char __pad1[4];
	}; assert_sizeof(XSurface, 0x108);

	struct XModelSurfs
	{
		const char* name;
		XSurface* surfs;
		unsigned short numsurfs;
		int partBits[8];
	}; assert_sizeof(XModelSurfs, 0x38);

	enum XModelLodFlags
	{
		XMODEL_LOD_FLAG_NONE = 0x0,
		XMODEL_LOD_FLAG_SUBDIV = 0x1,
		XMODEL_LOD_FLAG_SUBDIV_UNK = 0x2,
	};

	struct XModelLodInfo
	{
		float dist;
		unsigned short numsurfs;
		unsigned short surfIndex;
		XModelSurfs* modelSurfs;
		int partBits[8];
		XSurface* surfs;
		int unk;
		char flags;
		char pad[3];
	};

	struct XModelAngle
	{
		short x;
		short y;
		short z;
		short base;
	};

	struct XModelTagPos
	{
		float x;
		float y;
		float z;
	};

	struct DObjAnimMat
	{
		float quat[4];
		float trans[3];
		float transWeight;
	};

	struct ReactiveMotionModelPart
	{
		float center[3];
		float stiffness;
	};

	struct ReactiveMotionModelTweaks
	{
		float scale[4];
	};

	struct XModelCollSurf_s
	{
		Bounds bounds;
		int boneIdx;
		int contents;
		int surfFlags;
	};

	struct XBoneInfo
	{
		Bounds bounds;
		union
		{
			float radiusSquared;
			unsigned int radiusSquaredAsInt;
		};
	};

	struct BlendShapeWeightMap
	{
		unsigned short weightIndex;
		unsigned short targetIndex;
		float fullWeight;
	};

	struct ExtentBounds
	{
		vec3_t mins;
		vec3_t maxs;
	};

	struct MdaoVolume
	{
		ExtentBounds bounds;
		unsigned short cellCount[3];
		unsigned short parentBoneIndex;
		GfxImage* volumeData;
	}; assert_sizeof(MdaoVolume, 0x28);

	struct XPhysBoneInfo
	{
		PhysPreset* physPreset;
		PhysConstraint* physContraint;
		PhysCollmap* physCollmap;
		float unk1;
		char boneIndex;
		char unk2;
		char pad[2];
	}; assert_sizeof(XPhysBoneInfo, 0x20);

	enum XModelFlags : std::uint16_t
	{
		XMODEL_FLAG_NONE = 0x0,
		XMODEL_FLAG_ANIMATED_VERTS = 0x1,
		XMODEL_FLAG_UNK2 = 0x2,
		XMODEL_FLAG_UNK3 = 0x4,
		XMODEL_FLAG_UNK4 = 0x8,
		XMODEL_FLAG_REACTIVEMOTION = 0x8,
		XMODEL_FLAG_UNK6 = 0x20,
		XMODEL_FLAG_UNK7 = 0x40,
		XMODEL_FLAG_UNK8 = 0x80,
		XMODEL_FLAG_UNK9 = 0x100,
		XMODEL_FLAG_UNK10 = 0x200,
		XMODEL_FLAG_COMPOSITE = 0x400,
	};

	enum XModelLodRampType : std::uint8_t
	{
		XMODEL_LOD_RAMP_RIGID = 0x0,
		XMODEL_LOD_RAMP_SKINNED = 0x1,
		XMODEL_LOD_RAMP_COUNT = 0x2,
	};

	struct XModel
	{
		const char* name; // 0
		unsigned char numBones; // 8
		unsigned char numRootBones; // 9
		unsigned char numsurfs; // 10
		unsigned char numReactiveMotionParts; // 11
		unsigned char lodRampType; // 12
		unsigned char numBonePhysics; // 13
		char __pad0[2]; // 14-16
		float scale; // 16
		unsigned int noScalePartBits[8]; // 20
		scr_string_t* boneNames; // 56
		unsigned char* parentList; // 64
		XModelAngle* tagAngles; // 72
		XModelTagPos* tagPositions; // 80
		unsigned char* partClassification; // 88
		DObjAnimMat* baseMat; // 96
		ReactiveMotionModelPart* reactiveMotionParts; // 104
		ReactiveMotionModelTweaks* reactiveMotionTweaks; // 112
		Material** materialHandles; // 120
		XModelLodInfo lodInfo[6]; // 128
		char numLods; // 512
		char collLod; // 513
		unsigned char numCompositeModels; // 514
		unsigned char reactiveMotionLOD; // 515
		unsigned short flags; // 516
		unsigned short numCollSurfs; // 518
		XModelCollSurf_s* collSurfs; // 520
		int contents; // 528
		XBoneInfo* boneInfo; // 536
		float radius; // 544
		Bounds bounds; // 548
		unsigned short* invHighMipRadius; // 576
		int memUsage; // 584
		bool bad; // 588
		char pad; // 589
		unsigned short blendShapeCount; // 590
		unsigned short numberOfBlendShapeWeights; // 592
		unsigned short numberOfBlendShapeWeightMaps; // 594
		char __pad2[4]; // 596-600
		scr_string_t* blendShapeWeightNames; // 600
		BlendShapeWeightMap* blendShapeWeightMaps; // 608
		PhysPreset* physPreset; // 616
		PhysCollmap* physCollmap; // 624
		unsigned short mdaoVolumeCount; // 632
		short u3; // 634
		float quantization; // 636
		MdaoVolume* mdaoVolumes; // 640
		int u4; // 648
		int u5; // 652
		SkeletonScript* skeletonScript; // 656
		XModel** compositeModels; // 664
		XPhysBoneInfo* bonePhysics; // 672
	}; assert_sizeof(XModel, 0x2A8);

	enum activeReticleType_t : std::int32_t
	{
		VEH_ACTIVE_RETICLE_NONE = 0x0,
		VEH_ACTIVE_RETICLE_PIP_ON_A_STICK = 0x1,
		VEH_ACTIVE_RETICLE_BOUNCING_DIAMOND = 0x2,
		VEH_ACTIVE_RETICLE_COUNT = 0x3,
	};

	enum playerAnimType_t : std::uint8_t
	{
		PLAYERANIMTYPE_NONE = 0x0,
		PLAYERANIMTYPE_OTHER = 0x1,
		PLAYERANIMTYPE_PISTOL = 0x2,
		PLAYERANIMTYPE_SMG = 0x3,
		PLAYERANIMTYPE_AUTORIFLE = 0x4,
		PLAYERANIMTYPE_SNIPER = 0x5,
		PLAYERANIMTYPE_ROCKET_LAUNCHER = 0x6,
		PLAYERANIMTYPE_GRENADE = 0x7,
		PLAYERANIMTYPE_M203 = 0x8,
		PLAYERANIMTYPE_HOLD = 0x9,
		PLAYERANIMTYPE_BRIEFCASE = 0xA,
		PLAYERANIMTYPE_RIOTSHIELD = 0xB,
		PLAYERANIMTYPE_LAPTOP = 0xC,
		PLAYERANIMTYPE_THROWINGKNIFE = 0xD,
		PLAYERANIMTYPE_MINIGUN = 0xE,
		PLAYERANIMTYPE_SMG_BULLPUP = 0x1F,
		PLAYERANIMTYPE_AUTOFILE_BULLPUP = 0x10,
		PLAYERANIMTYPE_SNIPER_BULLPUP = 0x11,
		PLAYERANIMTYPE_KILLSTREAKTRIGGER = 0x12,
		PLAYERANIMTYPE_TROPHYSYSTEM = 0x13,
		PLAYERANIMTYPE_COMBATKNIFE = 0x14,
		PLAYERANIMTYPE_NUM = 0x15,
	};

	enum weapType_t : std::int32_t
	{
		WEAPTYPE_NONE = 0x0,
		WEAPTYPE_BULLET = 0x1,
		WEAPTYPE_GRENADE = 0x2,
		WEAPTYPE_PROJECTILE = 0x3,
		WEAPTYPE_RIOTSHIELD = 0x4,
		WEAPTYPE_ENERGY = 0x5,
		WEAPTYPE_NUM = 0x6,
	};

	enum weapClass_t : std::int32_t
	{
		WEAPCLASS_RIFLE = 0x0,
		WEAPCLASS_SNIPER = 0x1,
		WEAPCLASS_MG = 0x2,
		WEAPCLASS_SMG = 0x3,
		WEAPCLASS_SPREAD = 0x4,
		WEAPCLASS_PISTOL = 0x5,
		WEAPCLASS_GRENADE = 0x6,
		WEAPCLASS_ROCKETLAUNCHER = 0x7,
		WEAPCLASS_TURRET = 0x8,
		WEAPCLASS_THROWINGKNIFE = 0x9,
		WEAPCLASS_NON_PLAYER = 0xA,
		WEAPCLASS_ITEM = 0xB,
		WEAPCLASS_CONE = 0xC,
		WEAPCLASS_BEAM = 0xD,
		WEAPCLASS_SHIELD = 0xE,
		WEAPCLASS_HOVER = 0xF,
		WEAPCLASS_CLOAK = 0x10,
		WEAPCLASS_PING = 0x11,
		WEAPCLASS_REPULSOR = 0x12,
		WEAPCLASS_ADRENALINE = 0x13,
		WEAPCLASS_HEALTH = 0x14,
		WEAPCLASS_MUTE = 0x15,
		WEAPCLASS_UNDERWATER = 0x16,
		WEAPCLASS_BALL = 0x17,
		WEAPCLASS_NUM = 0x18,
	};

	enum weapInventoryType_t : std::int32_t
	{
		WEAPINVENTORY_PRIMARY = 0x0,
		WEAPINVENTORY_OFFHAND = 0x1,
		WEAPINVENTORY_ITEM = 0x2,
		WEAPINVENTORY_ALTMODE = 0x3,
		WEAPINVENTORY_EXCLUSIVE = 0x4,
		WEAPINVENTORY_SCAVENGER = 0x5,
		WEAPINVENTORYCOUNT = 0x6,
	};

	enum weapFireType_t : std::int32_t
	{
		WEAPON_FIRETYPE_FULLAUTO = 0x0,
		WEAPON_FIRETYPE_SINGLESHOT = 0x1,
		WEAPON_FIRETYPE_BURSTFIRE2 = 0x2,
		WEAPON_FIRETYPE_BURSTFIRE3 = 0x3,
		WEAPON_FIRETYPE_BURSTFIRE4 = 0x4,
		WEAPON_FIRETYPE_DOUBLEBARREL = 0x5,
		WEAPON_FIRETYPECOUNT = 0x6,
		WEAPON_FIRETYPE_BURSTFIRE_FIRST = 0x2,
		WEAPON_FIRETYPE_BURSTFIRE_LAST = 0x4,
	};

	enum PenetrateType : std::uint32_t
	{
		PENETRATE_TYPE_NONE = 0x0,
		PENETRATE_TYPE_SMALL = 0x1,
		PENETRATE_TYPE_MEDIUM = 0x2,
		PENETRATE_TYPE_LARGE = 0x3,
		PENETRATE_TYPE_COUNT = 0x4,
	};

	enum ImpactType : std::int32_t
	{

	};

	enum weapStance_t : std::int32_t
	{
		WEAPSTANCE_STAND = 0x0,
		WEAPSTANCE_DUCK = 0x1,
		WEAPSTANCE_PRONE = 0x2,
		WEAPSTANCE_NUM = 0x3,
	};

	enum OffhandClass : std::uint32_t
	{
		OFFHAND_CLASS_NONE = 0x0,
		OFFHAND_CLASS_FRAG_GRENADE = 0x1,
		OFFHAND_CLASS_SMOKE_GRENADE = 0x2,
		OFFHAND_CLASS_FLASH_GRENADE = 0x3,
		OFFHAND_CLASS_OTHER = 0x9,
		OFFHAND_CLASS_COUNT = 0xA,
	};

	enum weapProjExposion_t : std::int32_t
	{
		WEAPPROJEXP_GRENADE = 0x0,
		WEAPPROJEXP_ROCKET = 0x1,
		WEAPPROJEXP_FLASHBANG = 0x2,
		WEAPPROJEXP_NONE = 0x3,
		WEAPPROJEXP_DUD = 0x4,
		WEAPPROJEXP_SMOKE = 0x5,
		WEAPPROJEXP_HEAVY = 0x6,
		WEAPPROJEXP_NUM = 0x7,
	};

	enum weapAdsFireMode_t : std::int32_t
	{
		WEAPADSFIREMODE_NUM = 0x3,
	};

	enum weapGreebleType_t : std::int32_t
	{
		WEAPGREEBLE_NONE = 0x0,
		WEAPGREEBLE_ACCURACYLEVEL1 = 0x1,
		WEAPGREEBLE_ACCURACYLEVEL2 = 0x2,
		WEAPGREEBLE_FIRERATELEVEL1 = 0x3,
		WEAPGREEBLE_FIRERATELEVEL2 = 0x4,
		WEAPGREEBLE_NUM = 0x5,
	};

	enum weapAutoReloadType_t : std::int32_t
	{

	};

	enum weapAutoHolsterType_t : std::int32_t
	{

	};

	enum weapFireBarrels_t : std::int32_t
	{

	};

	enum weapFireTimeInterpolation_t : std::int32_t
	{

	};

	enum WeaponSlotRestriction : std::int32_t
	{
		SLOT_RESTRICTION_NONE = 0x0,
		SLOT_RESTRICTION_OPEN = 0x1,
		SLOT_RESTRICTION_PRESET = 0x2,
		SLOT_RESTRICTION_COUNT = 0x3,
	};

	enum AttachmentType : std::int32_t
	{
		ATTACHMENT_SCOPE = 0x0,
		ATTACHMENT_UNDERBARREL = 0x1,
		ATTACHMENT_OTHER = 0x2,
		ATTACHMENT_COUNT = 0x3,
	};

	struct AttChargeInfo
	{
		float minChargeTime;
		float overChargeTime;
		float timePerChargeShot;
		int maxChargeShots;
		float minChargeAngle;
		float maxChargeAngle;
		bool autoFireOnMaxCharge;
	}; assert_sizeof(AttChargeInfo, 28);

	struct AttHybridSettings
	{
		float adsSpread;
		float adsAimPitch;
		float adsTransInTime;
		float adsTransInFromSprintTime;
		float adsTransOutTime;
		int adsReloadTransTime;
		float adsCrosshairInFrac;
		float adsCrosshairOutFrac;
		float adsZoomFov;
		float adsZoomInFrac;
		float adsZoomOutFrac;
		float adsFovLerpInTime;
		float adsFovLerpOutTime;
		float adsBobFactor;
		float adsViewBobMult;
		float adsViewErrorMin;
		float adsViewErrorMax;
		float adsFireAnimFrac;
	}; assert_sizeof(AttHybridSettings, 72);

	union WAFieldParm
	{
		char p_char;
		bool p_bool;
		int p_int;
		float p_float;
		const char* string;
	};

	enum WAFieldType : std::uint8_t
	{
		WAFIELD_TYPE_STRING = 0,
		WAFIELD_TYPE_INT = 4,
		WAFIELD_TYPE_BOOL = 6,
		WAFIELD_TYPE_FLOAT = 7,
		WAFIELD_TYPE_FLOAT32 = 9,
		WAFIELD_TYPE_FX = 10,
		WAFIELD_TYPE_MODEL = 11,
		WAFIELD_TYPE_ANIM = 12,
		WAFIELD_TYPE_MATERIAL = 13,
		WAFIELD_TYPE_SOUND = 15,
		WAFIELD_TYPE_TRACER = 16,
	};

	enum WAFieldCode : std::uint8_t
	{
		FIELD_OP_STRING_SET = 0,
		FIELD_OP_STRING_REPLACE = 1,
		FIELD_OP_STRING_APPEND = 2,
		FIELD_OP_NUMBER_BEGIN = 3,
		FIELD_OP_NUMBER_SET = 3,
		FIELD_OP_NUMBER_ADD = 4,
		//FIELD_OP_NUMBER_ADD_MULTIPLY = 5,
		FIELD_OP_NUMBER_MULTIPLY = 6,
		FIELD_OP_NUMBER_END = 6,
		FIELD_OP_COUNT = 7,
	};

	struct WAField
	{
		unsigned char index;
		unsigned char type; //WAFieldType type;
		unsigned char code; // WAFieldCode code;
		WAFieldParm parm;
	}; assert_sizeof(WAField, 16);

	struct WeaponAttachment
	{
		union
		{
			const char* szInternalName;
			const char* name;
		};
		const char* szDisplayName; // 8
		AttachmentType type; // 16
		weapType_t weaponType; // 20
		weapClass_t weapClass; // 24
		weapGreebleType_t greebleType; // 28
		XModel** worldModels; // 32 (2 xmodels)
		XModel** viewModels; // 40 (2 xmodels)
		XModel** reticleViewModels; // 48 (64 xmodels)
		snd_alias_list_t** bounceSounds; // 56 (53 sounds)
		snd_alias_list_t** rollingSounds; // 64 (53 sounds)
		AttChargeInfo* chargeInfo; // 72
		AttHybridSettings* hybridSettings; // 80
		scr_string_t* hideTags; // 88 (4 strings)
		scr_string_t* showTags; // 96 (4 strings)
		unsigned short* fieldOffsets; // 104
		WAField* fields; // 112
		unsigned int numFields; // 120 (MAX_ATTACH_FIELDS_PER_WEAPON = 256)
		int loadIndex;
		int unused1;
		bool isAlternateAmmo;
		bool hideIronSightsWithThisAttachment;
		bool showMasterRail;
		bool showSideRail;
		bool shareAmmoWithAlt; // 136
		bool knifeAlwaysAttached;
		bool riotShield; // 138
		bool automaticAttachment;
		int unused2;
		// size: 144
	}; assert_sizeof(WeaponAttachment, 0x90);
	assert_offsetof(WeaponAttachment, shareAmmoWithAlt, 136);
	assert_offsetof(WeaponAttachment, riotShield, 138);

	struct AnimOverrideEntry
	{
		unsigned char animHand;
		unsigned char attachment1;
		unsigned char attachment2;
		unsigned char animTreeType;
		XAnimParts* overrideAnim;
		XAnimParts* altmodeAnim;
		int animTime;
		int altTime;
	}; assert_sizeof(AnimOverrideEntry, 32);

	struct SoundOverrideEntry
	{
		unsigned char attachment1;
		unsigned char attachment2;
		unsigned char soundType;
		snd_alias_list_t* overrideSound;
		snd_alias_list_t* altmodeSound;
	}; assert_sizeof(SoundOverrideEntry, 24);

	struct FXOverrideEntry
	{
		unsigned char attachment1;
		unsigned char attachment2;
		unsigned char fxType;
		FxEffectDef* overrideFX;
		FxEffectDef* altmodeFX;
	}; assert_sizeof(FXOverrideEntry, 24);

	struct ReloadStateTimerEntry
	{
		int attachment;
		int reloadAddTime;
		int reloadEmptyAddTime;
		int reloadStartAddTime;
	}; assert_sizeof(ReloadStateTimerEntry, 16);

	struct NoteTrackToSoundEntry
	{
		int attachment;
		scr_string_t* notetrackSoundMapKeys;
		scr_string_t* notetrackSoundMapValues;
	}; assert_sizeof(NoteTrackToSoundEntry, 24);

	struct TracerDef
	{
		const char* name;
		Material* material;
		FxEffectDef* effectDef;
		unsigned int drawInterval;
		float speed;
		float beamLength;
		float beamWidth;
		float screwRadius;
		float screwDist;
		float colors[5][4];
	}; assert_sizeof(TracerDef, 0x80);

	struct LaserDef
	{
		const char* name;
		Material* laserMaterial;
		Material* laserLightMaterial;
		FxEffectDef* laserEndEffect;
		LaserDef* friendlyTeamLaser;
		scr_string_t laserTag;
		float color[4];
		float hdrColorScale[4];
		float laserLightColor[4];
		float laserLightHdrColorScale[4];
		float range;
		float radius;
		float endOffset;
		float flarePct;
		float texCoordOffset;
		float laserLightRadius;
		float laserLightBeginOffset;
		float laserLightEndOffset;
		float laserLightBodyTweak;
		bool ownerOnly;
		bool nightvisionOnly;
		bool useHalfCylinderGeometry;
		bool laserLight;
		bool laserLightNvgOnly;
		bool laserSightLaser;
	}; assert_sizeof(LaserDef, 0x98);

	struct TurretHydraulicSettings
	{
		float minVelocity;
		float maxVelocity; // unused or padding
		snd_alias_list_t* verticalSound;
		snd_alias_list_t* verticalStopSound;
		snd_alias_list_t* horizontalSound;
		snd_alias_list_t* horizontalStopSound;
	}; assert_sizeof(TurretHydraulicSettings, 40);

	enum weapOverlayReticle_t : std::int32_t
	{
		WEAPOVERLAYRETICLE_NONE = 0x0,
		WEAPOVERLAYRETICLE_CROSSHAIR = 0x1,
		WEAPOVERLAYRETICLE_NUM = 0x2,
	};

	struct ADSOverlay
	{
		Material* shader;
		Material* shaderLowRes;
		Material* shaderEMP;
		Material* shaderEMPLowRes;
		weapOverlayReticle_t reticle;
		float width;
		float height;
		float widthSplitscreen;
		float heightSplitscreen;
	}; assert_sizeof(ADSOverlay, 0x38);

	enum weaponIconRatioType_t : std::int32_t
	{
		WEAPON_ICON_RATIO_1TO1 = 0x0,
		WEAPON_ICON_RATIO_2TO1 = 0x1,
		WEAPON_ICON_RATIO_4TO1 = 0x2,
		WEAPON_ICON_RATIO_COUNT = 0x3,
	};

	enum WeapStickinessType : std::int32_t
	{
		WEAPSTICKINESS_NONE = 0x0,
		WEAPSTICKINESS_ALL = 0x1,
		WEAPSTICKINESS_ALL_ORIENT = 0x2,
		WEAPSTICKINESS_GROUND = 0x3,
		WEAPSTICKINESS_GROUND_WITH_YAW = 0x4,
		WEAPSTICKINESS_KNIFE = 0x5,
		WEAPSTICKINESS_COUNT = 0x6,
	};

	enum guidedMissileType_t : std::int32_t
	{
		MISSILE_GUIDANCE_NONE = 0x0,
		MISSILE_GUIDANCE_SIDEWINDER = 0x1,
		MISSILE_GUIDANCE_HELLFIRE = 0x2,
		MISSILE_GUIDANCE_JAVELIN = 0x3,
		MISSILE_GUIDANCE_UNKNOWN0 = 0x4,
		MISSILE_GUIDANCE_UNKNOWN1 = 0x5,
		MISSILE_GUIDANCE_UNKNOWN2 = 0x6,
		MISSILE_GUIDANCE_COUNT = 0x7,
	};

	enum WeapOverlayInteface_t : std::int32_t
	{
		WEAPOVERLAYINTERFACE_NONE = 0x0,
		WEAPOVERLAYINTERFACE_JAVELIN = 0x1,
		WEAPOVERLAYINTERFACE_TURRETSCOPE = 0x2,
		WEAPOVERLAYINTERFACECOUNT = 0x3,
	};

	enum weapAnimFiles_t : std::int32_t
	{
		WEAP_ANIM_INVALID = -1,
		WEAP_ANIM_ROOT = 0,
		WEAP_ANIM_IDLE = 1,
		WEAP_ANIM_EMPTY_IDLE = 2,
		WEAP_ANIM_FIRE = 3,
		WEAP_ANIM_HOLD_FIRE = 4,
		WEAP_ANIM_LASTSHOT = 5,
		WEAP_ANIM_RECHAMBER = 6,
		WEAP_ANIM_GRENADE_PRIME = 7,
		WEAP_ANIM_GRENADE_PRIME_READY_TO_THROW = 8,
		WEAP_ANIM_MELEE_SWIPE = 9,
		WEAP_ANIM_MELEE_HIT = 10,
		WEAP_ANIM_MELEE_FATAL = 11,
		WEAP_ANIM_MELEE_MISS = 12,
		WEAP_ANIM_MELEE_VICTIM_CROUCHING_HIT = 13,
		WEAP_ANIM_MELEE_VICTIM_CROUCHING_FATAL = 14,
		WEAP_ANIM_MELEE_VICTIM_CROUCHING_MISS = 15,
		WEAP_ANIM_MELEE_ALT_STANDING = 16,
		WEAP_ANIM_MELEE_ALT_CROUCHING = 17,
		WEAP_ANIM_MELEE_ALT_PRONE = 18,
		WEAP_ANIM_MELEE_ALT_JUMPING = 19,
		WEAP_ANIM_MELEE_ALT_STANDING_VICTIM_CROUCHING = 20,
		WEAP_ANIM_MELEE_ALT_CROUCHING_VICTIM_CROUCHING = 21,
		WEAP_ANIM_MELEE_ALT_PRONE_VICTIM_CROUCHING = 22,
		WEAP_ANIM_MELEE_ALT_JUMPING_VICTIM_CROUCHING = 23,
		WEAP_ANIM_RELOAD = 24,
		WEAP_ANIM_RELOAD_EMPTY = 25,
		WEAP_ANIM_RELOAD_START = 26,
		WEAP_ANIM_RELOAD_END = 27,
		WEAP_ANIM_FAST_RELOAD = 28,
		WEAP_ANIM_FAST_RELOAD_EMPTY = 29,
		WEAP_ANIM_FAST_RELOAD_START = 30,
		WEAP_ANIM_FAST_RELOAD_END = 31,
		WEAP_ANIM_DUALMAG_RELOAD = 32,
		WEAP_ANIM_DUALMAG_RELOAD_EMPTY = 33,
		WEAP_ANIM_SPEED_RELOAD = 34,
		WEAP_ANIM_RELOAD_FROM_ALT = 35,
		WEAP_ANIM_RAISE = 36,
		WEAP_ANIM_FIRST_RAISE = 37,
		WEAP_ANIM_BREACH_RAISE = 38,
		WEAP_ANIM_DROP = 39,
		WEAP_ANIM_ALT_RAISE = 40,
		WEAP_ANIM_ALT_DROP = 41,
		WEAP_ANIM_ALT_OVERRIDE = 42,
		WEAP_ANIM_QUICK_RAISE = 43,
		WEAP_ANIM_QUICK_DROP = 44,
		WEAP_ANIM_EMPTY_RAISE = 45,
		WEAP_ANIM_EMPTY_DROP = 46,
		WEAP_ANIM_HYBRID_SIGHT_ON = 47,
		WEAP_ANIM_HYBRID_SIGHT_OFF = 48,
		WEAP_ANIM_SPRINT_IN = 49,
		WEAP_ANIM_SPRINT_IN_FROM_SLIDE = 50,
		WEAP_ANIM_SPRINT_IN_CANCEL = 51,
		WEAP_ANIM_SPRINT_LOOP = 52,
		WEAP_ANIM_SPRINT_OUT = 53,
		WEAP_ANIM_SPRINTANDFIRE_IN = 54,
		WEAP_ANIM_SPRINTANDFIRE_LOOP = 55,
		WEAP_ANIM_SPRINTANDFIRE_OUT = 56,
		WEAP_ANIM_STUNNED_START = 57,
		WEAP_ANIM_STUNNED_LOOP = 58,
		WEAP_ANIM_STUNNED_END = 59,
		WEAP_ANIM_THROWBACK = 60,
		WEAP_ANIM_DETONATE = 61,
		WEAP_ANIM_NIGHTVISION_WEAR = 62,
		WEAP_ANIM_NIGHTVISION_REMOVE = 63,
		WEAP_ANIM_ADS_FIRE = 64,
		WEAP_ANIM_ADS_LASTSHOT = 65,
		WEAP_ANIM_ADS_RECHAMBER = 66,
		WEAP_ANIM_BLAST_FRONT = 67,
		WEAP_ANIM_BLAST_RIGHT = 68,
		WEAP_ANIM_BLAST_BACK = 69,
		WEAP_ANIM_BLAST_LEFT = 70,
		WEAP_ANIM_SLIDE_IN = 71,
		WEAP_ANIM_SLIDE_LOOP = 72,
		WEAP_ANIM_SLIDE_OUT_TO_SPRINT = 73,
		WEAP_ANIM_SLIDE_OUT = 74,
		WEAP_ANIM_SLIDE_AND_FIRE_IN = 75,
		WEAP_ANIM_SLIDE_AND_FIRE_LOOP = 76,
		WEAP_ANIM_SLIDE_AND_FIRE_OUT = 77,
		WEAP_ANIM_HIGH_JUMP_IN = 78,
		WEAP_ANIM_HIGH_JUMP_DROP_IN = 79,
		WEAP_ANIM_HIGH_JUMP_DROP_LOOP = 80,
		WEAP_ANIM_HIGH_JUMP_DROP_LAND = 81,
		WEAP_ANIM_DODGE_GROUND_BACK = 82,
		WEAP_ANIM_DODGE_GROUND_LEFT = 83,
		WEAP_ANIM_DODGE_GROUND_RIGHT = 84,
		WEAP_ANIM_DODGE_AIR_FORWARD = 85,
		WEAP_ANIM_DODGE_AIR_BACK = 86,
		WEAP_ANIM_DODGE_AIR_LEFT = 87,
		WEAP_ANIM_DODGE_AIR_RIGHT = 88,
		WEAP_ANIM_LAND_DIP = 89,
		WEAP_ANIM_RECOIL_SETTLE = 90,
		WEAP_ANIM_SWIM_LOOP = 91,
		WEAP_ANIM_MANTLE_UP_64 = 92,
		WEAP_ANIM_MANTLE_UP_56 = 93,
		WEAP_ANIM_MANTLE_UP_48 = 94,
		WEAP_ANIM_MANTLE_UP_40 = 95,
		WEAP_ANIM_MANTLE_UP_32 = 96,
		WEAP_ANIM_MANTLE_UP_24 = 97,
		WEAP_ANIM_MANTLE_UP_16 = 98,
		WEAP_ANIM_MANTLE_OVER_64 = 99,
		WEAP_ANIM_MANTLE_OVER_56 = 100,
		WEAP_ANIM_MANTLE_OVER_48 = 101,
		WEAP_ANIM_MANTLE_OVER_40 = 102,
		WEAP_ANIM_MANTLE_OVER_32 = 103,
		WEAP_ANIM_MANTLE_OVER_24 = 104,
		WEAP_ANIM_MANTLE_OVER_16 = 105,
		WEAP_ANIM_GOLIATH_ENTRY = 106,
		WEAP_ANIM_OFFHAND_SWITCH = 107,
		WEAP_ANIM_HEAT_COOLDOWN_IN = 108,
		WEAP_ANIM_HEAT_COOLDOWN_OUT = 109,
		WEAP_ANIM_OVERHEAT_OUT = 110,
		WEAP_ANIM_SCRIPTED = 111,
		WEAP_ANIM_INSPECTION = 112,
		WEAP_ANIM_RELOAD_MULTIPLE_1 = 113,
		WEAP_ANIM_RELOAD_MULTIPLE_2 = 114,
		WEAP_ANIM_RELOAD_MULTIPLE_3 = 115,
		WEAP_ANIM_RELOAD_MULTIPLE_4 = 116,
		WEAP_ANIM_RELOAD_MULTIPLE_5 = 117,
		WEAP_ANIM_RELOAD_MULTIPLE_6 = 118,
		WEAP_ANIM_RELOAD_MULTIPLE_7 = 119,
		WEAP_ANIM_RELOAD_MULTIPLE_8 = 120,
		WEAP_ANIM_RELOAD_MULTIPLE_FAST_1 = 121,
		WEAP_ANIM_RELOAD_MULTIPLE_FAST_2 = 122,
		WEAP_ANIM_RELOAD_MULTIPLE_FAST_3 = 123,
		WEAP_ANIM_RELOAD_MULTIPLE_FAST_4 = 124,
		WEAP_ANIM_RELOAD_MULTIPLE_FAST_5 = 125,
		WEAP_ANIM_RELOAD_MULTIPLE_FAST_6 = 126,
		WEAP_ANIM_RELOAD_MULTIPLE_FAST_7 = 127,
		WEAP_ANIM_RELOAD_MULTIPLE_FAST_8 = 128,
		WEAP_ANIM_ADS_UP = 129,
		WEAP_ANIM_ADS_DOWN = 130,
		WEAP_ANIM_RECOIL = 131,
		WEAP_ALT_ANIM_ADJUST = 132,
		WEAP_ANIM_ADDITIVE_ADS_ROOT = 133,
		WEAP_ANIM_ADDITIVE_ADS_UP = 134,
		WEAP_ANIM_ADDITIVE_HYBRID_SIGHT_UP_ROOT = 135,
		WEAP_ANIM_ADDITIVE_HYBRID_SIGHT_UP = 136,
		WEAP_ANIM_ADDITIVE_DRAG_LEFT_ROOT = 137,
		WEAP_ANIM_ADDITIVE_DRAG_LEFT = 138,
		WEAP_ANIM_ADDITIVE_DRAG_RIGHT_ROOT = 139,
		WEAP_ANIM_ADDITIVE_DRAG_RIGHT = 140,
		WEAP_ANIM_ADDITIVE_DRAG_UP_ROOT = 141,
		WEAP_ANIM_ADDITIVE_DRAG_UP = 142,
		WEAP_ANIM_ADDITIVE_DRAG_DOWN_ROOT = 143,
		WEAP_ANIM_ADDITIVE_DRAG_DOWN = 144,
		WEAP_ANIM_ADDITIVE_SWIM_FORWARD_ROOT = 145,
		WEAP_ANIM_ADDITIVE_SWIM_FORWARD = 146,
		WEAP_ANIM_ADDITIVE_SWIM_BACKWARD_ROOT = 147,
		WEAP_ANIM_ADDITIVE_SWIM_BACKWARD = 148,
		WEAP_ANIM_ADDITIVE_JUMP_ROOT = 149,
		WEAP_ANIM_ADDITIVE_JUMP = 150,
		WEAP_ANIM_ADDITIVE_JUMP_BOOST = 151,
		WEAP_ANIM_ADDITIVE_JUMP_LAND_ROOT = 152,
		WEAP_ANIM_ADDITIVE_JUMP_LAND = 153,
		WEAP_ANIM_ADDITIVE_JUMP_LAND_HEAVY = 154,
		WEAP_ANIM_ADDITIVE_WALK_ROOT = 155,
		WEAP_ANIM_ADDITIVE_WALK = 156,
		WEAP_ANIM_ADDITIVE_HEAT_COOLDOWN_LOOP_ROOT = 157,
		WEAP_ANIM_ADDITIVE_HEAT_COOLDOWN_LOOP = 158,
		WEAP_ANIM_ADDITIVE_OVERHEAT_IN_ROOT = 159,
		WEAP_ANIM_ADDITIVE_OVERHEAT_IN = 160,
		WEAP_ANIM_ADDITIVE_OVERHEAT_LOOP_ROOT = 161,
		WEAP_ANIM_ADDITIVE_OVERHEAT_LOOP = 162,
		WEAP_ANIM_ADDITIVE_CRAWL_IN_ROOT = 163,
		WEAP_ANIM_ADDITIVE_CRAWL_IN = 164,
		WEAP_ANIM_ADDITIVE_CRAWL_LOOP_ROOT = 165,
		WEAP_ANIM_ADDITIVE_CRAWL_LOOP = 166,
		WEAP_ANIM_ADDITIVE_CRAWL_LOOP_BACK_ROOT = 167,
		WEAP_ANIM_ADDITIVE_CRAWL_LOOP_BACK = 168,
		WEAP_ANIM_ADDITIVE_CRAWL_LOOP_LEFT_ROOT = 169,
		WEAP_ANIM_ADDITIVE_CRAWL_LOOP_LEFT = 170,
		WEAP_ANIM_ADDITIVE_CRAWL_LOOP_RIGHT_ROOT = 171,
		WEAP_ANIM_ADDITIVE_CRAWL_LOOP_RIGHT = 172,
		WEAP_ANIM_ADDITIVE_PRONE_DROP_ROOT = 173,
		WEAP_ANIM_ADDITIVE_PRONE_DROP = 174,
		WEAP_ANIM_ADDITIVE_EMPTY_ROOT = 175,
		WEAP_ANIM_ADDITIVE_EMPTY = 176,
		WEAP_ANIM_ADDITIVE_MANTLE_ROOT = 177,
		WEAP_ANIM_ADDITIVE_MANTLE = 178,
		WEAP_ANIM_ADDITIVE_LOW_MANTLE_ROOT = 179,
		WEAP_ANIM_ADDITIVE_MANTLE_UP_24 = 180,
		WEAP_ANIM_ADDITIVE_MANTLE_UP_16 = 181,
		WEAP_ANIM_ADDITIVE_MANTLE_OVER_24 = 182,
		WEAP_ANIM_ADDITIVE_MANTLE_OVER_16 = 183,
		WEAP_ANIM_ADDITIVE_SHOT_CHARGE_IN_ROOT = 184,
		WEAP_ANIM_ADDITIVE_SHOT_CHARGE_IN = 185,
		WEAP_ANIM_ADDITIVE_SHOT_CHARGE_LOOP_ROOT = 186,
		WEAP_ANIM_ADDITIVE_SHOT_CHARGE_LOOP = 187,
		WEAP_ANIM_ADDITIVE_SCRIPTED_ROOT = 188,
		WEAP_ANIM_ADDITIVE_SCRIPTED = 189,
		NUM_WEAP_ANIMS = 190,
	};

	struct StateTimers
	{
		int fireDelay; // 1640 * x
		int meleeDelay; // 1644 * x
		int meleeChargeDelay; // 1648 * x
		int detonateDelay; // 1652 * x
		int fireTime; // 1656 * x
		int rechamberTime; // 1660 * x
		int rechamberTimeOneHanded; // 1664 * x
		int rechamberBoltTime; // 1668 * x
		int holdFireTime; // 1672 * x
		int grenadePrimeReadyToThrowTime; // 1676 * x
		int detonateTime; // 1680 * x
		int meleeTime; // 1684 * x
		int meleeChargeTime; // 1688 * x
		int reloadTime; // 1692 * x
		int reloadShowRocketTime; // 1696 * x
		int reloadEmptyTime; // 1700 * x
		int reloadAddTime; // 1704 * x
		int reloadEmptyAddTime; // 1708 * x
		int reloadStartTime; // 1712 * x
		int reloadStartAddTime; // 1716 * x
		int reloadEndTime; // 1720 * x
		int reloadTimeDualWield; // 1724 * x
		int reloadAddTimeDualWield; // 1728 * x
		int reloadEmptyDualMag; // 1732 * x
		int reloadEmptyAddTimeDualMag; // 1736 * x
		int speedReloadTime; // 1740 * x // (unused)
		int speedReloadAddTime; // 1744 * x // (unused)
		int dropTime; // 1748 * x
		int raiseTime; // 1752 * x
		int altDropTime; // 1756 * x
		int altRaiseTime; // 1760 * x
		int quickDropTime; // 1764 * x
		int quickRaiseTime; // 1768 * x
		int firstRaiseTime; // 1772 * x
		int breachRaiseTime; // 1776 * x
		int emptyRaiseTime; // 1780 * x
		int emptyDropTime; // 1784 * x
		int sprintInTime; // 1788 * x
		int sprintLoopTime; // 1792 * x
		int sprintOutTime; // 1796 * x
		int stunnedTimeBegin; // 1800 * x
		int stunnedTimeLoop; // 1804 * x
		int stunnedTimeEnd; // 1808 * x
		int nightVisionWearTime; // 1812 * x
		int nightVisionWearTimeFadeOutEnd; // 1816 * x
		int nightVisionWearTimePowerUp; // 1820 * x
		int nightVisionRemoveTime; // 1824 * x
		int nightVisionRemoveTimePowerDown; // 1828 * x
		int nightVisionRemoveTimeFadeInStart; // 1832 * x
		int aiFuseTime; // 1836 * x
		int fuseTime; // 1840 * x
		int missileTime; // 1844 * x
		int primeTime; // 1848 * x
		bool bHoldFullPrime; // 1852 * x
		int blastFrontTime; // 1856 * x
		int blastRightTime; // 1860 * x
		int blastBackTime; // 1864 * x
		int blastLeftTime; // 1868 * x
		int slideInTime; // 1872 * x (unused)
		int slideLoopTime; // 1876 * x (unused)
		int slideOutTime; // 1880 * x (unused)
		int highJumpInTime; // 1884 * x (unused)
		int highJumpDropInTime; // 1888 * x (unused)
		int highJumpDropLoopTime; // 1892 * x (unused)
		int highJumpDropLandTime; // 1896 * x (unused)
		int dodgeTime; // 1900 * x (unused)
		int landDipTime; // 1904 * x (unused)
		int hybridSightInTime; // 1908 * x (unused)
		int hybridSightOutTime; // 1912 * x (unused)
		int offhandSwitchTime; // 1916 * x
		int heatCooldownInTime; // 1920 * x
		int heatCooldownOutTime; // 1924 * x
		int heatCooldownOutReadyTime; // 1928 * x
		int overheatOutTime; // 1932 * x
		int overheatOutReadyTime; // 1936 * x
	}; assert_sizeof(StateTimers, 300);

	struct clipindex_t
	{
		int clipIndex;
		bool isAlternate;
	};

	struct ammoindex_t
	{
		int ammoIndex;
		bool isAlternate;
	};

	struct WeaponDef
	{
		union
		{
			const char* szInternalName;
			const char* name;
		};
		const char* szDisplayName; // 8
		const char* szAltWeaponName; // 16
		XModel** gunModel; // 24 (2 xmodels)
		XModel* handModel; // 32
		XModel* persistentArmXModel; // 40
		XModel** reticleViewModels; // 48 (64 xmodels)
		const char* lobWorldModelName; // 56
		XAnimParts** szXAnimsRightHanded; // 64 (190 xanims)
		XAnimParts** szXAnimsLeftHanded; // 72 (190 xanims)
		scr_string_t* hideTags; // 80 (32 xstrings)
		WeaponAttachment** attachments; // 88 (weaponDef + 1332 attachments)
		XAnimParts** szXAnims; // 96 (190 xanims)
		AnimOverrideEntry* animOverrides; // 104 (weaponDef + 1333 overrides)
		SoundOverrideEntry* soundOverrides; // 112 (weaponDef + 1334 overrides)
		FXOverrideEntry* fxOverrides; // 120 (weaponDef + 1335 overrides)
		ReloadStateTimerEntry* reloadOverrides; // 128 (weaponDef + 1336 overrides)
		NoteTrackToSoundEntry* notetrackOverrides; // 136 (weaponDef + 1337 overrides)
		scr_string_t* notetrackSoundMapKeys; // 144 (36 xstrings)
		scr_string_t* notetrackSoundMapValues; // 152 (36 xstrings)
		scr_string_t* notetrackRumbleMapKeys; // 160 (16 xstrings)
		scr_string_t* notetrackRumbleMapValues; // 168 (16 xstrings)
		scr_string_t* notetrackFXMapKeys; // 176 (16 xstrings)
		FxEffectDef** notetrackFXMapValues; // 184 (16 effects)
		scr_string_t* notetrackFXMapTagValues; // 192 (16 xstrings)
		scr_string_t* notetrackUnknownKeys; // 200 (16 xstrings)
		char* notetrackUnknown; // 208 (16 chars)
		scr_string_t* notetrackUnknownValues; // 216 (16 xstrings)
		const char* szAdsrBaseSetting; // 224
		FxEffectDef* viewFlashEffect; // 232
		FxEffectDef* viewBodyFlashEffect; // 240
		FxEffectDef* worldFlashEffect; // 248
		FxEffectDef* viewFlashADSEffect; // 256
		FxEffectDef* viewBodyFlashADSEffect; // 264
		FxEffectDef* signatureViewFlashEffect; // 272
		FxEffectDef* signatureViewBodyFlashEffect; // 280
		FxEffectDef* signatureWorldFlashEffect; // 288
		FxEffectDef* signatureViewFlashADSEffect; // 296
		FxEffectDef* signatureViewBodyFlashADSEffect; // 304
		FxEffectDef* meleeHitEffect; // 312
		FxEffectDef* meleeMissEffect; // 320
		snd_alias_list_t* pickupSound; // 328 (74 sounds)
		snd_alias_list_t* pickupSoundPlayer; // 336
		snd_alias_list_t* ammoPickupSound; // 344
		snd_alias_list_t* ammoPickupSoundPlayer; // 352
		snd_alias_list_t* projectileSound; // 360
		snd_alias_list_t* pullbackSound; // 368
		snd_alias_list_t* pullbackSoundPlayer; // 376
		snd_alias_list_t* pullbackSoundQuick; // 384
		snd_alias_list_t* pullbackSoundQuickPlayer; // 392
		snd_alias_list_t* fireSound; // 400
		snd_alias_list_t* fireSoundPlayer; // 408
		snd_alias_list_t* fireSoundPlayerAkimbo; // 416
		snd_alias_list_t* fireMedSound; // 424
		snd_alias_list_t* fireMedSoundPlayer; // 432
		snd_alias_list_t* fireHighSound; // 440
		snd_alias_list_t* fireHighSoundPlayer; // 448
		snd_alias_list_t* fireLoopSound; // 456
		snd_alias_list_t* fireLoopSoundPlayer; // 464
		snd_alias_list_t* fireMedLoopSound; // 472
		snd_alias_list_t* fireMedLoopSoundPlayer; // 480
		snd_alias_list_t* fireHighLoopSound; // 488
		snd_alias_list_t* fireHighLoopSoundPlayer; // 496
		snd_alias_list_t* fireLoopEndPointSound; // 504
		snd_alias_list_t* fireLoopEndPointSoundPlayer; // 512
		snd_alias_list_t* fireStopSound; // 520
		snd_alias_list_t* fireStopSoundPlayer; // 528
		snd_alias_list_t* fireMedStopSound; // 536
		snd_alias_list_t* fireMedStopSoundPlayer; // 544
		snd_alias_list_t* fireHighStopSound; // 552
		snd_alias_list_t* fireHighStopSoundPlayer; // 560
		snd_alias_list_t* fireLastSound; // 568
		snd_alias_list_t* fireLastSoundPlayer; // 576
		snd_alias_list_t* fireFirstSound; // 584
		snd_alias_list_t* fireFirstSoundPlayer; // 592
		snd_alias_list_t* fireCustomSound; // 600
		snd_alias_list_t* fireCustomSoundPlayer; // 608
		snd_alias_list_t* emptyFireSound; // 616
		snd_alias_list_t* emptyFireSoundPlayer; // 624
		snd_alias_list_t* adsRequiredFireSoundPlayer; // 632
		snd_alias_list_t* meleeSwipeSound; // 640
		snd_alias_list_t* meleeSwipeSoundPlayer; // 648
		snd_alias_list_t* meleeHitSound; // 656
		snd_alias_list_t* meleeHitSoundPlayer; // 664
		snd_alias_list_t* meleeMissSound; // 672
		snd_alias_list_t* meleeMissSoundPlayer; // 680
		snd_alias_list_t* rechamberSound; // 688
		snd_alias_list_t* rechamberSoundPlayer; // 696
		snd_alias_list_t* reloadSound; // 704
		snd_alias_list_t* reloadSoundPlayer; // 712
		snd_alias_list_t* reloadEmptySound; // 720
		snd_alias_list_t* reloadEmptySoundPlayer; // 728
		snd_alias_list_t* reloadStartSound; // 736
		snd_alias_list_t* reloadStartSoundPlayer; // 744
		snd_alias_list_t* reloadEndSound; // 752
		snd_alias_list_t* reloadEndSoundPlayer; // 760
		snd_alias_list_t* detonateSound; // 768
		snd_alias_list_t* detonateSoundPlayer; // 776
		snd_alias_list_t* nightVisionWearSound; // 784
		snd_alias_list_t* nightVisionWearSoundPlayer; // 792
		snd_alias_list_t* nightVisionRemoveSound; // 800
		snd_alias_list_t* nightVisionRemoveSoundPlayer; // 808
		snd_alias_list_t* raiseSound; // 816
		snd_alias_list_t* raiseSoundPlayer; // 824
		snd_alias_list_t* firstRaiseSound; // 832
		snd_alias_list_t* firstRaiseSoundPlayer; // 840
		snd_alias_list_t* altSwitchSound; // 848
		snd_alias_list_t* altSwitchSoundPlayer; // 856
		snd_alias_list_t* putawaySound; // 864
		snd_alias_list_t* putawaySoundPlayer; // 872
		snd_alias_list_t* scanSound; // 880
		snd_alias_list_t* changeVariableZoomSound; // 888
		snd_alias_list_t* adsUpSound; // 896
		snd_alias_list_t* adsDownSound; // 904
		snd_alias_list_t* adsCrosshairEnemySound; // 912
		snd_alias_list_t** bounceSound; // 920 (53 sounds)
		snd_alias_list_t** rollingSound; // 928 (53 sounds)
		FxEffectDef* viewShellEjectEffect; // 936
		FxEffectDef* worldShellEjectEffect; // 944
		FxEffectDef* viewLastShotEjectEffect; // 952
		FxEffectDef* worldLastShotEjectEffect; // 960
		FxEffectDef* viewMagEjectEffect; // 968
		Material* reticleCenter; // 976
		Material* reticleSide; // 984
		XModel** worldModel; // 992 (2 xmodels)
		XModel* worldClipModel; // 1000
		XModel* rocketModel; // 1008
		XModel* knifeModel; // 1016
		XModel* worldKnifeModel; // 1024
		Material* hudIcon; // 1032
		Material* pickupIcon; // 1040
		Material* minimapIconFriendly; // 1048
		Material* minimapIconEnemy; // 1056
		Material* minimapIconNeutral; // 1064
		Material* ammoCounterIcon; // 1072
		const char* szAmmoName; // 1080
		const char* szClipName; // 1088
		const char* szSharedAmmoCapName; // 1096
		PhysCollmap* physCollmap; // 1104
		PhysPreset* physPreset; // 1112
		const char* szUseHintString; // 1120
		const char* dropHintString; // 1128
		float* locationDamageMultipliers; // 1136 (22 floats)
		const char* fireRumble; // 1144
		const char* fireMedRumble; // 1152
		const char* fireHighRumble; // 1160
		const char* meleeImpactRumble; // 1168
		TracerDef* tracerType; // 1176
		TracerDef* signatureTracerType; // 1184
		LaserDef* laserType; // 1192
		snd_alias_list_t* turretOverheatSound; // 1200
		FxEffectDef* turretOverheatEffect; // 1208
		const char* turretBarrelSpinRumble; // 1216
		snd_alias_list_t* turretBarrelSpinMaxSnd; // 1224
		snd_alias_list_t* turretBarrelSpinUpSnd[4]; // 1232
		snd_alias_list_t* turretBarrelSpinDownSnd[4]; // 1264
		snd_alias_list_t* missileConeSoundAlias; // 1296
		snd_alias_list_t* missileConeSoundAliasAtBase; // 1304
		XModel* stowOffsetModel; // 1312
		TurretHydraulicSettings* turretHydraulicSettings; // 1320
		int altWeapon; // 1328
		unsigned char numAttachments; // 1332
		unsigned char numAnimOverrides; // 1333
		unsigned char numSoundOverrides; // 1334
		unsigned char numFXOverrides; // 1335
		unsigned char numReloadStateTimerOverrides; // 1336
		unsigned char numNotetrackOverrides; // 1337
		playerAnimType_t playerAnimType; // 1338
		char __pad000[1];
		weapType_t weapType; // 1340
		weapClass_t weapClass; // 1344
		PenetrateType penetrateType; // 1348
		float penetrateDepth; // 1352
		ImpactType impactType; // 1356
		weapInventoryType_t inventoryType; // 1360
		weapFireType_t fireType; // 1364
		weapFireBarrels_t fireBarrels; // 1368
		weapAdsFireMode_t adsFireMode; // 1372
		float burstFireCooldown; // 1376
		weapGreebleType_t greebleType; // 1380
		weapAutoReloadType_t autoReloadType; // 1384
		weapAutoHolsterType_t autoHolsterType; // 1388
		OffhandClass offhandClass; // 1392
		weapStance_t stance; // 1396
		int reticleCenterSize; // 1400
		int reticleSideSize; // 1404
		int reticleMinOfs; // 1408
		activeReticleType_t activeReticleType; // 1412
		float standMove[3]; // 1416 1420 1424
		float standRot[3]; // 1428 1432 1436
		float strafeMove[3]; // 1440 1444 1448
		float strafeRot[3]; // 1452 1456 1460
		float duckedOfs[3]; // 1464 1468 1472
		float duckedMove[3]; // 1476 1480 1484
		float duckedRot[3]; // 1488 1492 1496
		float proneOfs[3]; // 1500 1504 1508
		float proneMove[3]; // 1512 1516 1520
		float proneRot[3]; // 1524 1528 1532
		float posMoveRate; // 1536
		float posProneMoveRate; // 1540
		float standMoveMinSpeed; // 1544
		float duckedMoveMinSpeed; // 1548
		float proneMoveMinSpeed; // 1552
		float posRotRate; // 1556
		float posProneRotRate; // 1560
		weaponIconRatioType_t hudIconRatio; // 1564
		weaponIconRatioType_t pickupIconRatio; // 1568
		weaponIconRatioType_t ammoCounterIconRatio; // 1572
		int ammoCounterClip; // 1576
		int startAmmo; // 1580
		ammoindex_t iAmmoIndex; // 1584 (runtime variable)
		clipindex_t iClipIndex; // 1592 (runtime variable)
		int maxAmmo; // 1600
		int minAmmoReq; // 1604
		int clipSize; // 1608
		int shotCount; // 1612
		int sharedAmmoCapIndex; // 1616
		int sharedAmmoCap; // 1620
		int damage; // 1624
		int playerDamage; // 1628
		int meleeDamage; // 1632
		int damageType; // 1636
		StateTimers stateTimers; // 1640
		StateTimers akimboStateTimers; // 1940
		float autoAimRange; // 2240
		float aimAssistRange; // 2244
		float aimAssistRangeAds; // 2248
		float aimPadding; // 2252
		float enemyCrosshairRange; // 2256 
		float moveSpeedScale; // 2260
		float adsMoveSpeedScale; // 2264
		float sprintDurationScale; // 2268
		float adsZoomFov; // 2272
		float adsZoomInFrac; // 2276
		float adsZoomOutFrac; // 2280
		float adsSceneBlurStrength; // 2284 (1401FC630)
		float adsSceneBlurPhysicalScale; // 2288 (1400CF870)
		float pad3; // 2292 X
		ADSOverlay overlay; // 2296
		WeapOverlayInteface_t overlayInterface; // 2352
		float adsBobFactor; // 2356
		float adsViewBobMult; // 2360
		float hipSpreadStandMin; // 2364
		float hipSpreadDuckedMin; // 2368
		float hipSpreadProneMin; // 2372
		float hipSpreadStandMax; // 2376
		float hipSpreadSprintMax; // 2380 X
		float hipSpreadSlideMax; // 2384 X
		float hipSpreadDuckedMax; // 2388
		float hipSpreadProneMax; // 2392
		float hipSpreadDecayRate; // 2396
		float hipSpreadFireAdd; // 2400
		float hipSpreadTurnAdd; // 2404
		float hipSpreadMoveAdd; // 2408
		float hipSpreadDuckedDecay; // 2412
		float hipSpreadProneDecay; // 2416
		float hipReticleSidePos; // 2420
		float adsIdleAmount; // 2424
		float hipIdleAmount; // 2428
		float adsIdleSpeed; // 2432
		float hipIdleSpeed; // 2436f
		float idleCrouchFactor; // 2440
		float idleProneFactor; // 2444
		float gunMaxPitch; // 2448
		float gunMaxYaw; // 2452
		float adsIdleLerpStartTime; // 2456
		float adsIdleLerpTime; // 2460
		int adsTransInTime; // 2464
		int adsTransInFromSprintTime; // 2468 X
		int adsTransOutTime; // 2472
		float swayMaxAngleSteadyAim; // 2476 X
		float swayMaxAngle; // 2480
		float swayLerpSpeed; // 2484
		float swayPitchScale; // 2488
		float swayYawScale; // 2492
		float swayVertScale; // 2496
		float swayHorizScale; // 2500
		float swayShellShockScale; // 2504
		float adsSwayMaxAngle; // 2508
		float adsSwayLerpSpeed; // 2512
		float adsSwayPitchScale; // 2516
		float adsSwayYawScale; // 2520
		float adsSwayHorizScale; // 2524
		float adsSwayVertScale; // 2528
		float adsViewErrorMin; // 2532
		float adsViewErrorMax; // 2536
		float adsFireAnimFrac; // 2540
		float dualWieldViewModelOffset; // 2544
		float scopeDriftDelay; // 2548
		float scopeDriftLerpInTime; // 2552
		float scopeDriftSteadyTime; // 2556
		float scopeDriftLerpOutTime; // 2560
		float scopeDriftSteadyFactor; // 2564
		float scopeDriftUnsteadyFactor; // 2568
		float bobVerticalFactor; // 2572
		float bobHorizontalFactor; // 2576
		float bobViewVerticalFactor; // 2580
		float bobViewHorizontalFactor; // 2584
		float stationaryZoomFov; // 2588
		float stationaryZoomDelay; // 2592
		float stationaryZoomLerpInTime; // 2596
		float stationaryZoomLerpOutTime; // 2600
		float adsDofStart; // 2604
		float adsDofEnd; // 2608
		float pad1; // 2612 X
		Material* killIcon; // 2616
		Material* dpadIcon; // 2624
		Material* hudProximityWarningIcon; // 2632
		weaponIconRatioType_t killIconRatio; // 2640
		weaponIconRatioType_t dpadIconRatio; // 2644
		int fireAnimLength; // 2648
		int fireAnimLengthAkimbo; // 2652
		int inspectAnimTime; // 2656
		int reloadAmmoAdd; // 2660
		int reloadStartAdd; // 2664
		int ammoDropStockMin; // 2668
		int ammoDropStockMax; // 2672
		int ammoDropClipPercentMin; // 2676
		int ammoDropClipPercentMax; // 2680
		int explosionRadius; // 2684
		int explosionRadiusMin; // 2688
		int explosionInnerDamage; // 2692
		int explosionOuterDamage; // 2696
		float damageConeAngle; // 2700
		float bulletExplDmgMult; // 2704
		float bulletExplRadiusMult; // 2708
		int projectileSpeed; // 2712
		int projectileSpeedUp; // 2716
		int projectileSpeedForward; // 2720
		int projectileActivateDist; // 2724
		float projLifetime; // 2728
		float timeToAccelerate; // 2732
		float projectileCurvature; // 2736
		float pad2; // 2740 X
		const char* projectileName; // 2744
		XModel* projectileModel; // 2752
		FxEffectDef* projExplosionEffect; // 2760
		FxEffectDef* projDudEffect; // 2768
		snd_alias_list_t* projExplosionSound; // 2776
		snd_alias_list_t* projDudSound; // 2784
		weapProjExposion_t projExplosion; // 2792
		WeapStickinessType stickiness; // 2796
		float lowAmmoWarningThreshold; // 2800
		float ricochetChance; // 2804
		int riotShieldHealth; // 2808
		float riotShieldDamageMult; // 2812
		float* parallelBounce; // 2816 (53 floats)
		float* perpendicularBounce; // 2824 (53 floats)
		FxEffectDef* projTrailEffect; // 2832
		FxEffectDef* projBeaconEffect; // 2840
		float projectileColor[3]; // 2848 2852 2856
		guidedMissileType_t guidedMissileType; // 2860
		float maxSteeringAccel; // 2864
		int projIgnitionDelay; // 2868
		FxEffectDef* projIgnitionEffect; // 2872
		snd_alias_list_t* projIgnitionSound; // 2880
		float adsAimPitch; // 2888
		float adsCrosshairInFrac; // 2892
		float adsCrosshairOutFrac; // 2896
		int adsGunKickReducedKickBullets; // 2900
		float adsGunKickReducedKickPercent; // 2904
		float adsGunKickPitchMin; // 2908
		float adsGunKickPitchMax; // 2912
		float adsGunKickYawMin; // 2916
		float adsGunKickYawMax; // 2920
		float adsGunKickMagMin; // 2924
		float adsGunKickAccel; // 2928
		float adsGunKickSpeedMax; // 2932
		float adsGunKickSpeedDecay; // 2936
		float adsGunKickStaticDecay; // 2940
		float adsViewKickPitchMin; // 2944
		float adsViewKickPitchMax; // 2948
		float adsViewKickYawMin; // 2952
		float adsViewKickYawMax; // 2956
		float adsViewKickMagMin; // 2960
		float adsViewKickCenterSpeed; // 2964
		float adsViewScatterMin; // 2968 X
		float adsViewScatterMax; // 2972 X
		float adsSpread; // 2976
		int hipGunKickReducedKickBullets; // 2980
		float hipGunKickReducedKickPercent; // 2984
		float hipGunKickPitchMin; // 2988
		float hipGunKickPitchMax; // 2992
		float hipGunKickYawMin; // 2996
		float hipGunKickYawMax; // 3000
		float hipGunKickMagMin; // 3004
		float hipGunKickAccel; // 3008
		float hipGunKickSpeedMax; // 3012
		float hipGunKickSpeedDecay; // 3016
		float hipGunKickStaticDecay; // 3020
		float hipViewKickPitchMin; // 3024
		float hipViewKickPitchMax; // 3028
		float hipViewKickYawMin; // 3032
		float hipViewKickYawMax; // 3036
		float hipViewKickMagMin; // 3040
		float hipViewKickCenterSpeed; // 3044
		float hipViewScatterMin; // 3048 //*
		float hipViewScatterMax; // 3052 //*
		float viewKickScale; // 3056 //*
		int positionReloadTransTime; // 3060
		float fightDist; // 3064
		float maxDist; // 3068
		const char* accuracyGraphName[2]; // 3072
		vec2_t* accuracyGraphKnots[2]; // 3088
		vec2_t* originalAccuracyGraphKnots[2]; // 3104
		short accuracyGraphKnotCount[2]; // 3120
		float leftArc; // 3128
		float rightArc; // 3132
		float topArc; // 3136
		float bottomArc; // 3140
		float accuracy; // 3144
		float aiSpread; // 3148
		float playerSpread; // 3152
		float minTurnSpeed[2]; //3156
		float maxTurnSpeed[2]; // 3164
		float pitchConvergenceTime; // 3172
		float yawConvergenceTime; // 3176
		float suppressTime; // 3180
		float maxRange; // 3184
		float animHorRotateInc; // 3188
		float playerPositionDist; // 3192
		unsigned int useHintStringIndex; // 3196 (runtime variable)
		unsigned int dropHintStringIndex; // 3200 (runtime variable)
		float horizViewJitter; // 3204
		float vertViewJitter; // 3208
		float scanSpeed; // 3212
		float scanAccel; // 3216
		int scanPauseTime; // 3220
		const char* szScript; // 3224
		int minDamage; // 3232
		int midDamage; // 3236
		int minPlayerDamage; // 3240
		int midPlayerDamage; // 3244
		float maxDamageRange; // 3248
		float minDamageRange; // 3252
		int signatureAmmoInClip; // 3256 X
		int signatureDamage; // 3260 X
		int signatureMidDamage; // 3264 X
		int signatureMinDamage; // 3268 X
		float signatureMaxDamageRange; // 3272 X
		float signatureMinDamageRange; // 3276 X
		float destabilizationRateTime; // 3280
		float destabilizationCurvatureMax; // 3284
		int destabilizeDistance; // 3288
		float turretADSTime; // 3292
		float turretFov; // 3296 X
		float turretFovADS; // 3300 X
		float turretScopeZoomRate; // 3304 X
		float turretScopeZoomMin; // 3308 X
		float turretScopeZoomMax; // 3312 X
		float overheatUpRate; // 3316 X
		float overheatDownRate; // 3320 X
		float overheatCooldownRate; // 3324 X
		float overheatPenalty; // 3328 X
		float turretBarrelSpinSpeed; // 3332
		float turretBarrelSpinUpTime; // 3336
		float turretBarrelSpinDownTime; // 3340 X
		float missileConeSoundRadiusAtTop; // 3344 X
		float missileConeSoundRadiusAtBase; // 3348 X
		float missileConeSoundHeight; // 3352 X
		float missileConeSoundOriginOffset; // 3356 X
		float missileConeSoundVolumescaleAtCore; // 3360 X
		float missileConeSoundVolumescaleAtEdge; // 3364 X
		float missileConeSoundVolumescaleCoreSize; // 3368 X
		float missileConeSoundPitchAtTop; // 3372 X
		float missileConeSoundPitchAtBottom; // 3376 X
		float missileConeSoundPitchTopSize; // 3380 X
		float missileConeSoundPitchBottomSize; // 3384 X
		float missileConeSoundCrossfadeTopSize; // 3388 X
		float missileConeSoundCrossfadeBottomSize; // 3392 X
		float aim_automelee_lerp; // 3396
		float aim_automelee_range; // 3400
		float aim_automelee_region_height; // 3404
		float aim_automelee_region_width; // 3408
		float player_meleeHeight; // 3412
		float player_meleeRange; // 3416
		float player_meleeWidth; // 3420
		float changedFireTime; // 3424
		int changedFireTimeNumBullets; // 3428
		weapFireTimeInterpolation_t fireTimeInterpolationType; // 3432
		int generateAmmo; // 3436 X
		int ammoPerShot; // 3440
		int explodeCount; // 3444 X
		int batteryDischargeRate; // 3448 X
		int extendedBattery; // 3452 X
		int iU_079; // 3456 // int numBulletTags (BG_ShowHideTagsBasedOnAltMode)
		int iU_080; // 3460 // int tagForAmmo (1400C77D0)
		scr_string_t stowTag; // 3464
		unsigned char rattleSoundType; // 3468 X
		bool adsShouldShowCrosshair; // 3469 (CG_DrawCrosshair)
		bool adsCrosshairShouldScale; // 3470 (CG_DrawCrosshair)
		bool turretADSEnabled; // 3471 X
		bool knifeAttachTagLeft; // 3472
		bool knifeAlwaysAttached; // 3473
		bool meleeOverrideValues; // 3474
		bool riotShieldEnableDamage; // 3475 X
		bool allowPrimaryWeaponPickup; // 3476 X
		bool sharedAmmo; // 3477
		bool lockonSupported; // 3478
		bool requireLockonToFire; // 3479
		bool isAirburstWeapon; // 3480 X
		bool bigExplosion; // 3481 X
		bool noAdsWhenMagEmpty; // 3482
		bool avoidDropCleanup; // 3483
		bool inheritsPerks; // 3484
		bool crosshairColorChange; // 3485
		bool rifleBullet; // 3486
		bool armorPiercing; // 3487
		bool boltAction; // 3488
		bool aimDownSight; // 3489
		bool canHoldBreath; // 3490
		bool meleeOnly; // 3491
		bool bU_085; // 3492 bool isMeleeAnimDelayed;? (0x14009FDC0)(1401F2BC0)
		bool bU_086; // 3493 X bool oldWeaponBot;?
		bool canVariableZoom; // 3494
		bool rechamberWhileAds; // 3495
		bool bulletExplosiveDamage; // 3496
		bool cookOffHold; // 3497
		bool useBattery; // 3498 X
		bool reticleSpin45; // 3499
		bool clipOnly; // 3500
		bool noAmmoPickup; // 3501
		bool disableSwitchToWhenEmpty; // 3502
		bool suppressAmmoReserveDisplay; // 3503 (14017E520)
		bool motionTracker; // 3504
		bool markableViewmodel; // 3505 X
		bool noDualWield; // 3506
		bool flipKillIcon; // 3507
		bool actionSlotShowAmmo; // 3508
		bool noPartialReload; // 3509
		bool segmentedReload; // 3510
		bool multipleReload; // 3511
		bool blocksProne; // 3512
		bool silenced; // 3513
		bool isRollingGrenade; // 3514
		bool projExplosionEffectForceNormalUp; // 3515
		bool projExplosionEffectInheritParentDirection; // 3516
		bool projImpactExplode; // 3517
		bool projTrajectoryEvents; // 3518 X
		bool projWhizByEnabled; // 3519 X
		bool stickToPlayers; // 3520 X
		bool stickToVehicles; // 3521 X
		bool stickToTurrets; // 3522 X
		bool thrownSideways; // 3523 X
		bool hasDetonatorEmptyThrow; // 3524
		bool hasDetonatorDoubleTap; // 3525
		bool disableFiring; // 3526
		bool timedDetonation; // 3527
		bool noCrumpleMissile; // 3528 (G_FireGrenade)(CheckCrumpleMissile)
		bool fuseLitAfterImpact; // 3529 (G_FireRocket)
		bool rotate; // 3530
		bool holdButtonToThrow; // 3531 X
		bool freezeMovementWhenFiring; // 3532
		bool thermalScope; // 3533
		bool thermalToggle; // 3534
		bool outlineEnemies; // 3535
		bool altModeSameWeapon; // 3536
		bool turretBarrelSpinEnabled; // 3537
		bool missileConeSoundEnabled; // 3538 X
		bool missileConeSoundPitchshiftEnabled; // 3539 X
		bool missileConeSoundCrossfadeEnabled; // 3540 X
		bool offhandHoldIsCancelable; // 3541
		bool doNotAllowAttachmentsToOverrideSpread; // 3542
		bool useFastReloadAnims; // 3543 (140202800)
		bool dualMagReloadSupported; // 3544
		bool reloadStopsAlt; // 3545 X
		bool useScopeDrift; // 3546 X
		bool alwaysShatterGlassOnImpact; // 3547
		bool oldWeapon; // 3548
		bool raiseToHold; // 3549 (BulletRicochet)(PM_Weapon_OffHandPrepare)
		bool notifyOnPlayerImpact; // 3550 (BG_WeaponFireRecoil)(Missile_Impact)
		bool decreasingKick; // 3551 X
		bool counterSilencer; // 3552 (BG_HasCounterSilencer)
		bool projSuppressedByEMP; // 3553 X
		bool projDisabledByEMP; // 3554 X
		bool autosimDisableVariableRate; // 3555
		bool projPlayTrailEffectForOwnerOnly; // 3556 (CG_Missile)
		bool projPlayBeaconEffectForOwnerOnly; // 3557 (CG_Missile)
		bool projKillTrailEffectOnDeath; // 3558 (CG_Missile)
		bool projKillBeaconEffectOnDeath; // 3559 (CG_Missile)
		bool reticleDetonateHide; // 3560 X
		bool cloaked; // 3561 (BG_IsWeaponCloaked)
		bool adsHideWeapon; // 3562 (0x1401fa7aa)
		bool adsHideHands; // 3563 (0x1401fa78a)
		bool bU_108; // 3564 X
		bool adsSceneBlur; // 3565 (BG_GetADSSceneBlur)
		bool usesSniperScope; // 3566 (BG_UsingSniperScope)
		bool hasTransientModels; // 3567 (140499130) (14049CE70) (14049B890) (14049B680)
		bool bU_112; // 3568 X
		bool bU_113; // 3569 X
		bool bU_114; // 3570 (BG_ShowHideTagsBasedOnAltMode)
		bool bU_115; // 3571 (BG_ShowHideTagsBasedOnAltMode)
		float adsDofPhysicalFstop; // 3572 (BG_ADSDOFPhysicalFStop)
		float adsDofPhysicalFocusDistance; // 3576 (BG_ADSDOFPhysicalFocusDistance)
		float autosimSpeedScale; // 3580 (BG_GetAutosimSpeedScalar)
		float reactiveMotionRadiusScale; // 3584 (BG_GetExplosionReactiveMotionParams)
		float reactiveMotionFrequencyScale;
		float reactiveMotionAmplitudeScale;
		float reactiveMotionFalloff;
		float reactiveMotionLifetime;
		float fU_3604[3]; // 3604
		// size: 3616
	}; assert_sizeof(WeaponDef, 0xE20);

	enum operationEnum : std::int32_t
	{
		OP_NOOP = 0x0,
		OP_RIGHTPAREN = 0x1,
		OP_MULTIPLY = 0x2,
		OP_DIVIDE = 0x3,
		OP_MODULUS = 0x4,
		OP_ADD = 0x5,
		OP_SUBTRACT = 0x6,
		OP_NOT = 0x7,
		OP_LESSTHAN = 0x8,
		OP_LESSTHANEQUALTO = 0x9,
		OP_GREATERTHAN = 0xA,
		OP_GREATERTHANEQUALTO = 0xB,
		OP_EQUALS = 0xC,
		OP_NOTEQUAL = 0xD,
		OP_AND = 0xE,
		OP_OR = 0xF,
		OP_LEFTPAREN = 0x10,
		OP_COMMA = 0x11,
		OP_BITWISEAND = 0x12,
		OP_BITWISEOR = 0x13,
		OP_BITWISENOT = 0x14,
		OP_BITSHIFTLEFT = 0x15,
		OP_BITSHIFTRIGHT = 0x16,
		OP_FIRSTFUNCTIONCALL = 0x17,
		OP_STATICDVARINT = 0x17,
		OP_STATICDVARBOOL = 0x18,
		OP_STATICDVARFLOAT = 0x19,
		OP_STATICDVARSTRING = 0x1A,
		OP_TOINT = 0x1B,
		OP_TOSTRING = 0x1C,
		OP_TOFLOAT = 0x1D,
		LAST_COMMONLY_CALLED_FUNCTION = 0x1D,
		OP_SIN = 0x1E,
		OP_COS = 0x1F,
		OP_MIN = 0x20,
		OP_MAX = 0x21,
		OP_MILLISECONDS = 0x22,
		OP_LOCALCLIENTUIMILLISECONDS = 0x23,
		OP_DVARINT = 0x24,
		OP_DVARBOOL = 0x25,
		OP_DVARFLOAT = 0x26,
		OP_DVARSTRING = 0x27,
		OP_UIACTIVE = 0x28,
		OP_FLASHBANGED = 0x29,
		OP_USINGVEHICLE = 0x2A,
		OP_MISSILECAM = 0x2B,
		OP_SCOPED = 0x2C,
		OP_SCOPEDTHERMAL = 0x2D,
		OP_SCOREBOARDVISIBLE = 0x2E,
		OP_INKILLCAM = 0x2F,
		OP_INKILLCAM_NPC = 0x30,
		OP_PLAYERFIELD = 0x31,
		OP_GET_PLAYER_PERK = 0x32,
		OP_SELECTINGLOCATION = 0x33,
		OP_SELECTINGDIRECTION = 0x34,
		OP_TEAMFIELD = 0x35,
		OP_OTHERTEAMFIELD = 0x36,
		OP_MARINESFIELD = 0x37,
		OP_OPFORFIELD = 0x38,
		OP_MENUISOPEN = 0x39,
		OP_WRITINGDATA = 0x3A,
		OP_INLOBBY = 0x3B,
		OP_INGAMELOBBY = 0x3C,
		OP_INPRIVATEPARTY = 0x3D,
		OP_PRIVATEPARTYHOST = 0x3E,
		OP_PRIVATEPARTYHOSTINLOBBY = 0x3F,
		OP_ALONEINPARTY = 0x40,
		OP_ADSJAVELIN = 0x41,
		OP_WEAPLOCKBLINK = 0x42,
		OP_WEAPATTACKTOP = 0x43,
		OP_WEAPATTACKDIRECT = 0x44,
		OP_WEAPLOCKING = 0x45,
		OP_WEAPLOCKED = 0x46,
		OP_WEAPLOCKTOOCLOSE = 0x47,
		OP_WEAPLOCKSCREENPOSX = 0x48,
		OP_WEAPLOCKSCREENPOSY = 0x49,
		OP_SECONDSASTIME = 0x4A,
		OP_TABLELOOKUP = 0x4B,
		OP_TABLELOOKUPBYROW = 0x4C,
		OP_TABLEGETROWNUM = 0x4D,
		OP_LOCALIZESTRING = 0x4E,
		OP_LOCALVARINT = 0x4F,
		OP_LOCALVARBOOL = 0x50,
		OP_LOCALVARFLOAT = 0x51,
		OP_LOCALVARSTRING = 0x52,
		OP_TIMELEFT = 0x53,
		OP_SECONDSASCOUNTDOWN = 0x54,
		OP_GAMEMSGWNDACTIVE = 0x55,
		OP_GAMETYPENAME = 0x56,
		OP_GAMETYPE = 0x57,
		OP_GAMETYPEDESCRIPTION = 0x58,
		OP_SCORE = 0x59,
		OP_FOLLOWING = 0x5A,
		OP_SPECTATINGFREE = 0x5B,
		OP_KEYBINDING = 0x5C,
		OP_ACTIONSLOTUSABLE = 0x5D,
		OP_HUDFADE = 0x5E,
		OP_MAXPLAYERS = 0x5F,
		OP_ACCEPTINGINVITE = 0x60,
		OP_ISINTERMISSION = 0x61,
		OP_GAMEHOST = 0x62,
		OP_PARTYHASMISSINGMAPPACK = 0x63,
		OP_PARTYMISSINGMAPPACKERROR = 0x64,
		OP_ANYNEWMAPPACKS = 0x65,
		OP_AMISELECTED = 0x66,
		OP_PARTYSTATUSSTRING = 0x67,
		OP_ATTACHED_CONTROLLER_COUNT = 0x68,
		OP_IS_SPLIT_SCREEN_ONLINE_POSSIBLE = 0x69,
		OP_SPLITSCREENPLAYERCOUNT = 0x6A,
		OP_GETPLAYERDATA = 0x6B,
		OP_GETPLAYERDATASPLITSCREEN = 0x6C,
		OP_GET_MATCHRULES_DATA = 0x6D,
		OP_GET_SAVED_MATCHRULES_METADATA = 0x6E,
		OP_LEVEL_FOR_EXPERIENCE_MP = 0x6F,
		OP_LEVEL_FOR_EXPERIENCE_SO = 0x70,
		OP_IS_ITEM_UNLOCKED = 0x71,
		OP_IS_ITEM_UNLOCKEDSPLITSCREEN = 0x72,
		OP_IS_CARDICON_UNLOCKED = 0x73,
		OP_IS_CARDTITLE_UNLOCKED = 0x74,
		OP_IS_CARDICON_NEW = 0x75,
		OP_IS_CARDTITLE_NEW = 0x76,
		OP_IS_CARDICON_UNLOCKED_SPLITSCREEN = 0x77,
		OP_IS_CARDTITLE_UNLOCKED_SPLITSCREEN = 0x78,
		OP_IS_CARDICON_NEW_SPLITSCREEN = 0x79,
		OP_IS_CARDTITLE_NEW_SPLITSCREEN = 0x7A,
		OP_IS_PROFILEITEM_UNLOCKED = 0x7B,
		OP_IS_PROFILEITEM_UNLOCKED_SPLITSCREEN = 0x7C,
		OP_DEBUG_PRINT = 0x7D,
		OP_GETPLAYERDATA_ANYBOOLTRUE = 0x7E,
		OP_GETPROFILE_ANYBOOLTRUE = 0x7F,
		OP_WEAPONNAME = 0x80,
		OP_ISRELOADING = 0x81,
		OP_SAVE_GAME_AVAILABLE = 0x82,
		OP_UNLOCKED_ITEM_COUNT = 0x83,
		OP_UNLOCKED_ITEM_COUNT_SPLITSCREEN = 0x84,
		OP_UNLOCKED_ITEM = 0x85,
		OP_UNLOCKED_ITEM_SPLITSCREEN = 0x86,
		OP_RADAR_IS_JAMMED = 0x87,
		OP_RADAR_JAM_INTENSITY = 0x88,
		OP_RADAR_IS_ENABLED = 0x89,
		OP_EMP_JAMMED = 0x8A,
		OP_PLAYERADS = 0x8B,
		OP_WEAPON_HEAT_ACTIVE = 0x8C,
		OP_WEAPON_HEAT_VALUE = 0x8D,
		OP_WEAPON_HEAT_OVERHEATED = 0x8E,
		OP_SPLASH_TEXT = 0x8F,
		OP_SPLASH_DESCRIPTION = 0x90,
		OP_SPLASH_MATERIAL = 0x91,
		OP_SPLASH_HAS_ICON = 0x92,
		OP_SPLASH_ROWNUM = 0x93,
		OP_GETFOCUSED_NAME = 0x94,
		OP_GETFOCUSED_X = 0x95,
		OP_GETFOCUSED_Y = 0x96,
		OP_GETFOCUSED_W = 0x97,
		OP_GETFOCUSED_H = 0x98,
		OP_GETITEMDEF_X = 0x99,
		OP_GETITEMDEF_Y = 0x9A,
		OP_GETITEMDEF_W = 0x9B,
		OP_GETITEMDEF_H = 0x9C,
		OP_PLAYLISTFIELD = 0x9D,
		OP_SCOREBOARD_EXTERNALMUTE_NOTICE = 0x9E,
		OP_GET_MAP_NAME = 0x9F,
		OP_GET_MAP_IMAGE = 0xA0,
		OP_GET_MAP_CUSTOM = 0xA1,
		OP_GET_MIGRATION_STATUS = 0xA2,
		OP_GET_PLAYERCARD_INFO = 0xA3,
		OP_IS_OFFLINE_PROFILE_SELECTED = 0xA4,
		OP_COOP_PLAYERFIELD = 0xA5,
		OP_IS_COOP = 0xA6,
		OP_GETPARTYSTATUS = 0xA7,
		OP_GETSEARCHPARAMS = 0xA8,
		OP_GETTIMEPLAYED = 0xA9,
		OP_IS_SELECTED_PLAYER_FRIEND = 0xAA,
		OP_GETCHARBYINDEX = 0xAB,
		OP_GETPLAYERPROFILEDATA = 0xAC,
		OP_GETPLAYERPROFILEDATASPLITSCREEN = 0xAD,
		OP_IS_PROFILE_SIGNED_IN = 0xAE,
		OP_GET_WAIT_POPUP_STATUS = 0xAF,
		OP_GETNATTYPE = 0xB0,
		OP_GETLOCALIZEDNATTYPE = 0xB1,
		OP_GET_ADJUSTED_SAFEAREA_HORIZONTAL = 0xB2,
		OP_GET_ADJUSTED_SAFEAREA_VERTICAL = 0xB3,
		OP_CONNECTION_INFO = 0xB4,
		OP_OFFLINE_PROFILE_CAN_SAVE = 0xB5,
		OP_USER_WITHOUT_OFFLINE_PROFILE = 0xB6,
		OP_ALL_SPLITSCREEN_PROFILES_CAN_SAVE = 0xB7,
		OP_ALL_SPLITSCREEN_PROFILES_ARE_SIGNED_IN = 0xB8,
		OP_DO_WE_HAVE_MAP_PACK = 0xB9,
		OP_MAY_INVITE_PLAYER_TO_PARTY = 0xBA,
		OP_GETPATCHNOTES = 0xBB,
		OP_GETGAMEINFOS = 0xBC,
		OP_COOP_READY = 0xBD,
		OP_VOTE_CAST = 0xBE,
		OP_VOTE_PASSED = 0xBF,
		OP_GET_MAP_VOTE_MAP_IMAGE = 0xC0,
		OP_GET_MAP_VOTE_MAP_NAME = 0xC1,
		OP_GET_MAP_VOTE_GAME_TYPE_NAME = 0xC2,
		OP_IS_FRIEND_INVITABLE = 0xC3,
		OP_IS_FRIEND_JOINABLE = 0xC4,
		OP_GET_SORTED_CHALLENGE_INDEX = 0xC5,
		OP_GET_SORTED_CHALLENGE_NAME = 0xC6,
		OP_GET_SORTED_CHALLENGE_COUNT = 0xC7,
		OP_GET_FILTER_CHALLENGE_COUNT = 0xC8,
		OP_GET_FILTER_CHALLENGE_LOCKED_COUNT = 0xC9,
		OP_GET_FILTER_CHALLENGE_COMPLETE_COUNT = 0xCA,
		OP_IS_SORTED_CHALLENGE_TIERED = 0xCB,
		OP_GET_CHALLENGE_FILTER_CACHE_COUNT = 0xCC,
		OP_GET_CHALLENGE_FILTER_CACHE_COMPLETE_COUNT = 0xCD,
		OP_IS_COOP_SEARCHING = 0xCE,
		OP_IS_COOP_PUBLIC = 0xCF,
		OP_GET_COOP_DISPLAYABLE_GROUP_NUM = 0xD0,
		OP_COOP_HAS_REQUIRED_ONLINE_FILES = 0xD1,
		OP_GET_TEXTWIDTH = 0xD2,
		OP_GET_TEXTHEIGHT = 0xD3,
		OP_DEVELOPER = 0xD4,
		OP_IS_USING_AIRBURST_WEAPON = 0xD5,
		OP_GET_AIRBURST_METERS = 0xD6,
		OP_GET_CROSSHAIR_TRACE_METERS = 0xD7,
		OP_GET_FACEBOOK_STATUS_TEXT = 0xD8,
		OP_IS_FACEBOOK_LOGGED_IN = 0xD9,
		OP_IS_FACEBOOK_CHECKING = 0xDA,
		OP_IS_FACEBOOK_ALLOWED = 0xDB,
		OP_GETPRIVATELOBBYSTATUS = 0xDC,
		OP_INCLUDEDINMAPROTATION = 0xDD,
		OP_SELECT = 0xDE,
		OP_IS_DEMO_PLAYING = 0xDF,
		OP_GET_USER_GROUP_TEXT = 0xE0,
		OP_GET_USER_GROUP_COMMON_INTEREST_TOTAL = 0xE1,
		OP_IS_DEMO_FOLLOW_CAMERA = 0xE2,
		OP_IS_DEMO_FREE_CAMERA = 0xE3,
		OP_IS_DEMO_CAPTURING_SCREENSHOT = 0xE4,
		OP_PARTY_HOST_WAITING_ON_MEMBERS = 0xE5,
		OP_POPUP_PARTY_MEMBER_AWAY = 0xE6,
		OP_SELECTED_PARTY_MEMBER_AWAY = 0xE7,
		OP_GAMETIME = 0xE8,
		OP_GAMEENDTIME = 0xE9,
		OP_HAS_FOCUS = 0xEA,
		OP_MENU_HAS_FOCUS = 0xEB,
		OP_GET_DEMO_SEGMENT_COUNT = 0xEC,
		OP_GET_DEMO_SEGMENT_INFORMATION = 0xED,
		OP_IS_CLIP_MODIFIED = 0xEE,
		OP_IS_USING_RECIPE = 0xEF,
		OP_IS_GUEST = 0xF0,
		OP_GET_FACEBOOK_HELP_TEXT = 0xF1,
		OP_IS_ELITE_CLAN_ALLOWED = 0xF2,
		OP_IS_ENTITLEMENTS_ALLOWED = 0xF3,
		OP_IS_USERGROUPS_ALLOWED = 0xF4,
		OP_IS_WAITING_FOR_ONLINE_SERVICES = 0xF5,
		OP_GET_TEXTWIDTHMODCASE = 0xF6,
		OP_GET_SAVE_SCREEN_TITLE = 0xF7,
		OP_GET_SAVE_SCREEN_DESCRIPTION = 0xF8,
		OP_GET_ONLINEVAULT_SELECTEDITEM_DATA = 0xF9,
		OP_ONLINEVAULT_IS_RESTRICTED = 0xFA,
		OP_IS_CONTENTSERVER_TASK_IN_PROGRESS = 0xFB,
		OP_IS_CONTENTSERVER_GET_TASK_PROGRESS = 0xFC,
		OP_GET_RECENTGAMES_SELECTEDITEM_DATA = 0xFD,
		OP_GAMETYPENAME_ABBREVIATED = 0xFE,
		OP_GET_MAP_VOTE_GAME_TYPE_NAME_ABBREVIATED = 0xFF,
		OP_IS_USER_SIGNED_IN_TO_LIVE = 0x100,
		OP_USER_CAN_PLAY_ONLINE = 0x101,
		OP_GET_FEEDER_DATA = 0x102,
		OP_PARTY_CLIENTS_UP_TO_DATE = 0x103,
		OP_TRUNCATETEXTWITHELLIPSIS = 0x104,
		OP_UI_STARTED = 0x105,
		OP_CAN_RENDER_CLIP = 0x106,
		OP_GET_PREVIEW_MAP_CUSTOM = 0x107,
		OP_GET_DLC_MAPS_AVAILABLE_COUNT = 0x108,
		OP_IS_USER_SIGNED_IN = 0x109,
		OP_USINGINTERMISSIONTIMER = 0x10A,
		OP_ISUSINGCUSTOMMAPROTATION = 0x10B,
		OP_MENU_IS_TOPMOST = 0x10C,
		OP_FACEBOOK_IS_PLATFORM_FRIEND = 0x10D,
		OP_ELITE_CLAN_IS_PLATFORM_FRIEND = 0x10E,
		OP_ELITE_CLAN_IS_ME = 0x10F,
		OP_ELITE_CLAN_IS_LEADER = 0x110,
		OP_IS_USER_SIGNED_IN_FOR_VAULT = 0x111,
		OP_GET_USING_MATCHRULES_DATA = 0x112,
		OP_CAN_USER_ACCESS_ONLINEVAULT = 0x113,
		OP_FRIEND_GET_GAMERTAG = 0x114,
		OP_RECENTPLAYER_GET_GAMERTAG = 0x115,
		OP_LIVEPARTY_GET_GAMERTAG = 0x116,
		OP_FACEBOOK_GET_GAMERTAG = 0x117,
		OP_ELITECLAN_GET_GAMERTAG = 0x118,
		OP_LIVEPARTY_IS_ME = 0x119,
		OP_LIVEPARTY_IS_LOCAL = 0x11A,
		OP_DOUBLECLICK_WAS_RIGHT_CLICK = 0x11B,
		OP_IS_DEMO_CLIP_RECORDING = 0x11C,
		OP_GET_INDEX_FROM_STRING = 0x11D,
		OP_GET_STRING_WIHTOUT_INDEX = 0x11E,
		OP_ELITECLAN_GET_NAME = 0x11F,
		OP_ELITECLAN_GET_HELP = 0x120,
		OP_ELITECLAN_GET_MOTD = 0x121,
		OP_ELITECLAN_IS_MEMBER = 0x122,
		OP_ELITECLAN_IS_EMBLEM_OK = 0x123,
		OP_FACEBOOKFRIENDS_SHOW_NEXT = 0x124,
		OP_FACEBOOKFRIENDS_SHOW_PREV = 0x125,
		OP_GET_ONLINEVAULT_FRIEND_GAMERTAG = 0x126,
		OP_GET_OBJECTIVE_LIST_HEIGHT = 0x127,
		OP_IS_CLIENT_DEMO_ENABLED = 0x128,
		OP_IS_USER_SIGNED_IN_TO_DEMONWARE = 0x129,
		OP_IS_CUSTOM_CLASS_RESTRICTED = 0x12A,
		OP_IS_WEAPON_RESTRICTED = 0x12B,
		OP_ANY_SPLITSCREEN_PROFILES_ARE_SIGNED_IN = 0x12C,
		OP_IS_GUEST_SPLITSCREEN = 0x12D,
		OP_IS_ITEM_UNLOCKED_BY_CLIENT = 0x12E,
		OP_IS_ANY_USER_SIGNED_IN_TO_LIVE = 0x12F,
		OP_SPLITSCREENACTIVEGAMEPADCOUNT = 0x130,
		OP_SHOW_FRIEND_PLAYERCARD = 0x131,
		OP_GET_FRIEND_PLAYERCARD_PRESENCE = 0x132,
		OP_SHOW_RECENT_PLAYERS_GROUP_ICON = 0x133,
		OP_GET_WRAPPED_TEXT_HEIGHT = 0x134,
		OP_CAN_SAVE = 0x135,
		OP_GET_GAME_INVITES_COUNT = 0x136,
		OP_IS_SPLITSCREEN_GAMER_LIVE_ENABLED = 0x137,
		OP_SO_COOP_SHOW_COMMON_GROUP_ICON = 0x138,
		OP_STRIP_COLORS_FROM_STRING = 0x139,
		OP_CAN_USER_ACCESS_THEATRE = 0x13A,
		OP_IS_CHALLENGE_PERIODIC = 0x13B,
		OP_GET_CHALLENGE_DATA = 0x13C,
		OP_IS_ELITE_APP_PRESENT = 0x13D,
		OP_ELITE_CLAN_SELECTED_IS_ME = 0x13E,
		OP_ENOUGH_STORAGE_SPACE_FOR_CLIENT_DEMO = 0x13F,
		OP_IS_USER_SIGNED_IN_FOR_COMMERCE = 0x140,
		OP_GET_FACEBOOK_MENU_TEXT = 0x141,
		OP_GET_FACEBOOK_IS_POSTING = 0x142,
		OP_MEET_PLAYER_IS_PLATFORM_FRIEND = 0x143,
		OP_IS_SELECTED_PLAYER_GUEST = 0x144,
		OP_GET_SPLITSCREEN_CONTROLLER_CLIENT_NUM = 0x145,
		OP_IS_CLIENT_DEMO_ENABLED_SPLITSCREEN = 0x146,
		OP_ITEM_CAN_TAKE_FOCUS = 0x147,
		OP_GET_TIME_SINCE_LAST_DOUBLECLICK = 0x148,
		OP_IS_SERVER_LIST_REFRESHING = 0x149,
		OP_IS_RECIPE_NAME_VALID = 0x14A,
		OP_RECIPE_EXISTS = 0x14B,
		OP_GET_FACEBOOK_OPTIONS_HELP_TEXT = 0x14C,
		OP_DO_WE_HAVE_ALL_MAP_PACKS = 0x14D,
		OP_IS_THERE_NEW_ELITE_ITEMS = 0x14E,
		OP_IS_PAYING_SUBSCRIBER = 0x14F,
		OP_LOCALUSER_HASMISSINGMAPPACK = 0x150,
		OP_LOCALUSER_MISSINGMAPPACKERROR = 0x151,
		OP_GET_FIRST_SPECOPS_DLC_MAP = 0x152,
		OP_LOCALUSER_MISSINGMAPNAME = 0x153,
		OP_SHOW_STORE_NEW = 0x154,
		OP_USINGBOTS = 0x155,
		OP_BOTSALLOWED = 0x156,
		OP_ISCOLORBLIND = 0x157,
		OP_BOTSCONNECTTYPE = 0x158,
		OP_BOTSDIFFICULTY = 0x159,
		OP_SPECTATINGTHIRD = 0x15A,
		OP_GETPLAYERNAME = 0x15B,
		OP_SQUAD_SHOW_REPORT = 0x15C,
		OP_GETRANKEDPLAYERDATASPLITSCREEN = 0x15D,
		OP_GETPRIVATEPLAYERDATASPLITSCREEN = 0x15E,
		OP_GETCOOPPLAYERDATASPLITSCREEN = 0x15F,
		OP_GETCOMMONPLAYERDATASPLITSCREEN = 0x160,
		OP_GETOMNVAR = 0x161,
		NUM_OPERATORS = 0x162,
	};

	struct ExpressionString
	{
		const char* string;
	};

	union operandInternalDataUnion
	{
		int intVal;
		float floatVal;
		ExpressionString stringVal;
		Statement_s* function;
	};

	enum expDataType : std::int32_t
	{
		VAL_INT = 0x0,
		VAL_FLOAT = 0x1,
		VAL_STRING = 0x2,
		NUM_INTERNAL_DATATYPES = 0x3,
		VAL_FUNCTION = 0x3,
		NUM_DATATYPES = 0x4,
	};

#pragma pack(push, 1)
	struct Operand
	{
		operandInternalDataUnion internals;
		expDataType dataType;
	}; assert_sizeof(Operand, 12);
#pragma pack(pop)

	union entryInternalData
	{
		operationEnum op;
		Operand operand;
	};

	struct expressionEntry
	{
		entryInternalData data;
		int type;
	};

	struct UIFunctionList
	{
		int totalFunctions;
		Statement_s** functions;
	};

	struct StaticDvar
	{
		void* dvar; //const dvar_t* dvar;
		char* dvarName;
	};

	struct StaticDvarList
	{
		int numStaticDvars;
		StaticDvar** staticDvars;
	};

	struct StringList
	{
		int totalStrings;
		const char** strings;
	};

	struct ExpressionSupportingData
	{
		UIFunctionList uifunctions;
		StaticDvarList staticDvarList;
		StringList uiStrings;
	};

	struct ExpressionPersistentState
	{
		int flags;
		int playerDataKey[4];
		int lastExecuteTime[4];
		Operand lastResult[4];
	};

	struct __declspec(align(8)) Statement_s
	{
		int numEntries;
		expressionEntry* entries;
		ExpressionSupportingData* supportingData;
		ExpressionPersistentState persistentState;
	};

	struct ConditionalScript
	{
		MenuEventHandlerSet* eventHandlerSet;
		Statement_s* eventExpression;
	};

	struct SetLocalVarData
	{
		const char* localVarName;
		Statement_s* expression;
	};

	union EventData
	{
		const char* unconditionalScript;
		ConditionalScript* conditionalScript;
		MenuEventHandlerSet* elseScript;
		SetLocalVarData* setLocalVarData;
	};

	enum EventType : std::uint8_t
	{
		EVENT_UNCONDITIONAL = 0x0,
		EVENT_IF = 0x1,
		EVENT_ELSE = 0x2,
		EVENT_SET_LOCAL_VAR_BOOL = 0x3,
		EVENT_SET_LOCAL_VAR_INT = 0x4,
		EVENT_SET_LOCAL_VAR_FLOAT = 0x5,
		EVENT_SET_LOCAL_VAR_STRING = 0x6,
		EVENT_COUNT = 0x7,
	};

	struct __declspec(align(8)) MenuEventHandler
	{
		EventData eventData;
		EventType eventType;
	};

	struct MenuEventHandlerSet
	{
		int eventHandlerCount;
		MenuEventHandler** eventHandlers;
	};

	struct ItemKeyHandler
	{
		int key;
		MenuEventHandlerSet* action;
		ItemKeyHandler* next;
	};

	struct menuTransition
	{
		int transitionType;
		int startTime;
		float startVal;
		float endVal;
		float time;
		int endTriggerType;
	};

	struct __declspec(align(8)) menuData_t
	{
		int fullScreen;
		int fadeCycle;
		float fadeClamp;
		float fadeAmount;
		float fadeInAmount;
		float blurRadius;
		MenuEventHandlerSet* onOpen;
		MenuEventHandlerSet* onCloseRequest;
		MenuEventHandlerSet* onClose;
		MenuEventHandlerSet* onESC;
		MenuEventHandlerSet* onFocusDueToClose;
		ItemKeyHandler* onKey;
		Statement_s* visibleExp;
		const char* allowedBinding;
		const char* soundName;
		float focusColor[4];
		Statement_s* rectXExp;
		Statement_s* rectYExp;
		Statement_s* rectWExp;
		Statement_s* rectHExp;
		Statement_s* openSoundExp;
		Statement_s* closeSoundExp;
		Statement_s* soundLoopExp;
		int cursorItem[1];
		menuTransition scaleTransition[1];
		menuTransition alphaTransition[1];
		menuTransition xTransition[1];
		menuTransition yTransition[1];
		ExpressionSupportingData* expressionData;
		unsigned char priority;
	};

	struct __declspec(align(4)) rectDef_s
	{
		float x;
		float y;
		float w;
		float h;
		unsigned __int8 horzAlign;
		unsigned __int8 vertAlign;
	};

	struct windowDef_t
	{
		const char* name;
		rectDef_s rect;
		rectDef_s rectClient;
		const char* group;
		int style;
		int border;
		int ownerDraw;
		int ownerDrawFlags;
		float borderSize;
		int staticFlags;
		int dynamicFlags[1];
		int nextTime;
		float foreColor[4];
		float backColor[4];
		float borderColor[4];
		float outlineColor[4];
		float disableColor[4];
		Material* background;
	};

	struct columnInfo_s
	{
		int xpos;
		int ypos;
		int width;
		int height;
		int maxChars;
		int alignment;
	};

	struct listBoxDef_s
	{
		int startPos[1];
		int endPos[1];
		int drawPadding;
		float elementWidth;
		float elementHeight;
		int elementStyle;
		int numColumns;
		columnInfo_s columnInfo[16];
		MenuEventHandlerSet* onDoubleClick;
		int notselectable;
		int noScrollBars;
		int usePaging;
		float selectBorder[4];
		Material* selectIcon;
		Statement_s* elementHeightExp;
	};

	struct editFieldDef_s
	{
		float minVal;
		float maxVal;
		float stepVal;
		float range;
		int maxChars;
		int maxCharsGotoNext;
		int maxPaintChars;
		int paintOffset;
	};

	struct multiDef_s
	{
		const char* dvarList[32];
		const char* dvarStr[32];
		float dvarValue[32];
		int count;
		int strDef;
	};

	struct textScrollDef_s
	{
		int startTime;
	};

	struct newsTickerDef_s
	{
		int feedId;
		int speed;
		int spacing;
	};

	union itemDefData_t
	{
		listBoxDef_s* listBox;
		editFieldDef_s* editField;
		multiDef_s* multi;
		const char* enumDvarName;
		newsTickerDef_s* ticker;
		textScrollDef_s* scroll;
		void* data;
	};

	enum ItemFloatExpressionTarget
	{
		ITEM_FLOATEXP_TGT_RECT_X = 0x0,
		ITEM_FLOATEXP_TGT_RECT_Y = 0x1,
		ITEM_FLOATEXP_TGT_RECT_W = 0x2,
		ITEM_FLOATEXP_TGT_RECT_H = 0x3,
		ITEM_FLOATEXP_TGT_FORECOLOR_R = 0x4,
		ITEM_FLOATEXP_TGT_FORECOLOR_G = 0x5,
		ITEM_FLOATEXP_TGT_FORECOLOR_B = 0x6,
		ITEM_FLOATEXP_TGT_FORECOLOR_RGB = 0x7,
		ITEM_FLOATEXP_TGT_FORECOLOR_A = 0x8,
		ITEM_FLOATEXP_TGT_GLOWCOLOR_R = 0x9,
		ITEM_FLOATEXP_TGT_GLOWCOLOR_G = 0xA,
		ITEM_FLOATEXP_TGT_GLOWCOLOR_B = 0xB,
		ITEM_FLOATEXP_TGT_GLOWCOLOR_RGB = 0xC,
		ITEM_FLOATEXP_TGT_GLOWCOLOR_A = 0xD,
		ITEM_FLOATEXP_TGT_BACKCOLOR_R = 0xE,
		ITEM_FLOATEXP_TGT_BACKCOLOR_G = 0xF,
		ITEM_FLOATEXP_TGT_BACKCOLOR_B = 0x10,
		ITEM_FLOATEXP_TGT_BACKCOLOR_RGB = 0x11,
		ITEM_FLOATEXP_TGT_BACKCOLOR_A = 0x12,
		ITEM_FLOATEXP_TGT__COUNT = 0x13,
	};

	struct ItemFloatExpression
	{
		ItemFloatExpressionTarget target;
		Statement_s* expression;
	};

	struct itemDef_t
	{
		windowDef_t window;
		rectDef_s textRect[1];
		int type;
		int dataType;
		int alignment;
		int fontEnum;
		int textAlignMode;
		float textalignx;
		float textaligny;
		float textscale;
		int textStyle;
		int gameMsgWindowIndex;
		int gameMsgWindowMode;
		const char* text;
		int itemFlags;
		menuDef_t* parent;
		MenuEventHandlerSet* mouseEnterText;
		MenuEventHandlerSet* mouseExitText;
		MenuEventHandlerSet* mouseEnter;
		MenuEventHandlerSet* mouseExit;
		MenuEventHandlerSet* action;
		MenuEventHandlerSet* accept;
		MenuEventHandlerSet* onFocus;
		MenuEventHandlerSet* hasFocus;
		MenuEventHandlerSet* leaveFocus;
		const char* dvar;
		const char* dvarTest;
		ItemKeyHandler* onKey;
		const char* enableDvar;
		const char* localVar;
		int dvarFlags;
		snd_alias_list_t* focusSound;
		float special;
		int cursorPos[1];
		itemDefData_t typeData;
		int floatExpressionCount;
		ItemFloatExpression* floatExpressions;
		Statement_s* visibleExp;
		Statement_s* disabledExp;
		Statement_s* textExp;
		Statement_s* materialExp;
		float glowColor[4];
		bool decayActive;
		int fxBirthTime;
		int fxLetterTime;
		int fxDecayStartTime;
		int fxDecayDuration;
		int lastSoundPlayedTime;
		Statement_s* textAlignYExp;
	};

	struct menuDef_t
	{
		menuData_t* data;
		windowDef_t window;
		int itemCount;
		itemDef_t** items;
	};

	struct MenuList
	{
		const char* name;
		int menuCount;
		menuDef_t** menus;
	};

	struct cplane_s
	{
		float normal[3];
		float dist;
		unsigned char type;
		//unsigned char pad[3];
	}; assert_sizeof(cplane_s, 20);

	enum CSurfaceFlags : std::uint32_t
	{
		SURF_FLAG_DEFAULT = 0x00000000,
		SURF_FLAG_BARK = 0x00100000,
		SURF_FLAG_BRICK = 0x00200000,
		SURF_FLAG_CARPET = 0x00300000,
		SURF_FLAG_CLOTH = 0x00400000,
		SURF_FLAG_CONCRETE = 0x00500000,
		SURF_FLAG_DIRT = 0x00600000,
		SURF_FLAG_FLESH = 0x00700000,
		SURF_FLAG_FOLIAGE_DEBRIS = 0x00800000,
		SURF_FLAG_GLASS = 0x00900000,
		SURF_FLAG_GRASS = 0x00A00000,
		SURF_FLAG_GRAVEL = 0x00B00000,
		SURF_FLAG_ICE = 0x00C00000,
		SURF_FLAG_METAL_SOLID = 0x00D00000,
		SURF_FLAG_METAL_GRATE = 0x00E00000,
		SURF_FLAG_MUD = 0x00F00000,
		SURF_FLAG_PAPER = 0x01000000,
		SURF_FLAG_PLASTER = 0x01100000,
		SURF_FLAG_ROCK = 0x01200000,
		SURF_FLAG_SAND = 0x01300000,
		SURF_FLAG_SNOW = 0x01400000,
		SURF_FLAG_WATER_WAIST = 0x01500000,
		SURF_FLAG_WOOD_SOLID = 0x01600000,
		SURF_FLAG_ASPHALT = 0x01700000,
		SURF_FLAG_CERAMIC = 0x01800000,
		SURF_FLAG_PLASTIC_SOLID = 0x01900000,
		SURF_FLAG_RUBBER = 0x01A00000,
		SURF_FLAG_FRUIT = 0x01B00000,
		SURF_FLAG_PAINTEDMETAL = 0x01C00000,
		SURF_FLAG_RIOTSHIELD = 0x01D00000,
		SURF_FLAG_SLUSH = 0x01E00000,
		SURF_FLAG_ASPHALT_WET = 0x01F00000,
		SURF_FLAG_ASPHALT_DEBRIS = 0x02000000,
		SURF_FLAG_CONCRETE_WET = 0x02100000,
		SURF_FLAG_CONCRETE_DEBRIS = 0x02200000,
		SURF_FLAG_FOLIAGE_VEGETATION = 0x02300000,
		SURF_FLAG_FOLIAGE_LEAVES = 0x02400000,
		SURF_FLAG_GRASS_TALL = 0x02500000,
		SURF_FLAG_METAL_HOLLOW = 0x02600000,
		SURF_FLAG_METAL_VEHICLE = 0x02700000,
		SURF_FLAG_METAL_THIN = 0x02800000,
		SURF_FLAG_METAL_WET = 0x02900000,
		SURF_FLAG_METAL_DEBRIS = 0x02A00000,
		SURF_FLAG_PLASTIC_HOLLOW = 0x02B00000,
		SURF_FLAG_PLASTIC_TARP = 0x02C00000,
		SURF_FLAG_ROCK_WET = 0x02D00000,
		SURF_FLAG_ROCK_DEBRIS = 0x02E00000,
		SURF_FLAG_WATER_ANKLE = 0x02F00000,
		SURF_FLAG_WATER_KNEE = 0x03000000,
		SURF_FLAG_WATER_HOLLOW = 0x03100000,
		SURF_FLAG_WOOD_HOLLOW = 0x03200000,
		SURF_FLAG_WOOD_DEBRIS = 0x03300000,
		SURF_FLAG_CUSHION = 0x03400000,
		SURF_FLAG_CLIPMISSILE = 0x00000000,
		SURF_FLAG_AI_NOSIGHT = 0x00000000,
		SURF_FLAG_CLIPSHOT = 0x00000000,
		SURF_FLAG_PLAYERCLIP = 0x00000000,
		SURF_FLAG_MONSTERCLIP = 0x00000000,
		SURF_FLAG_AICLIPALLOWDEATH = 0x00000000,
		SURF_FLAG_VEHICLECLIP = 0x00000000,
		SURF_FLAG_ITEMCLIP = 0x00000000,
		SURF_FLAG_NODROP = 0x00000000,
		SURF_FLAG_NONSOLID = 0x00004000,
		SURF_FLAG_NOGRAPPLE = 0x00008000,
		SURF_FLAG_DETAIL = 0x00000000,
		SURF_FLAG_STRUCTURAL = 0x00000000,
		SURF_FLAG_PORTAL = 0x80000000,
		SURF_FLAG_CANSHOOTCLIP = 0x00000000,
		SURF_FLAG_ORIGIN = 0x00000000,
		SURF_FLAG_SKY = 0x00000004,
		SURF_FLAG_NOCASTSHADOW = 0x00040000,
		SURF_FLAG_PHYSICSGEOM = 0x00000000,
		SURF_FLAG_LIGHTPORTAL = 0x00000000,
		SURF_FLAG_OUTDOORBOUNDS = 0x00000000,
		SURF_FLAG_SLICK = 0x00000002,
		SURF_FLAG_NOIMPACT = 0x00000010,
		SURF_FLAG_NOMARKS = 0x00000020,
		SURF_FLAG_NOPENETRATE = 0x00000100,
		SURF_FLAG_LADDER = 0x00000008,
		SURF_FLAG_NODAMAGE = 0x00000001,
		SURF_FLAG_MANTLEON = 0x04000000,
		SURF_FLAG_MANTLEOVER = 0x08000000,
		SURF_FLAG_STAIRS = 0x00000200,
		SURF_FLAG_SOFT = 0x00001000,
		SURF_FLAG_NOSTEPS = 0x00002000,
		SURF_FLAG_NODRAW = 0x00000080,
		SURF_FLAG_NOLIGHTMAP = 0x00000400,
		SURF_FLAG_NODLIGHT = 0x00020000,
		SURF_FLAG_TRANSSORT = 0x00080000,
	};

	struct ClipMaterial
	{
		const char* name;
		int surfaceFlags;
		int contents;
	}; assert_sizeof(ClipMaterial, 16);

	struct cLeafBrushNodeLeaf_t
	{
		unsigned short* brushes;
	};

	struct cLeafBrushNodeChildren_t
	{
		float dist;
		float range;
		unsigned short childOffset[2];
	};

	union cLeafBrushNodeData_t
	{
		cLeafBrushNodeLeaf_t leaf;
		cLeafBrushNodeChildren_t children;
	};

	struct cLeafBrushNode_s
	{
		unsigned char axis;
		short leafBrushCount;
		int contents;
		cLeafBrushNodeData_t data;
	}; assert_sizeof(cLeafBrushNode_s, 24);

	typedef unsigned short LeafBrush;

	struct BrushesCollisionTree
	{
		unsigned int leafbrushNodesCount;
		cLeafBrushNode_s* leafbrushNodes;
		unsigned int numLeafBrushes;
		LeafBrush* leafbrushes;
	}; assert_sizeof(BrushesCollisionTree, 32);

	union CollisionAabbTreeIndex
	{
		int firstChildIndex;
		int partitionIndex;
	};

	struct CollisionAabbTree
	{
		float midPoint[3];
		unsigned short materialIndex;
		unsigned short childCount;
		float halfSize[3];
		CollisionAabbTreeIndex u;
	}; assert_sizeof(CollisionAabbTree, 32);

	struct PatchesCollisionTree
	{
		int aabbTreeCount;
		CollisionAabbTree* aabbTrees;
	}; assert_sizeof(PatchesCollisionTree, 16);

	struct SModelAabbNode
	{
		Bounds bounds;
		unsigned short firstChild;
		unsigned short childCount;
	}; assert_sizeof(SModelAabbNode, 28);

	struct SModelsCollisionTree
	{
		unsigned short numStaticModels;
		unsigned short smodelNodeCount;
		SModelAabbNode* smodelNodes;
	}; assert_sizeof(SModelsCollisionTree, 16);

	struct cbrushside_t
	{
		unsigned int planeIndex;
		unsigned short materialNum;
		unsigned char firstAdjacentSideOffset;
		unsigned char edgeCount;
	}; assert_sizeof(cbrushside_t, 8);

	typedef unsigned char cbrushedge_t;

	struct cbrush_t
	{
		unsigned short numsides;
		unsigned short glassPieceIndex;
		cbrushside_t* sides;
		cbrushedge_t* baseAdjacentSide;
		short axialMaterialNum[2][3];
		unsigned char firstAdjacentSideOffsets[2][3];
		unsigned char edgeCount[2][3];
	}; assert_sizeof(cbrush_t, 48);
	assert_offsetof(cbrush_t, sides, 8);

	struct BrushesCollisionData
	{
		unsigned int numBrushSides;
		cbrushside_t* brushSides;
		unsigned int numBrushEdges;
		cbrushedge_t* brushEdges;
		unsigned int numBrushes;
		cbrush_t* brushes;
		Bounds* brushBounds;
		int* brushContents;
	}; assert_sizeof(BrushesCollisionData, 64);

	struct CollisionBorder
	{
		float distEq[3];
		float zBase;
		float zSlope;
		float start;
		float length;
	}; assert_sizeof(CollisionBorder, 28);

	struct CollisionPartition
	{
		unsigned char triCount;
		unsigned char borderCount;
		unsigned char firstVertSegment;
		int firstTri;
		CollisionBorder* borders;
	}; assert_sizeof(CollisionPartition, 16);

	struct PatchesCollisionData
	{
		unsigned int vertCount;
		vec3_t* verts;
		int triCount;
		unsigned short* triIndices;
		unsigned char* triEdgeIsWalkable;
		int borderCount;
		CollisionBorder* borders;
		int partitionCount;
		CollisionPartition* partitions;
	}; assert_sizeof(PatchesCollisionData, 72);

	struct cStaticModel_s
	{
		XModel* xmodel;
		float origin[3];
		float invScaledAxis[3][3];
		Bounds absBounds;
		int lightingHandle;
	}; assert_sizeof(cStaticModel_s, 88);

	struct SModelsCollisionData
	{
		unsigned int numStaticModels;
		cStaticModel_s* staticModelList;
	}; assert_sizeof(SModelsCollisionData, 16);

	struct ClipInfo
	{
		int planeCount;
		cplane_s* planes;
		unsigned int numMaterials;
		ClipMaterial* materials;
		BrushesCollisionTree bCollisionTree;
		PatchesCollisionTree pCollisionTree;
		SModelsCollisionTree sCollisionTree;
		BrushesCollisionData bCollisionData;
		PatchesCollisionData pCollisionData;
		SModelsCollisionData sCollisionData;
	}; assert_sizeof(ClipInfo, 0xF8);
	assert_offsetof(ClipInfo, bCollisionTree, 32);
	assert_offsetof(ClipInfo, pCollisionTree, 64);
	assert_offsetof(ClipInfo, sCollisionTree, 80);
	assert_offsetof(ClipInfo, bCollisionData, 96);
	assert_offsetof(ClipInfo, pCollisionData, 160);
	assert_offsetof(ClipInfo, sCollisionData, 232);
	assert_offsetof(ClipInfo, bCollisionData.brushes, 136);

	struct cNode_t
	{
		cplane_s* plane;
		short children[2];
	}; assert_sizeof(cNode_t, 16);

	struct cLeaf_t
	{
		unsigned int firstCollAabbIndex;
		unsigned int collAabbCount;
		int brushContents;
		int terrainContents;
		Bounds bounds;
		int leafBrushNode;
	}; assert_sizeof(cLeaf_t, 44);

	struct cmodel_t
	{
		Bounds bounds;
		float radius;
		ClipInfo* info;
		cLeaf_t leaf;
	}; assert_sizeof(cmodel_t, 88);

	struct Stage
	{
		const char* name;
		float origin[3];
		unsigned short triggerIndex;
		unsigned char sunPrimaryLightIndex;
		unsigned int entityUID;
	}; assert_sizeof(Stage, 32);

	enum DynEntityType : std::int32_t
	{
		DYNENT_TYPE_INVALID = 0x0,
		DYNENT_TYPE_CLUTTER = 0x1,
		DYNENT_TYPE_DESTRUCT = 0x2,
		DYNENT_TYPE_HINGE = 0x3,
		DYNENT_TYPE_SCRIPTABLEINST = 0x4,
		DYNENT_TYPE_SCRIPTABLEPHYSICS = 0x5,
		DYNENT_TYPE_LINKED = 0x6,
		DYNENT_TYPE_LINKED_NOSHADOW = 0x7,
		DYNENT_TYPE_COUNT = 0x8,
	};

	struct GfxPlacement
	{
		float quat[4];
		float origin[3];
	};

	struct DynEntityHingeDef
	{
		float axisOrigin[3];
		float axisDir[3];
		bool isLimited;
		float angleMin;
		float angleMax;
		float momentOfInertia;
		float friction;
	}; assert_sizeof(DynEntityHingeDef, 44);

	struct DynEntityLinkToDef
	{
		int anchorIndex;
		float originOffset[3];
		float angleOffset[3];
	}; assert_sizeof(DynEntityLinkToDef, 28);

	struct DynEntityDef
	{
		DynEntityType type;
		GfxPlacement pose;
		XModel* baseModel;
		unsigned short brushModel;
		unsigned short physicsBrushModel;
		unsigned short scriptableIndex;
		unsigned short health;
		FxEffectDef* destroyFx;
		snd_alias_list_t* sound;
		PhysPreset* physPreset;
		DynEntityHingeDef* hinge;
		DynEntityLinkToDef* linkTo;
		PhysMass mass;
		int contents;
		float unk[2]; //char __pad0[8];
	}; assert_sizeof(DynEntityDef, 136);

	struct DynEntityPose
	{
		GfxPlacement pose;
		float radius;
		char __pad0[4];
	}; assert_sizeof(DynEntityPose, 36);

	struct Hinge
	{
		float angle;
		float quat[4];
		float angularVel;
		float torqueAccum;
		bool active;
		float autoDisableTimeLeft;
		DynEntityHingeDef* def;
		PhysPreset* physPreset;
		float centerOfMassRelToAxisOriginAtAngleZero[3];
	};

	struct DynEntityClient
	{
		__int64 physObjId;
		unsigned short flags;
		unsigned short lightingHandle;
		unsigned short health;
		Hinge* hinge;
		XModel* activeModel;
		int contents;
	}; assert_sizeof(DynEntityClient, 40);

	struct DynEntityColl
	{
		unsigned short sector;
		unsigned short nextEntInSector;
		float linkMins[2];
		float linkMaxs[2];
	}; assert_sizeof(DynEntityColl, 20);

	enum ScriptableEventType : std::int32_t
	{
		SCRIPTABLE_EVENT_MODEL = 0x0,
		SCRIPTABLE_EVENT_FX = 0x1,
		SCRIPTABLE_EVENT_STOP_FX = 0x2,
		SCRIPTABLE_EVENT_SOUND = 0x3,
		SCRIPTABLE_EVENT_ANIMATION = 0x4,
		SCRIPTABLE_EVENT_EXPLODE = 0x5,
		SCRIPTABLE_EVENT_HEALTHDRAIN = 0x6,
		SCRIPTABLE_EVENT_PHYSICSLAUNCH = 0x7,
		SCRIPTABLE_EVENT_LIGHTSETTINGS = 0x8,
		SCRIPTABLE_EVENT_SUNLIGHTSETTINGS = 0x9,
		SCRIPTABLE_EVENT_SHAKE = 0xA,
		SCRIPTABLE_EVENT_TRANSLATE = 0xB,
		SCRIPTABLE_EVENT_ROTATE = 0xC,
		SCRIPTABLE_EVENT_STATECHANGE = 0xD,
		SCRIPTABLE_EVENT_COUNT = 0xE,
	};

	struct ScriptableEventModelDef
	{
		XModel* model;
	}; assert_sizeof(ScriptableEventModelDef, 8);

	struct ScriptableEventFxDef
	{
		FxEffectDef* handle;
		scr_string_t tagName;
		unsigned short loopTime;
		unsigned char loopTimeStreamIndex;
		bool tagUseAngles;
	}; assert_sizeof(ScriptableEventFxDef, 16);

	struct ScriptableEventStopFxDef
	{
		FxEffectDef* handle;
		scr_string_t tagName;
		unsigned short loopTime;
		unsigned char loopTimeStreamIndex;
		bool tagUseAngles;
	}; assert_sizeof(ScriptableEventFxDef, 16);

	struct ScriptableEventSoundDef
	{
		snd_alias_list_t* alias;
		bool looping;
	}; assert_sizeof(ScriptableEventSoundDef, 16);

	struct ScriptableEventAnimationDef
	{
		const char* animName;
		bool override;
		bool stateful;
		unsigned char animEntryIndex;
		unsigned char animPlaybackStreamIndex;
		unsigned short timeOffsetMin;
		unsigned short timeOffsetMax;
		unsigned short playbackRateMin;
		unsigned short playbackRateMax;
		unsigned short blendTime;
	}; assert_sizeof(ScriptableEventAnimationDef, 24);

	struct ScriptableEventExplodeDef
	{
		unsigned short forceMin;
		unsigned short forceMax;
		unsigned short radius;
		unsigned short damageMin;
		unsigned short damageMax;
		bool aiAvoid;
	}; assert_sizeof(ScriptableEventExplodeDef, 12);

	struct ScriptableEventHealthDef
	{
		unsigned short amount;
		unsigned short interval;
		unsigned short badPlaceRadius;
		unsigned char streamIndex;
	}; assert_sizeof(ScriptableEventHealthDef, 8);

	struct ScriptableEventPhysicsDef
	{
		XModel* model;
		unsigned char launchDirX;
		unsigned char launchDirY;
		unsigned char launchDirZ;
		unsigned short explForceScale;
		unsigned short bulletForceScale;
	}; assert_sizeof(ScriptableEventPhysicsDef, 16);

	struct ScriptableEventLightSettingsDef
	{
		unsigned char color[4];
		unsigned char lightIndexConstIndex;
		unsigned char transStateStreamIndex;
		unsigned char useColor;
		unsigned char useStateTransitionTime;
		unsigned short intensityScaleMin;
		unsigned short intensityScaleMax;
		unsigned short radiusScaleMin;
		unsigned short radiusScaleMax;
		unsigned short transitionTimeMin;
		unsigned short transitionTimeMax;
		const char* noteworthy;
	}; assert_sizeof(ScriptableEventLightSettingsDef, 32);
	assert_offsetof(ScriptableEventLightSettingsDef, noteworthy, 24);

	struct ScriptableEventSunlightSettingsDef
	{
		unsigned char color[4];
		unsigned char transStateStreamIndex;
		unsigned char flags;
		float intensityScaleMin;
		float intensityScaleMax;
		unsigned short pitchMin;
		unsigned short pitchMax;
		unsigned short headingMin;
		unsigned short headingMax;
		unsigned short transitionTimeMin;
		unsigned short transitionTimeMax;
	}; assert_sizeof(ScriptableEventSunlightSettingsDef, 28);

	struct ScriptableEventShakeDef
	{
		const char* rumbleName;
		unsigned short duration;
		unsigned short durationFadeUp;
		unsigned short durationFadeDown;
		unsigned short radius;
		unsigned short exponent;
		unsigned short scaleEarthquake;
		unsigned char scalePitch;
		unsigned char scaleYaw;
		unsigned char scaleRoll;
		unsigned char frequencyPitch;
		unsigned char frequencyYaw;
		unsigned char frequencyRoll;
		unsigned char flags;
	}; assert_sizeof(ScriptableEventShakeDef, 32);

	struct ScriptableEventTranslateDef
	{
		short translationMinX;
		short translationMinY;
		short translationMinZ;
		short translationMaxX;
		short translationMaxY;
		short translationMaxZ;
		unsigned short transitionTimeMin;
		unsigned short transitionTimeMax;
		unsigned char constIndex;
		unsigned char transStateStreamIndex;
		unsigned char flags;
		const char* noteworthy;
	}; assert_sizeof(ScriptableEventTranslateDef, 32);

	struct ScriptableEventRotateDef
	{
		short rotationMinPitch;
		short rotationMinYaw;
		short rotationMinRoll;
		short rotationMaxPitch;
		short rotationMaxYaw;
		short rotationMaxRoll;
		unsigned short transitionTimeMin;
		unsigned short transitionTimeMax;
		unsigned char constIndex;
		unsigned char transStateStreamIndex;
		unsigned char flags;
		const char* noteworthy;
	}; assert_sizeof(ScriptableEventTranslateDef, 32);

	struct ScriptableEventStateChangeDef
	{
		unsigned char targetIndex;
		unsigned char delayStreamIndex;
		unsigned short delayMin;
		unsigned short delayMax;
	}; assert_sizeof(ScriptableEventStateChangeDef, 6);

	union ScriptableEventDataUnion
	{
		ScriptableEventModelDef setModel;
		ScriptableEventFxDef playFx;
		ScriptableEventStopFxDef stopFx;
		ScriptableEventSoundDef playSound;
		ScriptableEventAnimationDef playAnim;
		ScriptableEventExplodeDef doExplosion;
		ScriptableEventHealthDef healthDrain;
		ScriptableEventPhysicsDef physicsLaunch;
		ScriptableEventLightSettingsDef lightSettings;
		ScriptableEventSunlightSettingsDef sunlightSettings;
		ScriptableEventShakeDef shake;
		ScriptableEventTranslateDef translate;
		ScriptableEventRotateDef rotate;
		ScriptableEventStateChangeDef stateChange;
	};

	struct ScriptableEventDef
	{
		ScriptableEventType type;
		ScriptableEventDataUnion data;
	};

	struct ScriptableStateDef
	{
		scr_string_t name;
		scr_string_t tagName;
		ScriptableEventDef* onEnterEvents;
		unsigned char onEnterEventCount;
		unsigned char damageFlags;
		unsigned char damageParentTransferRate;
		unsigned char damageParentReceiveRate;
		unsigned short maxHealth;
	}; assert_sizeof(ScriptableStateDef, 24);

	struct ScriptablePartDef
	{
		ScriptableStateDef* states;
		scr_string_t name;
		unsigned char stateCount;
		unsigned char flags;
		unsigned char eventStreamTimeRemainIndex;
		unsigned char eventStreamNextChangeTimeIndex;
	}; assert_sizeof(ScriptablePartDef, 16);

	enum ScriptableNotetrackType : std::int32_t
	{
		SCRIPTABLE_NT_FX = 0x0,
		SCRIPTABLE_NT_SOUND = 0x1,
		SCRIPTABLE_NT_COUNT = 0x2,
	};

	struct ScriptableNotetrackFxDef
	{
		FxEffectDef* handle;
		scr_string_t tagName;
		bool useAngles;
	};

	struct ScriptableNotetrackSoundDef
	{
		snd_alias_list_t* alias;
	};

	union ScriptableNotetrackDataUnion
	{
		ScriptableNotetrackFxDef playFx;
		ScriptableNotetrackSoundDef playSound;
	};

	struct ScriptableNotetrackDef
	{
		scr_string_t name;
		ScriptableNotetrackType type;
		ScriptableNotetrackDataUnion data;
	};

	enum ScriptableType : std::int32_t
	{
		SCRIPTABLE_TYPE_GENERAL = 0x0,
		SCRIPTABLE_TYPE_CHARACTER = 0x1,
		SCRIPTABLE_TYPE_COUNT = 0x2,
	};

	struct ScriptableDef
	{
		const char* name;
		XModel* baseModel;
		const char* baseCollisionBrush;
		const char* destroyedCollisionBrush;
		ScriptablePartDef* parts;
		ScriptableNotetrackDef* notetracks;
		ScriptableType type;
		unsigned char flags;
		unsigned char partCount;
		unsigned char serverInstancePartCount;
		unsigned char serverControlledPartCount;
		unsigned char notetrackCount;
		unsigned char eventStreamSize;
		unsigned char eventConstantsSize;
	}; assert_sizeof(ScriptableDef, 0x40);
	assert_offsetof(ScriptableDef, partCount, 53);
	assert_offsetof(ScriptableDef, eventConstantsSize, 58);

	struct ScriptableInstanceTargetData
	{
		unsigned int lightIndex;
		float lightAxis[4][3];
		float lightColorStorage[3];
		float lightRadiusStorage;
	}; assert_sizeof(ScriptableInstanceTargetData, 68);

	struct ScriptableInstancePartState
	{
		unsigned short curHealth;
		unsigned char lastExecutedStateIndex;
		unsigned char stateIndex;
	}; assert_sizeof(ScriptableInstancePartState, 4);

	struct ScriptableInstance
	{
		ScriptableDef* def;
		unsigned char* eventConstantsBuf;
		ScriptableInstanceTargetData* targetData;
		float origin[3];
		float angles[3];
		float startOrigin[3];
		float startAngles[3];
		scr_string_t targetname;
		unsigned short preBrushModel;
		unsigned short postBrushModel;
		unsigned char flags;
		unsigned char targetCount;
		XModel* currentModel;
		ScriptableInstancePartState* partStates;
		unsigned char* eventStreamBuf;
		unsigned int currentPartBits[8];
		unsigned int damageOwnerEntHandle;
		unsigned short updateNextInstance;
		unsigned short linkedObject;
	}; assert_sizeof(ScriptableInstance, 152);
	assert_offsetof(ScriptableInstance, targetData, 16);
	assert_offsetof(ScriptableInstance, targetname, 72);
	assert_offsetof(ScriptableInstance, currentModel, 88);
	assert_offsetof(ScriptableInstance, partStates, 96);
	assert_offsetof(ScriptableInstance, eventStreamBuf, 104);

	struct ScriptableAnimationEntry
	{
		const char* animName;
		unsigned __int64 runtimeBuf;
	}; assert_sizeof(ScriptableAnimationEntry, 16);

	struct ScriptableMapEnts
	{
		unsigned int instanceStateSize;
		unsigned int instanceCount;
		unsigned int reservedInstanceCount;
		ScriptableInstance* instances;
		unsigned int animEntryCount;
		ScriptableAnimationEntry* animEntries;
		unsigned int replicatedInstanceCount;
	}; assert_sizeof(ScriptableMapEnts, 48);
	assert_offsetof(ScriptableMapEnts, instances, 16);
	assert_offsetof(ScriptableMapEnts, animEntries, 32);

	struct sphere_tree_t
	{
		int axis;
		float dist;
		int numObjects;
		unsigned int* objIdx;
		unsigned int child[2];
	}; assert_sizeof(sphere_tree_t, 32);
	assert_offsetof(sphere_tree_t, numObjects, 8);
	assert_offsetof(sphere_tree_t, objIdx, 16);

	struct sphere_tree_obj_t
	{
		float origin[3];
		float radius;
		unsigned int object;
	}; assert_sizeof(sphere_tree_obj_t, 20);

	struct sphere_tree_data_t
	{
		int treeCount;
		sphere_tree_t* tree;
		int numObjects;
		sphere_tree_obj_t* objects;
	}; assert_sizeof(sphere_tree_data_t, 32);

	struct grapple_magnet_t
	{
		unsigned int flags;
		float origin[3];
		float normal[3];
		float length;
		int next;
		int prev;
	}; assert_sizeof(grapple_magnet_t, 40);

	struct grapple_data_t
	{
		sphere_tree_data_t magnetTree;
		grapple_magnet_t* magnets;
		unsigned int magnetCount;
	}; assert_sizeof(grapple_data_t, 48);

	struct /*alignas(128)*/ clipMap_t
	{
		const char* name; // 0
		int isInUse; // 8
		ClipInfo info; // 16
		ClipInfo* pInfo; // 264
		unsigned int numNodes; // 272
		cNode_t* nodes; // 280
		unsigned int numLeafs; // 288
		cLeaf_t* leafs; // 296
		unsigned int numSubModels; // 304
		cmodel_t* cmodels; // 312
		MapEnts* mapEnts; // 320
		Stage* stages; // 328
		unsigned char stageCount; // 336
		MapTriggers stageTrigger; // 344
		unsigned short dynEntCount[2];
		DynEntityDef* dynEntDefList[2];
		DynEntityPose* dynEntPoseList[2];
		DynEntityClient* dynEntClientList[2];
		DynEntityColl* dynEntCollList[2];
		unsigned int dynEntAnchorCount; // 464
		scr_string_t* dynEntAnchorNames; // 472
		ScriptableMapEnts scriptableMapEnts; // 480
		grapple_data_t grapple; // 528
		unsigned int checksum;
		char __pad0[60]; // alignment padding
	}; assert_sizeof(clipMap_t, 0x280);
	assert_offsetof(clipMap_t, info, 16);
	assert_offsetof(clipMap_t, pInfo, 264);
	assert_offsetof(clipMap_t, nodes, 280);
	assert_offsetof(clipMap_t, leafs, 296);
	assert_offsetof(clipMap_t, cmodels, 312);
	assert_offsetof(clipMap_t, stageTrigger, 344);
	assert_offsetof(clipMap_t, scriptableMapEnts, 480);
	assert_offsetof(clipMap_t, grapple, 528);

	enum GfxLightType : std::uint8_t
	{
		GFX_LIGHT_TYPE_NONE = 0x0,
		GFX_LIGHT_TYPE_DIR = 0x1,
		GFX_LIGHT_TYPE_SPOT = 0x2,
		GFX_LIGHT_TYPE_OMNI = 0x3,
		GFX_LIGHT_TYPE_COUNT = 0x4,
		GFX_LIGHT_TYPE_DIR_SHADOWMAP = 0x4,
		GFX_LIGHT_TYPE_SPOT_SHADOWMAP = 0x5,
		GFX_LIGHT_TYPE_OMNI_SHADOWMAP = 0x6,
		GFX_LIGHT_TYPE_COUNT_WITH_SHADOWMAP_VERSIONS = 0x7,
		GFX_LIGHT_TYPE_SPOT_SHADOWMAP_CUCOLORIS = 0x7,
		GFX_LIGHT_TYPE_COUNT_WITH_ALL_VERSIONS = 0x8,
	};

	struct ComPrimaryLight
	{
		GfxLightType type; // 0
		unsigned char canUseShadowMap; // 1
		unsigned char physicallyBased; // 2
		unsigned char exponent; // 3
		unsigned char lightingState; // 4
		char __pad0[3];
		float color[3]; // 8 12 16
		float dir[3]; // 20 24 28
		float up[3]; // 32 36 40
		float origin[3]; // 44 48 52
		float fadeOffset[2];
		float bulbRadius;
		float bulbLength[3];
		float radius; // 80
		float cosHalfFovOuter; // 84
		float cosHalfFovInner; // 88
		float cosHalfFovExpanded; // 92
		float rotationLimit; // 96
		float translationLimit; // 100
		float cucRotationOffsetRad; // 104
		float cucRotationSpeedRad; // 108
		float cucScrollVector[2]; // 112 116
		float cucScaleVector[2]; // 120 124
		float cucTransVector[2]; // 128 132
		const char* defName; // 136
	}; assert_sizeof(ComPrimaryLight, 144);
	assert_offsetof(ComPrimaryLight, color, 8);
	assert_offsetof(ComPrimaryLight, dir, 20);
	assert_offsetof(ComPrimaryLight, up, 32);
	assert_offsetof(ComPrimaryLight, origin, 44);
	assert_offsetof(ComPrimaryLight, radius, 80);
	assert_offsetof(ComPrimaryLight, cosHalfFovOuter, 84);
	assert_offsetof(ComPrimaryLight, cosHalfFovInner, 88);
	assert_offsetof(ComPrimaryLight, cosHalfFovExpanded, 92);
	assert_offsetof(ComPrimaryLight, rotationLimit, 96);
	assert_offsetof(ComPrimaryLight, translationLimit, 100);
	assert_offsetof(ComPrimaryLight, defName, 136);

	struct ComPrimaryLightEnv
	{
		unsigned short primaryLightIndices[4];
		unsigned char numIndices;
	}; assert_sizeof(ComPrimaryLightEnv, 10);

	struct ComWorld
	{
		const char* name;
		int isInUse;
		unsigned int primaryLightCount;
		ComPrimaryLight* primaryLights;
		unsigned int primaryLightEnvCount;
		ComPrimaryLightEnv* primaryLightEnvs;
	}; assert_sizeof(ComWorld, 0x28);

	struct G_GlassPiece
	{
		unsigned short damageTaken;
		unsigned short collapseTime;
		int lastStateChangeTime;
		unsigned char impactDir;
		unsigned char impactPos[2];
	}; assert_sizeof(G_GlassPiece, 12);

	struct G_GlassName
	{
		char* nameStr;
		scr_string_t name; // set during runtime from nameStr, G_InitGlass
		unsigned short pieceCount;
		unsigned short* pieceIndices;
	}; assert_sizeof(G_GlassName, 24);

	struct G_GlassData
	{
		G_GlassPiece* glassPieces;
		unsigned int pieceCount;
		unsigned short damageToWeaken;
		unsigned short damageToDestroy;
		unsigned int glassNameCount;
		G_GlassName* glassNames;
		unsigned char pad[108];
	}; assert_sizeof(G_GlassData, 0x90);

	struct GlassWorld
	{
		const char* name;
		G_GlassData* g_glassData;
	}; assert_sizeof(GlassWorld, 0x10);

	struct FxGlassDef
	{
		float halfThickness;
		float texVecs[2][2];
		GfxColor color;
		Material* material;
		Material* materialShattered;
		PhysPreset* physPreset;
		FxEffectDef* pieceBreakEffect;
		FxEffectDef* shatterEffect;
		FxEffectDef* shatterSmallEffect;
		FxEffectDef* crackDecalEffect;
		snd_alias_list_t* damagedSound;
		snd_alias_list_t* destroyedSound;
		snd_alias_list_t* destroyedQuietSound;
		float invHighMipRadius;
		float shatteredInvHighMipRadius;
		int numCrackRings;
		bool isOpaque;
	}; assert_sizeof(FxGlassDef, 120);

	struct FxSpatialFrame
	{
		float quat[4];
		float origin[3];
	};

	struct $03A8A7B39FA20F64B5AB79125E07CD62
	{
		FxSpatialFrame frame;
		float radius;
	};

	union FxGlassPiecePlace
	{
		$03A8A7B39FA20F64B5AB79125E07CD62 __s0;
		unsigned int nextFree;
	};

	struct FxGlassPieceState
	{
		float texCoordOrigin[2];
		unsigned int supportMask;
		unsigned short initIndex;
		unsigned short geoDataStart;
		unsigned short lightingIndex;
		unsigned char defIndex;
		unsigned char pad[3];
		unsigned char vertCount;
		unsigned char holeDataCount;
		unsigned char crackDataCount;
		unsigned char fanDataCount;
		unsigned short flags;
		float areaX2;
	}; assert_sizeof(FxGlassPieceState, 32);

	struct FxGlassPieceDynamics
	{
		int fallTime;
		__int64 physObjId;
		__int64 physJointId;
		float vel[3];
		float avel[3];
	}; assert_sizeof(FxGlassPieceDynamics, 48);

	struct FxGlassVertex
	{
		short x;
		short y;
	};

	struct FxGlassHoleHeader
	{
		unsigned short uniqueVertCount;
		unsigned char touchVert;
		unsigned char pad[1];
	};

	struct FxGlassCrackHeader
	{
		unsigned short uniqueVertCount;
		unsigned char beginVertIndex;
		unsigned char endVertIndex;
	};

	union FxGlassGeometryData
	{
		FxGlassVertex vert;
		FxGlassHoleHeader hole;
		FxGlassCrackHeader crack;
		unsigned char asBytes[4];
		short anonymous[2];
	}; assert_sizeof(FxGlassGeometryData, 4);

	struct FxGlassInitPieceState
	{
		FxSpatialFrame frame;
		float radius;
		float texCoordOrigin[2];
		unsigned int supportMask;
		float areaX2;
		unsigned short lightingIndex;
		unsigned char defIndex;
		unsigned char vertCount;
		unsigned char fanDataCount;
		unsigned char pad[1];
	}; assert_sizeof(FxGlassInitPieceState, 56);

	struct FxGlassSystem
	{
		int time;
		int prevTime;
		unsigned int defCount;
		unsigned int pieceLimit;
		unsigned int pieceWordCount;
		unsigned int cellCount;
		unsigned int activePieceCount;
		unsigned int firstFreePiece;
		unsigned int geoDataLimit;
		unsigned int geoDataCount;
		unsigned int initGeoDataCount;
		FxGlassDef* defs;
		FxGlassPiecePlace* piecePlaces;
		FxGlassPieceState* pieceStates;
		FxGlassPieceDynamics* pieceDynamics;
		FxGlassGeometryData* geoData;
		unsigned int* isInUse;
		unsigned int* cellBits;
		unsigned char* visData;
		float(*linkOrg)[3];
		float* halfThickness;
		unsigned short* lightingHandles;
		FxGlassGeometryData* initGeoData;
		bool needToCompactData;
		unsigned char initCount;
		float effectChanceAccum;
		int lastPieceDeletionTime;
		unsigned int initPieceCount;
		FxGlassInitPieceState* initPieceStates;
	}; assert_sizeof(FxGlassSystem, 168);
	assert_offsetof(FxGlassSystem, initPieceStates, 160);

	struct FxWorld
	{
		const char* name;
		FxGlassSystem glassSys;
	}; assert_sizeof(FxWorld, 0xB0);

	struct GfxSky
	{
		int skySurfCount;
		int* skyStartSurfs;
		GfxImage* skyImage;
		unsigned char skySamplerState;
		Bounds bounds;
	}; assert_sizeof(GfxSky, 56);

	struct GfxWorldDpvsPlanes
	{
		int cellCount;
		cplane_s* planes;
		unsigned short* nodes;
		unsigned int* sceneEntCellBits;
	}; assert_sizeof(GfxWorldDpvsPlanes, 32);

	struct GfxCellTreeCount
	{
		int aabbTreeCount;
	};

	struct GfxAabbTree
	{
		Bounds bounds;
		int childrenOffset;
		unsigned short childCount;
		unsigned short smodelIndexCount;
		unsigned short* smodelIndexes;
		int startSurfIndex;
		unsigned short surfaceCount;
		unsigned short pad;
	}; assert_sizeof(GfxAabbTree, 48);
	assert_offsetof(GfxAabbTree, childrenOffset, 24);
	assert_offsetof(GfxAabbTree, childCount, 28);
	assert_offsetof(GfxAabbTree, smodelIndexCount, 30);
	assert_offsetof(GfxAabbTree, smodelIndexes, 32);
	assert_offsetof(GfxAabbTree, startSurfIndex, 40);
	assert_offsetof(GfxAabbTree, surfaceCount, 44);

	struct GfxCellTree
	{
		GfxAabbTree* aabbTree;
	};

	struct GfxPortal;
	struct GfxPortalWritable
	{
		bool isQueued;
		bool isAncestor;
		unsigned char recursionDepth;
		unsigned char hullPointCount;
		float(*hullPoints)[2];
		GfxPortal* queuedParent;
	};

	struct DpvsPlane
	{
		float coeffs[4];
	};

	struct GfxPortal
	{
		GfxPortalWritable writable;
		DpvsPlane plane;
		float(*vertices)[3];
		unsigned short cellIndex;
		unsigned short closeDistance;
		unsigned char vertexCount;
		float hullAxis[2][3];
	}; assert_sizeof(GfxPortal, 80);
	assert_offsetof(GfxPortal, vertices, 40);
	assert_offsetof(GfxPortal, vertexCount, 52);

	struct GfxCell
	{
		Bounds bounds;
		unsigned short portalCount;
		unsigned char reflectionProbeCount;
		unsigned char reflectionProbeReferenceCount;
		GfxPortal* portals;
		unsigned char* reflectionProbes;
		unsigned char* reflectionProbeReferences;
	}; assert_sizeof(GfxCell, 56);
	assert_offsetof(GfxCell, portalCount, 24);
	assert_offsetof(GfxCell, reflectionProbeCount, 26);
	assert_offsetof(GfxCell, reflectionProbeReferenceCount, 27);
	assert_offsetof(GfxCell, portals, 32);
	assert_offsetof(GfxCell, reflectionProbes, 40);
	assert_offsetof(GfxCell, reflectionProbeReferences, 48);

	struct GfxPortalGroupInfo
	{
		unsigned short cellIndex;
		unsigned short portalIndex;
	};

	struct GfxPortalGroup
	{
		const char* targetName;
		GfxPortalGroupInfo* gfxPortalArray;
		scr_string_t targetNameIndex;
		unsigned short numPortals;
	}; assert_sizeof(GfxPortalGroup, 24);
	assert_offsetof(GfxPortalGroup, numPortals, 20);

	struct GfxReflectionProbeVolume
	{
		unsigned short* probeVolumePlanes;
		unsigned int probeVolumePlaneCount;
	}; assert_sizeof(GfxReflectionProbeVolume, 16);

	struct GfxReflectionProbe
	{
		float origin[3];
		GfxReflectionProbeVolume* probeVolumes;
		unsigned int probeVolumeCount;
		unsigned int lightingState;
	}; assert_sizeof(GfxReflectionProbe, 32);
	assert_offsetof(GfxReflectionProbe, probeVolumeCount, 24);

	struct GfxReflectionProbeReferenceOrigin
	{
		float origin[3];
	};

	struct GfxReflectionProbeReference
	{
		unsigned char index;
	};

	struct GfxRawTexture : GfxTexture
	{
		char __pad0[8];
	}; assert_sizeof(GfxRawTexture, 32);

	struct GfxLightmapArray
	{
		GfxImage* primary;
		GfxImage* secondary;
	};

	struct GfxWorldVertex
	{
		float xyz[3];
		float binormalSign;
		GfxColor color;
		float texCoord[2];
		float lmapCoord[2];
		PackedUnitVec normal;
		PackedUnitVec tangent;
	}; assert_sizeof(GfxWorldVertex, 44);

	union GfxWorldVertex0Union
	{
		GfxWorldVertex* vertices;
	};

	struct GfxWorldVertexData
	{
		GfxWorldVertex* vertices;
		ID3D11Buffer* worldVb;
		ID3D11ShaderResourceView* worldVbView;
	}; assert_sizeof(GfxWorldVertexData, 24);

	struct GfxWorldVertexLayerData
	{
		unsigned char* data;
		ID3D11Buffer* layerVb;
		ID3D11ShaderResourceView* layerVbView;
	}; assert_sizeof(GfxWorldVertexLayerData, 24);

	struct GfxDisplacementParms
	{
		char __pad0[16];
	}; assert_sizeof(GfxDisplacementParms, 16);

	struct GfxLightmapParameters
	{
		int lightmapWidthPrimary;
		int lightmapHeightPrimary;
		int lightmapWidthSecondary;
		int lightmapHeightSecondary;
		int lightmapModelUnitsPerTexel;
	};

	struct GfxWorldDraw
	{
		unsigned int reflectionProbeCount;
		GfxImage** reflectionProbes;
		GfxReflectionProbe* reflectionProbeOrigins;
		GfxRawTexture* reflectionProbeTextures;
		unsigned int reflectionProbeReferenceCount;
		GfxReflectionProbeReferenceOrigin* reflectionProbeReferenceOrigins;
		GfxReflectionProbeReference* reflectionProbeReferences;
		int lightmapCount;
		GfxLightmapArray* lightmaps;
		GfxRawTexture* lightmapPrimaryTextures;
		GfxRawTexture* lightmapSecondaryTextures;
		GfxImage* lightmapOverridePrimary;
		GfxImage* lightmapOverrideSecondary;
		GfxLightmapParameters lightmapParameters;
		unsigned int trisType;
		unsigned int vertexCount;
		GfxWorldVertexData vd;
		unsigned int vertexLayerDataSize;
		GfxWorldVertexLayerData vld;
		unsigned int indexCount;
		unsigned short* indices;
		ID3D11Buffer* indexBuffer;
		ID3D11ShaderResourceView* indexBufferView;
		int displacementParmsCount;
		GfxDisplacementParms* displacementParms;
		ID3D11Buffer* displacementParmsBuffer;
		ID3D11ShaderResourceView* displacementParmsBufferView;
	}; assert_sizeof(GfxWorldDraw, 256);
	assert_offsetof(GfxWorldDraw, reflectionProbeTextures, 24);
	assert_offsetof(GfxWorldDraw, lightmaps, 64);
	assert_offsetof(GfxWorldDraw, lightmapOverrideSecondary, 96);
	assert_offsetof(GfxWorldDraw, vertexCount, 128);
	assert_offsetof(GfxWorldDraw, vd, 136);
	assert_offsetof(GfxWorldDraw, vld, 168);
	assert_offsetof(GfxWorldDraw, indexCount, 192);
	assert_offsetof(GfxWorldDraw, indices, 200);
	assert_offsetof(GfxWorldDraw, displacementParmsCount, 224);
	assert_offsetof(GfxWorldDraw, displacementParms, 232);

	struct GfxLightGridEntry
	{
		unsigned int colorsIndex;
		unsigned short primaryLightEnvIndex;
		unsigned char unused;
		unsigned char needsTrace;
	}; assert_sizeof(GfxLightGridEntry, 8);

	struct GfxLightGridColors
	{
		unsigned short rgb[56][3];
	}; assert_sizeof(GfxLightGridColors, 336);

	struct GfxLightGridColorsHDR
	{
		unsigned short rgb[56][3];
	}; assert_sizeof(GfxLightGridColorsHDR, 336);

	enum $25ED8C8BD8ECF2D54402B1200AEDD83D : std::int32_t
	{
		LIGHTINGSTATE_NONE = 0x0,
		LIGHTINGSTATE_A = 0x1,
		LIGHTINGSTATE_B = 0x2,
		LIGHTINGSTATE_COUNT = 0x3,
		LIGHTINGSTATE_MAX = 0x2,
	};

	struct GfxLightGridTree
	{
		union
		{
			unsigned char lightingState;
			unsigned char index;
		};
		unsigned char maxDepth;
		char unused[2];
		int nodeCount;
		int leafCount;
		int coordMinGridSpace[3];
		int coordMaxGridSpace[3];
		int coordHalfSizeGridSpace[3];
		int defaultColorIndexBitCount;
		int defaultLightIndexBitCount;
		unsigned int* p_nodeTable;
		int leafTableSize;
		unsigned char* p_leafTable;
	}; assert_sizeof(GfxLightGridTree, 80);

	struct GfxLightGrid
	{
		bool hasLightRegions;
		bool useSkyForLowZ;
		unsigned int lastSunPrimaryLightIndex;
		unsigned short mins[3];
		unsigned short maxs[3];
		unsigned int rowAxis;
		unsigned int colAxis;
		unsigned short* rowDataStart;
		unsigned int rawRowDataSize;
		unsigned char* rawRowData;
		unsigned int entryCount;
		GfxLightGridEntry* entries;
		unsigned int colorCount;
		GfxLightGridColors* colors;
		GfxLightGridEntry cachedSkyLightGridEntry;
		float cachedSkyLightEntryAverageColor[3];
		unsigned int missingGridColorIndex;
		int tableVersion;
		int paletteVersion;
		char rangeExponent8BitsEncoding;
		char rangeExponent12BitsEncoding;
		char rangeExponent16BitsEncoding;
		unsigned char stageCount;
		float* stageLightingContrastGain;
		unsigned int paletteEntryCount;
		int* paletteEntryAddress;
		unsigned int paletteBitstreamSize;
		unsigned char* paletteBitstream;
		GfxLightGridColorsHDR skyLightGridColors;
		GfxLightGridColorsHDR defaultLightGridColors;
		GfxLightGridTree tree[3];
	}; assert_sizeof(GfxLightGrid, 1080);
	assert_offsetof(GfxLightGrid, rowDataStart, 32);
	assert_offsetof(GfxLightGrid, rawRowData, 48);
	assert_offsetof(GfxLightGrid, entries, 64);
	assert_offsetof(GfxLightGrid, colors, 80);
	assert_offsetof(GfxLightGrid, paletteVersion, 116);
	assert_offsetof(GfxLightGrid, rangeExponent8BitsEncoding, 120);
	assert_offsetof(GfxLightGrid, stageCount, 123);
	assert_offsetof(GfxLightGrid, stageLightingContrastGain, 128);
	assert_offsetof(GfxLightGrid, paletteEntryCount, 136);
	assert_offsetof(GfxLightGrid, paletteEntryAddress, 144);
	assert_offsetof(GfxLightGrid, paletteBitstreamSize, 152);
	assert_offsetof(GfxLightGrid, paletteBitstream, 160);
	assert_offsetof(GfxLightGrid, tree, 840);

	struct GfxBrushModelWritable
	{
		Bounds bounds;
		vec3_t origin;
		vec4_t quat;
		int mdaoVolumeProcessed;
	};

	struct GfxBrushModel
	{
		GfxBrushModelWritable writable;
		Bounds bounds;
		float radius;
		unsigned int startSurfIndex;
		unsigned short surfaceCount;
		int mdaoVolumeIndex;
	}; assert_sizeof(GfxBrushModel, 96);

	struct MaterialMemory
	{
		Material* material;
		int memory;
	}; assert_sizeof(MaterialMemory, 16);

	struct sunflare_t
	{
		bool hasValidData;
		Material* spriteMaterial;
		Material* flareMaterial;
		float spriteSize;
		float flareMinSize;
		float flareMinDot;
		float flareMaxSize;
		float flareMaxDot;
		float flareMaxAlpha;
		int flareFadeInTime;
		int flareFadeOutTime;
		float blindMinDot;
		float blindMaxDot;
		float blindMaxDarken;
		int blindFadeInTime;
		int blindFadeOutTime;
		float glareMinDot;
		float glareMaxDot;
		float glareMaxLighten;
		int glareFadeInTime;
		int glareFadeOutTime;
		float sunFxPosition[3];
	}; assert_sizeof(sunflare_t, 112);

	struct XModelDrawInfo
	{
		unsigned char hasGfxEntIndex;
		unsigned char lod;
		unsigned short surfId;
	};

	struct GfxSceneDynModel
	{
		XModelDrawInfo info;
		unsigned short dynEntId;
	}; assert_sizeof(GfxSceneDynModel, 6);

	struct BModelDrawInfo
	{
		unsigned short surfId;
	};

	struct GfxSceneDynBrush
	{
		BModelDrawInfo info;
		unsigned short dynEntId;
	}; assert_sizeof(GfxSceneDynBrush, 4);

	struct GfxShadowGeometry
	{
		unsigned short surfaceCount;
		unsigned short smodelCount;
		unsigned int* sortedSurfIndex;
		unsigned short* smodelIndex;
	}; assert_sizeof(GfxShadowGeometry, 24);

	struct GfxLightRegionAxis
	{
		float dir[3];
		float midPoint;
		float halfSize;
	}; assert_sizeof(GfxLightRegionAxis, 20);

	struct GfxLightRegionHull
	{
		float kdopMidPoint[9];
		float kdopHalfSize[9];
		unsigned int axisCount;
		GfxLightRegionAxis* axis;
	}; assert_sizeof(GfxLightRegionHull, 88);

	struct GfxLightRegion
	{
		unsigned int hullCount;
		GfxLightRegionHull* hulls;
	}; assert_sizeof(GfxLightRegion, 16);

	struct GfxStaticModelInst
	{
		float mins[3];
		float maxs[3];
		float lightingOrigin[3];
	}; assert_sizeof(GfxStaticModelInst, 36);

	struct srfTriangles_t
	{
		unsigned int vertexLayerData;
		unsigned int firstVertex;
		float maxEdgeLength;
		int unk;
		unsigned short vertexCount;
		unsigned short triCount;
		unsigned int baseIndex;
	};

	struct GfxSurfaceLightingAndFlagsFields
	{
		unsigned char lightmapIndex;
		unsigned char reflectionProbeIndex;
		unsigned short primaryLightEnvIndex;
		unsigned char flags;
		unsigned char unused[3];
	};

	union GfxSurfaceLightingAndFlags
	{
		GfxSurfaceLightingAndFlagsFields fields;
		unsigned __int64 packed;
	};

	struct GfxSurface
	{
		srfTriangles_t tris;
		Material* material;
		GfxSurfaceLightingAndFlags laf;
	}; assert_sizeof(GfxSurface, 40);
	assert_offsetof(GfxSurface, material, 24);

	struct GfxSurfaceBounds
	{
		Bounds bounds;
		float unk[3];
	}; assert_sizeof(GfxSurfaceBounds, 36);

	struct GfxPackedPlacement
	{
		float origin[3];
		float axis[3][3];
		float scale;
	};

	enum StaticModelFlag : std::int16_t
	{
		// scale modifiers: 
		// 0 = 0.25f
		// 1 = 0.285714f
		// 2 = 0.333333f
		// 3 = 0.4f
		// 4 = 0.5f
		// 5 = 0.571429f
		// 6 = 0.666667f
		// 7 = 0.8f
		// 8 = 0.888889f
		// 9 = 1.0f
		// 10 = 1.14286f
		// 11 = 1.33333f
		// 12 = 1.6f
		// 13 = 2.0f
		// 14 = 2.66667f
		// 15 = 4.0f
		STATIC_MODEL_FLAG_SCALE_0 = 0,
		STATIC_MODEL_FLAG_SCALE_1 = 1,
		STATIC_MODEL_FLAG_SCALE_2 = 2,
		STATIC_MODEL_FLAG_SCALE_3 = 3,
		STATIC_MODEL_FLAG_SCALE_4 = 4,
		STATIC_MODEL_FLAG_SCALE_5 = 5,
		STATIC_MODEL_FLAG_SCALE_6 = 6,
		STATIC_MODEL_FLAG_SCALE_7 = 7,
		STATIC_MODEL_FLAG_SCALE_8 = 8,
		STATIC_MODEL_FLAG_SCALE_9 = 9,
		STATIC_MODEL_FLAG_SCALE_10 = 10,
		STATIC_MODEL_FLAG_SCALE_11 = 11,
		STATIC_MODEL_FLAG_SCALE_12 = 12,
		STATIC_MODEL_FLAG_SCALE_13 = 13,
		STATIC_MODEL_FLAG_SCALE_14 = 14,
		STATIC_MODEL_FLAG_SCALE_15 = 15,
		STATIC_MODEL_FLAG_SCALE_MODIFIER_MASK = 0xF,
		STATIC_MODEL_FLAG_NO_CAST_SHADOW = 0x10,
		STATIC_MODEL_FLAG_GROUND_LIGHTING = 0x20,
		STATIC_MODEL_FLAG_LIGHTGRID_LIGHTING = 0x40,
		STATIC_MODEL_FLAG_VERTEXLIT_LIGHTING = 0x80, // mv
		STATIC_MODEL_FLAG_LIGHTMAP_LIGHTING = 0x100, // ml
		STATIC_MODEL_FLAG_ALLOW_FXMARK = 0x200,
		STATIC_MODEL_FLAG_REACTIVEMOTION = 0x400,
		STATIC_MODEL_FLAG_ANIMATED_VERTS = 0x800,
	};

	struct GfxStaticModelDrawInst
	{
		GfxPackedPlacement placement;
		XModel* model;
		unsigned short cullDist;
		unsigned short flags;
		unsigned short lightingHandle;
		unsigned short staticModelId;
		unsigned short primaryLightEnvIndex;
		unsigned short reactiveMotionCullDist;
		unsigned char reactiveMotionLOD;
		unsigned char reflectionProbeIndex;
		unsigned char firstMtlSkinIndex;
		unsigned char sunShadowFlags;
	}; assert_sizeof(GfxStaticModelDrawInst, 80);
	assert_offsetof(GfxStaticModelDrawInst, model, 56);
	assert_offsetof(GfxStaticModelDrawInst, cullDist, 64);
	assert_offsetof(GfxStaticModelDrawInst, flags, 66);
	assert_offsetof(GfxStaticModelDrawInst, lightingHandle, 68);
	assert_offsetof(GfxStaticModelDrawInst, primaryLightEnvIndex, 72);
	assert_offsetof(GfxStaticModelDrawInst, reflectionProbeIndex, 77);
	assert_offsetof(GfxStaticModelDrawInst, firstMtlSkinIndex, 78);

	struct GfxStaticModelVertexLighting
	{
		unsigned char visibility[4];
		unsigned short ambientColorFloat16[4];
		unsigned short highlightColorFloat16[4];
	}; assert_sizeof(GfxStaticModelVertexLighting, 20);

	struct GfxStaticModelVertexLightingInfo
	{
		GfxStaticModelVertexLighting* lightingValues;
		ID3D11Buffer* lightingValuesVb;
		int numLightingValues;
	};

	struct GfxStaticModelLightmapInfo
	{
		float offset[2];
		float scale[2];
		unsigned int lightmapIndex;
	};

	struct GfxStaticModelAmbientLightingInfo
	{
		GfxColorHdr groundLighting;
		unsigned int colorIndex;
		float primaryLightWeight;
	};

	union GfxStaticModelLighting
	{
		GfxStaticModelAmbientLightingInfo ambientLightingInfo;
		GfxStaticModelVertexLightingInfo vertexLightingInfo;
		GfxStaticModelLightmapInfo modelLightmapInfo;
		char pad[24];
	}; assert_sizeof(GfxStaticModelLighting, 24);

	struct GfxSubdivVertexLightingInfo
	{
		int vertexLightingIndex;
		ID3D11Buffer* vb;
		GfxSubdivCache cache;
	}; assert_sizeof(GfxSubdivVertexLightingInfo, 40);

	struct GfxDepthAndSurf
	{
		short depthSort;
		short pad;
		int surfIndex;
	}; assert_sizeof(GfxDepthAndSurf, 8);

	typedef char* GfxWorldDpvsVoid;

	struct GfxWorldDpvsStatic
	{
		unsigned int smodelCount; // 0
		unsigned int subdivVertexLightingInfoCount; // 4
		unsigned int staticSurfaceCount; // 8
		unsigned int litOpaqueSurfsBegin; // 12
		unsigned int litOpaqueSurfsEnd; // 16
		unsigned int unkSurfsBegin;
		unsigned int unkSurfsEnd;
		unsigned int litDecalSurfsBegin; // 28
		unsigned int litDecalSurfsEnd; // 32
		unsigned int litTransSurfsBegin; // 36
		unsigned int litTransSurfsEnd; // 40
		unsigned int shadowCasterSurfsBegin; // 44
		unsigned int shadowCasterSurfsEnd; // 48
		unsigned int emissiveSurfsBegin; // 52
		unsigned int emissiveSurfsEnd; // 56
		unsigned int smodelVisDataCount; // 60
		unsigned int surfaceVisDataCount; // 64
		unsigned int* smodelVisData[4]; // 72 80 88 96
		unsigned int* smodelUnknownVisData[27];
		unsigned int* surfaceVisData[4]; // 320 328 336 344
		unsigned int* surfaceUnknownVisData[27];
		unsigned int* smodelUmbraVisData[4]; // 568 576 584 592
		unsigned int* surfaceUmbraVisData[4]; // 600 608 616 624
		unsigned int* lodData; // 632
		unsigned int* tessellationCutoffVisData; // 640
		unsigned int* sortedSurfIndex; // 648
		GfxStaticModelInst* smodelInsts; // 656
		GfxSurface* surfaces; // 664
		GfxSurfaceBounds* surfacesBounds; // 672
		GfxStaticModelDrawInst* smodelDrawInsts; // 680
		unsigned int* unknownSModelVisData1; // 688
		unsigned int* unknownSModelVisData2; // 696
		GfxStaticModelLighting* smodelLightingInsts; // 704 (array)
		GfxSubdivVertexLightingInfo* subdivVertexLighting; // 712 (array)
		GfxDrawSurf* surfaceMaterials; // 720
		unsigned int* surfaceCastsSunShadow; // 728
		unsigned int sunShadowOptCount; // 736
		unsigned int sunSurfVisDataCount; // 740
		unsigned int* surfaceCastsSunShadowOpt; // 744
		GfxDepthAndSurf* surfaceDeptAndSurf; // 752
		GfxWorldDpvsVoid* constantBuffersLit; // 760
		GfxWorldDpvsVoid* constantBuffersAmbient; // 768
		int usageCount; // 776
	}; assert_sizeof(GfxWorldDpvsStatic, 784);
	assert_offsetof(GfxWorldDpvsStatic, smodelVisData[0], 72);
	assert_offsetof(GfxWorldDpvsStatic, surfaceVisData[0], 320);
	assert_offsetof(GfxWorldDpvsStatic, smodelUmbraVisData[0], 568);
	assert_offsetof(GfxWorldDpvsStatic, tessellationCutoffVisData, 640);
	assert_offsetof(GfxWorldDpvsStatic, smodelDrawInsts, 680);
	assert_offsetof(GfxWorldDpvsStatic, smodelLightingInsts, 704);
	assert_offsetof(GfxWorldDpvsStatic, sunSurfVisDataCount, 740);
	assert_offsetof(GfxWorldDpvsStatic, constantBuffersAmbient, 768);

	struct GfxWorldDpvsDynamic
	{
		unsigned int dynEntClientWordCount[2]; // 0 4
		unsigned int dynEntClientCount[2]; // 8 12
		unsigned int* dynEntCellBits[2]; // 16 24
		unsigned char* dynEntVisData[2][4]; // 32 40 48 56 64 72 80 88
	}; assert_sizeof(GfxWorldDpvsDynamic, 96);

	struct GfxHeroOnlyLight
	{
		unsigned char type;
		unsigned char needsDynamicShadows;
		unsigned char unused[2];
		float color[3];
		float dir[3];
		float up[3];
		float origin[3];
		float radius;
		float cosHalfFovOuter;
		float cosHalfFovInner;
		int exponent;
	}; assert_sizeof(GfxHeroOnlyLight, 68);

	typedef void* umbraTomePtr_t;

	struct GfxBuildInfo
	{
		const char* bspCommandline;
		const char* lightCommandline;
		const char* bspTimestamp;
		const char* lightTimestamp;
	}; assert_sizeof(GfxBuildInfo, 32);

	enum FogTypes : std::int8_t
	{
		FOG_NORMAL = 0x1,
		FOG_DFOG = 0x2,
	};

	struct GfxWorld
	{
		const char* name; // 0
		const char* baseName; // 8
		unsigned int bspVersion; // 16
		int planeCount; // 20
		int nodeCount; // 24
		unsigned int surfaceCount; // 28
		int skyCount; // 32
		GfxSky* skies; // 40
		unsigned int portalGroupCount; // 48
		unsigned int lastSunPrimaryLightIndex; // 52
		unsigned int primaryLightCount; // 56
		unsigned int primaryLightEnvCount; // 60
		unsigned int sortKeyLitDecal; // 64
		unsigned int sortKeyEffectDecal; // 68
		unsigned int sortKeyTopDecal; // 72
		unsigned int sortKeyEffectAuto; // 76
		unsigned int sortKeyDistortion; // 80
		unsigned int sortKeyHair; // 84
		unsigned int sortKeyEffectBlend; // 88
		char __pad0[4]; // 92
		GfxWorldDpvsPlanes dpvsPlanes; // 96
		GfxCellTreeCount* aabbTreeCounts; // 128
		GfxCellTree* aabbTrees; // 136
		GfxCell* cells; // 144
		GfxPortalGroup* portalGroup; // 152
		unsigned int portalDistanceAnchorCount; // 160
		char __pad1[4];
		vec4_t* portalDistanceAnchorsAndCloseDistSquared; // 168
		GfxWorldDraw draw; // 176
		GfxLightGrid lightGrid; // 432
		int modelCount; // 1512
		GfxBrushModel* models; // 1520
		Bounds bounds;
		Bounds shadowBounds;
		unsigned int checksum;
		int materialMemoryCount; // 1580
		MaterialMemory* materialMemory; // 1584
		sunflare_t sun; // 1592
		float outdoorLookupMatrix[4][4];
		GfxImage* outdoorImage; // 1768
		unsigned int* cellCasterBits; // 1776
		unsigned int* cellHasSunLitSurfsBits; // 1784
		GfxSceneDynModel* sceneDynModel; // 1792
		GfxSceneDynBrush* sceneDynBrush; // 1800
		unsigned int* primaryLightEntityShadowVis; // 1808
		unsigned int* primaryLightDynEntShadowVis[2]; // 1816 1824
		unsigned short* nonSunPrimaryLightForModelDynEnt; // 1832
		GfxShadowGeometry* shadowGeom; // 1840
		GfxShadowGeometry* shadowGeomOptimized; // 1848
		GfxLightRegion* lightRegion; // 1856
		GfxWorldDpvsStatic dpvs; // 1864
		GfxWorldDpvsDynamic dpvsDyn; // 2648
		unsigned int mapVtxChecksum;
		unsigned int heroOnlyLightCount; // 2748
		GfxHeroOnlyLight* heroOnlyLights; // 2752
		unsigned char fogTypesAllowed; // 2760
		unsigned int umbraTomeSize; // 2764
		char* umbraTomeData; // 2768
		umbraTomePtr_t umbraTomePtr; // 2776
		unsigned int mdaoVolumesCount; // 2784
		MdaoVolume* mdaoVolumes; // 2792
		bool useLightGridDefaultModelLightingLookup;
		bool useLightGridDefaultFXLightingLookup;
		float lightGridDefaultModelLightingLookup[3];
		float lightGridDefaultFXLightingLookup[3];
		GfxBuildInfo buildInfo; // 2832
	}; assert_sizeof(GfxWorld, 0xB30);
	assert_offsetof(GfxWorld, skyCount, 32);
	assert_offsetof(GfxWorld, skies, 40);
	assert_offsetof(GfxWorld, dpvsPlanes, 96);
	assert_offsetof(GfxWorld, aabbTreeCounts, 128);
	assert_offsetof(GfxWorld, cells, 144);
	assert_offsetof(GfxWorld, portalGroup, 152);
	assert_offsetof(GfxWorld, portalDistanceAnchorCount, 160);
	assert_offsetof(GfxWorld, portalDistanceAnchorsAndCloseDistSquared, 168);
	assert_offsetof(GfxWorld, draw, 176);
	assert_offsetof(GfxWorld, lightGrid, 432);
	assert_offsetof(GfxWorld, modelCount, 1512);
	assert_offsetof(GfxWorld, models, 1520);
	assert_offsetof(GfxWorld, materialMemoryCount, 1580);
	assert_offsetof(GfxWorld, materialMemory, 1584);
	assert_offsetof(GfxWorld, sun, 1592);
	assert_offsetof(GfxWorld, outdoorImage, 1768);
	assert_offsetof(GfxWorld, cellCasterBits, 1776);
	assert_offsetof(GfxWorld, cellHasSunLitSurfsBits, 1784);
	assert_offsetof(GfxWorld, dpvs, 1864);
	assert_offsetof(GfxWorld, dpvsDyn, 2648);
	assert_offsetof(GfxWorld, heroOnlyLightCount, 2748);
	assert_offsetof(GfxWorld, heroOnlyLights, 2752);
	assert_offsetof(GfxWorld, umbraTomeSize, 2764);
	assert_offsetof(GfxWorld, umbraTomeData, 2768);
	assert_offsetof(GfxWorld, umbraTomePtr, 2776);
	assert_offsetof(GfxWorld, mdaoVolumesCount, 2784);
	assert_offsetof(GfxWorld, mdaoVolumes, 2792);
	assert_offsetof(GfxWorld, mdaoVolumes, 2792);
	assert_offsetof(GfxWorld, buildInfo, 2832);

	struct GfxLightImage
	{
		GfxImage* image;
		unsigned char samplerState;
	};

	struct GfxLightDef
	{
		const char* name;
		GfxLightImage attenuation;
		GfxLightImage cucoloris;
		int lmapLookupStart;
	}; assert_sizeof(GfxLightDef, 0x30);

	struct AddonMapEnts
	{
		const char* name;
		char* entityString;
		int numEntityChars;
		MapTriggers trigger;
		ClipInfo* info;
		unsigned int numSubModels;
		cmodel_t* cmodels;
		GfxBrushModel* models;
		PhysBrushModel* physModels;
		dmPolytopeData* polytope;
		dmMeshData* meshData;
		unsigned int polytopeCount;
		unsigned int meshDataCount;
	}; assert_sizeof(AddonMapEnts, 0x88);

	struct Clut
	{
		unsigned int width;
		unsigned int height;
		unsigned int depth;
		unsigned char* pixels;
		const char* name;
	}; assert_sizeof(Clut, 0x20);

	struct pathnode_yaworient_t
	{
		float fLocalAngle;
		float localForward[2];
	};

	union $3936EE84564F75EDA6DCBAC77A545FC8
	{
		pathnode_yaworient_t yaw_orient;
		float angles[3];
	};

	union PathNodeParentUnion
	{
		scr_string_t name;
		unsigned short index;
	};

	enum PathNodeErrorCode : std::int32_t
	{
		PNERR_NONE = 0x0,
		PNERR_INSOLID = 0x1,
		PNERR_FLOATING = 0x2,
		PNERR_NOLINK = 0x3,
		PNERR_DUPLICATE = 0x4,
		PNERR_NOSTANCE = 0x5,
		PNERR_INVALIDDOOR = 0x6,
		PNERR_NOANGLES = 0x7,
		PNERR_BADPLACEMENT = 0x8,
		NUM_PATH_NODE_ERRORS = 0x9,
	};

	union $5F11B9753862CE791E23553F99FA1738
	{
		float minUseDistSq;
		PathNodeErrorCode error;
	};

	struct pathlink_s
	{
		float fDist;
		unsigned short nodeNum;
		unsigned char disconnectCount;
		unsigned char negotiationLink;
		unsigned char flags;
		unsigned char ubBadPlaceCount[3];
	};

	enum nodeSpawnFlags : std::uint32_t
	{
		PNF_DONTLINK = 0x1,
		PNF_INDOORTRANSITION = 0x2,
		PNF_DONTSTAND = 0x4,
		PNF_DONTCROUCH = 0x8,
		PNF_DONTPRONE = 0x10,
		PNF_CHOKEPOINT = 0x20,
		PNF_ALT_BOUNDS = 0x40,
		PNF_PRIORITY = 0x40,
		PNF_IDLE = 0x80,
		PSF_ZONE_ISLAND = 0x100,
		PNF_COVER_PEEKOVER = 0x200,
		PNF_COVER_PEEKLEFT = 0x400,
		PNF_COVER_PEEKRIGHT = 0x800,
		PNF_LINKSTOCHOKE = 0x1000,
		PNF_INDOOR = 0x2000,
		PNF_ERROR = 0x4000,
		PNF_ANGLEVALID = 0x8000,
		PNF_CANNOTBEUSEDBY_HUMANS = 0x10000,
		PNF_CANNOTBEUSEDBY_DOGS = 0x20000,
		PNF_GLASS_LINK = 0x40000,
		PNF_NO_ENTITY_DISCONNECT = 0x80000,
	};

	enum nodeType : std::uint16_t
	{
		NODE_ERROR = 0,
		NODE_PATHNODE = 1,
		NODE_COVER_STAND = 2,
		NODE_COVER_CROUCH = 3,
		NODE_COVER_CROUCH_WINDOW = 4,
		NODE_COVER_PRONE = 5,
		NODE_COVER_RIGHT = 6,
		NODE_COVER_LEFT = 7,
		//NODE_COVER_UNK1 = 8,
		//NODE_COVER_UNK2 = 9,
		NODE_COVER_MULTI = 10,
		NODE_AMBUSH = 11,
		NODE_EXPOSED = 12,
		NODE_CONCEALMENT_STAND = 13,
		NODE_CONCEALMENT_CROUCH = 14,
		NODE_CONCEALMENT_PRONE = 15,
		NODE_DOOR = 16, // not confirmed
		NODE_DOOR_INTERIOR = 17, // not confirmed
		NODE_SCRIPTED = 18,
		NODE_NEGOTIATION_BEGIN = 19,
		NODE_NEGOTIATION_END = 20,
		NODE_TURRET = 21,
		NODE_GUARD = 22,
		NODE_NUMTYPES = 31,
	};

	struct pathnode_constant_t
	{
		unsigned short type;
		unsigned int spawnflags;
		scr_string_t targetname;
		scr_string_t script_linkName;
		scr_string_t script_noteworthy;
		scr_string_t target;
		scr_string_t animscript;
		int animscriptfunc;
		float vLocalOrigin[3];
		$3936EE84564F75EDA6DCBAC77A545FC8 ___u9;
		PathNodeParentUnion parent;
		$5F11B9753862CE791E23553F99FA1738 ___u11;
		short wOverlapNode[2];
		char __pad0[4];
		unsigned short totalLinkCount;
		pathlink_s* Links;
		scr_string_t customangles;
		char __pad1[4];
	};

	struct SentientHandle
	{
		unsigned short number;
		unsigned short infoIndex;
	};

	struct pathnode_dynamic_t
	{
		SentientHandle pOwner;
		int iFreeTime;
		int iValidTime[3];
		short wLinkCount;
		short wOverlapCount;
		short turretEntNumber;
		unsigned char userCount;
		unsigned char hasBadPlaceLink;
		int spreadUsedTime[2];
		short flags;
		short dangerousCount;
		int recentUseProxTime;
	};

	union $73F238679C0419BE2C31C6559E8604FC
	{
		float nodeCost;
		int linkIndex;
	};

	struct pathnode_t;
	struct pathnode_transient_t
	{
		int iSearchFrame;
		pathnode_t* pNextOpen;
		pathnode_t* pPrevOpen;
		pathnode_t* pParent;
		float fCost;
		float fHeuristic;
		$73F238679C0419BE2C31C6559E8604FC ___u6;
	};

	struct pathnode_t
	{
		pathnode_constant_t constant;
		pathnode_dynamic_t dynamic;
		pathnode_transient_t transient;
	}; assert_sizeof(pathnode_t, 192);
	assert_sizeof(pathnode_constant_t, 96);
	assert_sizeof(pathnode_dynamic_t, 44);
	assert_sizeof(pathnode_transient_t, 48);

	struct pathnode_tree_nodes_t
	{
		int nodeCount;
		unsigned short* nodes;
	};

	struct pathnode_tree_t;
	union pathnode_tree_info_t
	{
		pathnode_tree_t* child[2];
		pathnode_tree_nodes_t s;
	};

	struct pathnode_tree_t
	{
		int axis;
		float dist;
		pathnode_tree_info_t u;
	};

	struct PathDynamicNodeGroup
	{
		unsigned short parentIndex;
		int nodeTreeCount;
		pathnode_tree_t* nodeTree;
	};

	struct PathData
	{
		const char* name;
		unsigned int nodeCount;
		pathnode_t* nodes;
		bool parentIndexResolved;
		unsigned short version;
		int visBytes;
		unsigned char* pathVis;
		int nodeTreeCount;
		pathnode_tree_t* nodeTree;
		int dynamicNodeGroupCount;
		PathDynamicNodeGroup* dynamicNodeGroups;
		int exposureBytes;
		unsigned char* pathExposure;
		int noPeekVisBytes;
		unsigned char* pathNoPeekVis;
		int zoneCount;
		int zonesBytes;
		unsigned char* pathZones;
		int dynStatesBytes;
		unsigned char* pathDynStates;
	}; assert_sizeof(PathData, 0x88);
	assert_offsetof(PathData, nodes, 16);
	assert_offsetof(PathData, pathExposure, 80);
	assert_offsetof(PathData, pathNoPeekVis, 96);
	assert_offsetof(PathData, pathZones, 112);

	enum VehicleType : std::int32_t
	{
		VEH_WHEELS_4 = 0,
		VEH_TANK = 1,
		VEH_PLANE = 2,
		VEH_BOAT = 3,
		VEH_ARTILLERY = 4,
		VEH_HELICOPTER = 5,
		VEH_SNOWMOBILE = 6,
		VEH_SUBMARINE = 7,
		VEH_UGV = 8,
		VEH_WALKER = 9,
		VEH_BALL_WHEELS = 10,
		VEH_MOBILE_COVER = 11,
		VEH_JETBIKE = 12,
		VEH_RECON_UGV = 13,
		VEH_HOVERTANK = 14,
		VEH_DIVEBOAT = 15,
		VEH_TYPE_COUNT = 16,
	};

	enum VehicleAxleType : std::int32_t
	{
		VEH_AXLE_FRONT = 0x0,
		VEH_AXLE_REAR = 0x1,
		VEH_AXLE_ALL = 0x2,
		VEH_AXLE_COUNT = 0x3,
	};

	struct VehiclePhysDef
	{
		int physicsEnabled;
		const char* physPresetName;
		PhysPreset* physPreset;
		const char* physMassName;
		PhysMass* physMass;
		const char* accelGraphName;
		VehicleAxleType steeringAxle;
		VehicleAxleType powerAxle;
		VehicleAxleType brakingAxle;
		float topSpeed;
		float topSpeedTurbo;
		float reverseSpeed;
		float maxVelocity;
		float maxPitch;
		float maxRoll;
		float wheelRadius;
		float suspensionTravelFront;
		float suspensionTravelRear;
		float suspensionStrengthFront;
		float suspensionDampingFront;
		float suspensionStrengthRear;
		float suspensionDampingRear;
		float frictionBraking;
		float frictionCoasting;
		float frictionTopSpeed;
		float frictionSide;
		float frictionSideRear;
		float handBrakeLongitudinalSteerableFrictionScale;
		float handBrakeLateralSteerableFrictionScale;
		float handBrakeLongitudinalNonsteerableFrictionScale;
		float handBrakeLateralNonsteerableFrictionScale;
		float handBrakingStrength;
		float handBrakeExtraYawTorque;
		float speedAtMaxHandBrakeExtraYawTorque;
		float driveForceFalloffFraction;
		float velocityDependentSlip;
		float rollStability;
		float rollResistance;
		float pitchResistance;
		float yawResistance;
		float uprightStrengthPitch;
		float uprightStrengthRoll;
		float targetAirPitch;
		float airYawTorque;
		float airPitchTorque;
		float minimumMomentumForCollision;
		float collisionLaunchForceScale;
		float wreckedMassScale;
		float wreckedBodyFriction;
		float minimumJoltForNotify;
		float slipThresholdFront;
		float slipThresholdRear;
		float slipFricScaleFront;
		float slipFricScaleRear;
		float slipFricRateFront;
		float slipFricRateRear;
		float slipYawTorque;
		float cruiseControlProportionalGain;
		float cruiseControlIntegralGain;
	}; assert_sizeof(VehiclePhysDef, 0x108);
	assert_offsetof(VehiclePhysDef, accelGraphName, 40);
	assert_offsetof(VehiclePhysDef, rollStability, 168);
	assert_offsetof(VehiclePhysDef, minimumMomentumForCollision, 204);

	enum VehicleTurretFireType
	{
		VEH_TURRET_SINGLE_FIRE = 0x0,
		VEH_TURRET_DUAL_FIRE = 0x1,
		VEH_TURRET_ALT_FIRE = 0x2,
		VEH_TURRET_FIRE_TYPE_COUNT = 0x3,
	};

	enum VehCamZOffsetMode : std::int32_t
	{
		VEHCAM_ZMODE_WORLD = 0x0,
		VEHCAM_ZMODE_VEHICLE = 0x1,
		VEHCAM_ZMODE_VIEW = 0x2,
		VEHCAM_ZMODE_COUNT = 0x3,
	};

	struct VehicleDef
	{
		union
		{
			const char* name;
			const char* internalName;
		};
		VehicleType type;
		const char* useHintString;
		int health;
		int quadBarrel;
		int hitClientScriptables;
		int multipleLinkedGroundEntities;
		int hideVehicleForDriver;
		float texScrollScale;
		float topSpeed;
		float accel;
		float rotRate;
		float rotAccel;
		float maxBodyPitch;
		float maxBodyRoll;
		int legIK;
		float fakeBodyAccelPitch;
		float fakeBodyAccelRoll;
		float fakeBodyVelPitch;
		float fakeBodyVelRoll;
		float fakeBodySideVelPitch;
		float fakeBodyPitchStrength;
		float fakeBodyRollStrength;
		float fakeBodyPitchDampening;
		float fakeBodyRollDampening;
		float fakeBodyBoatRockingAmplitude;
		float fakeBodyBoatRockingPeriod;
		float fakeBodyBoatRockingRotationPeriod;
		float fakeBodyBoatRockingFadeoutSpeed;
		float boatBouncingMinForce;
		float boatBouncingMaxForce;
		float boatBouncingRate;
		float boatBouncingFadeinSpeed;
		float boatBouncingFadeoutSteeringAngle;
		float collisionDamage;
		float collisionSpeed;
		float killcamOffset[3];
		int playerProtected;
		int bulletDamage;
		int armorPiercingDamage;
		int grenadeDamage;
		int projectileDamage;
		int projectileSplashDamage;
		int heavyExplosiveDamage;
		int pad1;
		VehiclePhysDef vehPhysDef;
		float boostDuration;
		float boostRechargeTime;
		float boostAcceleration;
		float boostTopSpeed;
		float suspensionTravel;
		float maxSteeringAngle;
		float steeringLerp;
		float steeringLerpCentering;
		float minSteeringScale;
		float minSteeringSpeed;
		float disableWheelsTurning;
		float pad2;
		FxEffectDef* treadDefaultFx;
		FxEffectDef* handBrakeDefaultFx;
		FxEffectDef* handBrakeLeftFx;
		FxEffectDef* handBrakeRightFx;
		FxEffectDef* boostFx;
		float treadFxSlowestRepeatRate;
		float treadFxFastestRepeatRate;
		float treadFxMinSpeed;
		float treadFxMaxSpeed;
		int vehHelicopterIsASplinePlane;
		int vehHelicopterOrbitsAroundPoint;
		int vehHelicopterLockAltitude;
		int vehHelicopterOffsetFromMesh;
		float vehHelicopterAltitudeOffset;
		float vehHelicopterPitchOffset;
		float vehHelicopterBoundsRadius;
		float vehHelicopterBoundsOffsetZ;
		float vehHelicopterMaxSpeed;
		float vehHelicopterMaxSpeedVertical;
		float vehHelicopterMaxAccel;
		float vehHelicopterMaxAccelVertical;
		float vehHelicopterDecelerationFwd;
		float vehHelicopterDecelerationSide;
		float vehHelicopterDecelerationUp;
		float vehHelicopterMaxYawRate;
		float vehHelicopterMaxYawAccel;
		float vehHelicopterTiltFromVelocity;
		float vehHelicopterTiltFromControllerAxes;
		float vehHelicopterTiltFromAcceleration;
		float vehHelicopterTiltFromDeceleration;
		float vehHelicopterTiltFromFwdAndYaw_VelAtMaxTilt;
		float vehHelicopterTiltFromFwdAndYaw;
		float vehHelicopterTiltMomentum;
		float vehHelicopterTiltSpeed;
		float vehHelicopterMaxPitch;
		float vehHelicopterMaxRoll;
		float vehHelicopterHoverSpeedThreshold;
		float vehHelicopterJitterJerkyness;
		int vehHelicopterUseHoverWobble;
		float vehHelicopterHoverWobblePhase;
		float vehHelicopterHoverWobbleAmplitude;
		int vehHelicopterUseBob;
		float vehHelicopterBobPhase;
		float vehHelicopterBobAmplitude;
		float vehHelicopterLookaheadTime;
		int vehHelicopterSoftCollisions;
		int vehHelicopterUseGroundFX;
		FxEffectDef* vehHelicopterGroundFx;
		FxEffectDef* vehHelicopterGroundWaterFx;
		float vehHelicopterGroundFxDefaultRepeatRate;
		float vehHelicopterGroundFxSlowestRepeatRate;
		float vehHelicopterGroundFxFastestRepeatRate;
		float vehHelicopterGroundFxMinGroundDist;
		float vehHelicopterGroundFxMaxGroundDist;
		float vehSplinePlaneCorridorMaxXVel;
		float vehSplinePlaneCorridorMaxZVel;
		float vehSplinePlaneCorridorMaxXAccel;
		float vehSplinePlaneCorridorMaxZAccel;
		float vehSplinePlaneTangentLookAtRate;
		float vehSplinePlaneMaxPitchSpeed;
		float vehSplinePlaneMaxYawSpeed;
		float vehSplinePlaneMaxRollSpeed;
		float vehSplinePlanePitchSpeedRate;
		float vehSplinePlaneYawSpeedRate;
		float vehSplinePlaneRollSpeedRateUp;
		float vehSplinePlaneRollSpeedRateDown;
		float vehSplinePlaneMaxPitchAccel;
		float vehSplinePlaneMaxYawAccel;
		float vehSplinePlaneMaxRollAccel;
		float vehSplinePlaneYawToRollFactor;
		float vehSplinePlaneRollToYawFactor;
		float vehSplinePlaneRollToYawFactorBlend;
		float vehSplinePlaneMaxPitch;
		float vehSplinePlaneMaxRoll;
		float vehSplinePlaneMaxPitchFromRoll;
		float vehSplinePlaneMaxRollYawOffset;
		float vehSplinePlaneRollYawOffsetThreshold;
		float vehSplinePlaneMaxTiltRoll;
		float vehSplinePlaneMaxTiltPitch;
		float vehSplinePlaneTiltRollRate;
		float vehSplinePlaneTiltPitchRate;
		float vehJetbikeThrottleForce;
		float vehJetbikeStrafeForce;
		float vehJetbikeYawTorque;
		float vehJetbikePitchTorque;
		float vehJetbikeYawDamping;
		float vehJetbikePitchDamping;
		float vehJetbikeRollDamping;
		float vehJetbikeRepulsorMaxForceFraction;
		float vehJetbikeRepulsorMinForceFraction;
		float vehJetbikeRepulsorCompressionDampingConstant;
		float vehJetbikeRepulsorReboundDampingConstant;
		float vehJetbikeRepulsorTorqueScale;
		float vehJetbikeRepulsorCrossCoupling;
		float vehJetbikeAntislipConstant;
		float vehJetbikeAntislipMaxForce;
		float vehJetbikeControlForceLocalOffsetX;
		float vehJetbikeControlForceLocalOffsetZ;
		float vehJetbikeControlTorqueLocalOffsetX;
		float vehJetbikeControlTorqueLocalOffsetZ;
		float vehJetbikeMaxControlForce;
		float vehJetbikeMinContactForFullControl;
		float vehJetbikeThrustScaleWithNoContact;
		float vehJetbikeTorqueScaleWithNoContact;
		float vehJetbikeUprightingTorque;
		float vehJetbikeUprightingTorqueWithNoContact;
		float vehJetbikeWeathervaneTorque;
		float vehJetbikeWeathervaneTorqueWithNoContact;
		float vehJetbikeAiSteeringConstant;
		float vehJetbikeAiStationarySteeringScale;
		float vehJetbikeAiThrottleConstant;
		float vehHovertankAutoYawForce;
		float vehHovertankAutoBrakeForce;
		float vehHovertankRandomHoverForceMagMin;
		float vehHovertankRandomHoverForceMagMax;
		float vehHovertankRandomHoverForceStartTimerMin;
		float vehHovertankRandomHoverForceStartTimerMax;
		float vehHovertankRandomHoverForceDurationMin;
		float vehHovertankRandomHoverForceDurationMax;
		float vehDiveboatInitialDiveForceFactor;
		float vehDiveboatContinuingDiveForceFactor;
		float vehDiveboatMaxDiveTime;
		float vehDiveboatDiveResetTime;
		float vehDiveboatSubmergedDragFactor;
		float vehDiveboatRollFactor;
		float vehDiveboatBuoyancyOffset;
		float pad3;
		const char* vehDiveboatSteeringGraphName;
		int steeringGraphIndex;
		float vehOrbiterMinYaw;
		float vehOrbiterMaxYaw;
		float vehOrbiterMinZ;
		float vehOrbiterMaxZ;
		float vehOrbiterAngularAcceleration;
		float vehOrbiterAngularMaxVelocity;
		float vehOrbiterAngularDeceleration;
		float vehOrbiterAngularADSDeceleration;
		float vehOrbiterAngularBraking;
		float vehOrbiterAngularADSBraking;
		float vehOrbiterAngularLookAheadTime;
		float vehOrbiterVerticalAcceleration;
		float vehOrbiterVerticalMaxVelocity;
		float vehOrbiterVerticalDeceleration;
		float vehOrbiterVerticalADSDeceleration;
		float vehOrbiterVerticalBraking;
		float vehOrbiterVerticalADSBraking;
		float vehOrbiterVerticalLookAheadTime;
		float vehOrbiterADSVelocityMult;
		float vehOrbiterTiltRollMax;
		float vehOrbiterTiltRollRate;
		float vehOrbiterTiltPitchMax;
		float vehOrbiterTiltPitchRate;
		int camLookEnabled;
		int camRelativeControl;
		int camRemoteDrive;
		float camLerp;
		float camHeight;
		float camRadius;
		float camPitchInfluence;
		float camYawInfluence;
		float camRollInfluence;
		float camFovIncrease;
		float camFovOffset;
		float camFovSpeed;
		float camReturnSpeed;
		float camReturnLerp;
		float camVehicleAnglePitchRate;
		float camVehicleAngleYawRate;
		float camVehicleAngleRollRate;
		float camShakeMinSpeed;
		float camShakeMaxSpeed;
		float camShakeMinFreq;
		float camShakeMaxFreq;
		float camShakeMaxAmplitudePitch;
		float camShakeMaxAmplitudeYaw;
		float camShakeMaxAmplitudeRoll;
		float camShakeMaxAmplitudeX;
		float camShakeMaxAmplitudeY;
		float camShakeMaxAmplitudeZ;
		float camShakeMinAmplitudeScale;
		int camShakeTurretInherit;
		int vehCam_UseGDT;
		float vehCam_anglesPitch;
		float vehCam_anglesYaw;
		float vehCam_anglesRoll;
		float vehCam_offsetX;
		float vehCam_offsetY;
		float vehCam_offsetZ;
		float vehCam_radius;
		float vehCam_speedInfluence;
		float vehCam_pitchTurnRate;
		float vehCam_pitchClamp;
		float vehCam_yawTurnRate;
		float vehCam_yawClamp;
		VehCamZOffsetMode vehCam_zOffsetMode;
		float vehCam_anglesPitch3P;
		float vehCam_anglesYaw3P;
		float vehCam_anglesRoll3P;
		float vehCam_offsetX3P;
		float vehCam_offsetY3P;
		float vehCam_offsetZ3P;
		float vehCam_radius3P;
		float vehCam_speedInfluence3P;
		float vehCam_pitchTurnRate3P;
		float vehCam_pitchClamp3P;
		float vehCam_yawTurnRate3P;
		float vehCam_yawTurnRate3PHandbrakeInc;
		float vehCam_yawClamp3P;
		VehCamZOffsetMode vehCam_zOffsetMode3P;
		float pad4;
		const char* turretWeaponName;
		WeaponDef* turretWeapon;
		float turretHorizSpanLeft;
		float turretHorizSpanRight;
		float turretVertSpanUp;
		float turretVertSpanDown;
		float turretHorizResistLeft;
		float turretHorizResistRight;
		float turretVertResistUp;
		float turretVertResistDown;
		float turretRotRate;
		VehicleTurretFireType turretFireType;
		snd_alias_list_t* turretSpinSnd;
		snd_alias_list_t* turretStopSnd;
		int trophyEnabled;
		float trophyRadius;
		float trophyInactiveRadius;
		int trophyAmmoCount;
		float trophyReloadTime;
		scr_string_t trophyTags[4];
		FxEffectDef* trophyExplodeFx;
		FxEffectDef* trophyFlashFx;
		Material* compassFriendlyIcon;
		Material* compassEnemyIcon;
		Material* compassFriendlyAltIcon;
		Material* compassEnemyAltIcon;
		int compassIconWidth;
		int compassIconHeight;
		snd_alias_list_t* idleLowSnd;
		snd_alias_list_t* idleHighSnd;
		snd_alias_list_t* engineLowSnd;
		snd_alias_list_t* engineHighSnd;
		snd_alias_list_t* boostSnd;
		float engineSndSpeed;
		scr_string_t audioOriginTag;
		snd_alias_list_t* idleLowSndAlt;
		snd_alias_list_t* idleHighSndAlt;
		snd_alias_list_t* engineLowSndAlt;
		snd_alias_list_t* engineHighSndAlt;
		float engineSndSpeedAlt;
		scr_string_t audioOriginTagAlt;
		snd_alias_list_t* turretSpinSndAlt;
		snd_alias_list_t* turretStopSndAlt;
		snd_alias_list_t* engineStartUpSnd;
		int engineStartUpLength;
		snd_alias_list_t* engineShutdownSnd;
		snd_alias_list_t* engineIdleSnd;
		snd_alias_list_t* engineSustainSnd;
		snd_alias_list_t* engineRampUpSnd;
		int engineRampUpLength;
		snd_alias_list_t* engineRampDownSnd;
		int engineRampDownLength;
		snd_alias_list_t* suspensionSoftSnd;
		float suspensionSoftCompression;
		snd_alias_list_t* suspensionHardSnd;
		float suspensionHardCompression;
		snd_alias_list_t* collisionSnd;
		float collisionBlendSpeed;
		snd_alias_list_t* speedSnd;
		float speedSndBlendSpeed;
		const char* surfaceSndPrefix;
		snd_alias_list_t* surfaceSnds[53];
		float surfaceSndBlendSpeed;
		float slideVolume;
		float slideBlendSpeed;
		float inAirPitch;
		const char* soundTriggerOverrideZone;
		bool soundTriggerOverrideReverb;
		bool soundTriggerOverrideMix;
		bool soundTriggerOverrideFilter;
		bool soundTriggerOverrideOcclusion;
		bool soundTriggerOverrideAmbient;
		bool soundTriggerOverrideAmbientEvents;
	}; assert_sizeof(VehicleDef, 0x8D0);

	struct FxImpactEntry
	{
		FxEffectDef* nonflesh[53];
		FxEffectDef* flesh[7];
	};

	struct FxImpactTable
	{
		const char* name;
		FxImpactEntry* table; // size: 19
	};

	struct SurfaceFxEntry
	{
		FxEffectDef* surfaceEffect[53];
	};

	struct SurfaceFxTable
	{
		const char* name;
		SurfaceFxEntry* table; // size: 6
	};

	enum StatsGroup : std::int32_t
	{
		STATSGROUP_RANKED = 0x0,
		STATSGROUP_PRIVATE = 0x1,
		STATSGROUP_COOP = 0x2,
		STATSGROUP_COMMON = 0x3,
		STATSGROUP_HORDE = 0x4,
		STATSGROUP_SP = 0x5,
		STATSGROUP_COUNT = 0x6,
		STATSGROUP_IGNORE = 0x7,
	};

	enum LbColType : std::int32_t
	{

	};

	enum LbAggType : std::int32_t
	{

	};

	struct LbColumnDef
	{
		const char* name;
		int id;
		int propertyId;
		bool hidden;
		StatsGroup statsGroup;
		const char* statName;
		LbColType type;
		int precision;
		LbAggType agg;
		int uiCalColX;
		int uiCalColY;
	}; assert_sizeof(LbColumnDef, 56);

	enum LbUpdateType : std::int32_t
	{

	};

	enum LbTrackTypes : std::int32_t
	{

	};

	struct LeaderboardDef
	{
		const char* name;
		int id;
		int id2;
		int columnCount;
		int xpColId;
		int prestigeColId;
		int pad;
		LbColumnDef* columns;
		LbUpdateType updateType;
		LbTrackTypes trackTypes;
	}; assert_sizeof(LeaderboardDef, 0x30);
	assert_offsetof(LeaderboardDef, columns, 32);
	assert_offsetof(LeaderboardDef, columnCount, 16);

	struct VLbColumnDef
	{
		const char* name;
		int id;
		int unk1;
		int unk2;
		int unk3;
	}; assert_sizeof(VLbColumnDef, 24);

	struct VirtualLeaderboardDef
	{
		const char* name;
		const char* leaderboardName;
		int id;
		int leaderboardId;
		VLbColumnDef* columns;
		int columnCount;
		int pad;
	}; assert_sizeof(VirtualLeaderboardDef, 0x28);

	enum DDLType : std::int32_t
	{
		DDL_BYTE_TYPE = 0x0,
		DDL_SHORT_TYPE = 0x1,
		DDL_BOOL_TYPE = 0x2,
		DDL_INT_TYPE = 0x3,
		DDL_UINT64_TYPE = 0x4,
		DDL_FLOAT_TYPE = 0x5,
		DDL_FIXEDPOINT_TYPE = 0x6, // unused
		DDL_STRING_TYPE = 0x7,
		DDL_STRUCT_TYPE = 0x8,
		DDL_ENUM_TYPE = 0x9,
		DDL_PAD_TYPE = 0xA,
	};

	enum DDLFLags : std::uint8_t
	{
		DDL_FLAG_DIRTY = 0x0,
		DDL_FLAG_CHECKSUM = 0x1,
		DDL_FLAG_CODE_VERSION = 0x2,
		DDL_FLAG_USER_FLAGS = 0x4,
		DDL_FLAG_NO_PADDING = 0x8,
		DDL_FLAG_RESERVE = 0x10,
		DDL_FLAG_DDL_CHECKSUM = 0x20,
	};

	struct DDLMember
	{
		const char* name;
		int index;
		void* parent;
		int bitSize;
		int limitSize;
		int offset;
		int type;
		int externalIndex;
		unsigned int rangeLimit;
		unsigned int serverDelta;
		unsigned int clientDelta;
		int arraySize;
		int enumIndex;
		int permission;
	};

	struct DDLHash
	{
		unsigned int hash;
		int index;
	};

	struct DDLHashTable
	{
		DDLHash* list;
		int count;
		int max;
	};

	struct DDLStruct
	{
		const char* name;
		int bitSize;
		int memberCount;
		DDLMember* members;
		DDLHashTable hashTableUpper;
		DDLHashTable hashTableLower;
	};

	struct DDLEnum
	{
		const char* name;
		int memberCount;
		const char** members;
		DDLHashTable hashTable;
	};

	struct DDLDef
	{
		char* name;
		unsigned short version;
		unsigned int checksum;
		unsigned char flags;
		int bitSize;
		int byteSize;
		DDLStruct* structList;
		int structCount;
		DDLEnum* enumList;
		int enumCount;
		DDLDef* next;
		int headerBitSize;
		int headerByteSize;
		int reserveSize;
		int userFlagsSize;
		bool paddingUsed;
	};

	struct DDLRoot
	{
		const char* name;
		DDLDef* ddlDef;
	};

	struct Proto;
	struct Proto_B;
	struct Proto_A_A_A;
	struct Proto_A_A_B_A;
	struct Proto_A_A_B;
	struct Proto_A_A;
	struct Proto_A_B_A;
	struct Proto_A_B;
	struct Proto_A;
	struct Proto_C;

	struct Proto_B
	{
		Proto_A_B_A* unk1;
		int unk1_count;
		int unk2;
	}; assert_sizeof(Proto_B, 16);

	struct Proto_A_A_A
	{
		const char* unk1;
		Proto_A_A* unk2;
		int unk2_count;
		Proto_B unk3;
	}; assert_sizeof(Proto_A_A_A, 40);
	assert_offsetof(Proto_A_A_A, unk2, 8);
	assert_offsetof(Proto_A_A_A, unk2_count, 16);

	struct Proto_A_A_B_A
	{
		int __pad0[3];
		const char* unk1;
	}; assert_sizeof(Proto_A_A_B_A, 24);

	struct Proto_A_A_B
	{
		const char* unk1;
		Proto_A_A_B_A* unk2;
		int unk2_count;
	}; assert_sizeof(Proto_A_A_B, 24);
	assert_offsetof(Proto_A_A_B, unk2, 8);
	assert_offsetof(Proto_A_A_B, unk2_count, 16);

	struct Proto_A_A
	{
		const char* unk1;
		int __pad0[4];
		Proto_A_A_A* unk2;
		Proto_A_A_B* unk3;
	}; assert_sizeof(Proto_A_A, 40);
	assert_offsetof(Proto_A_A, unk2, 24);
	assert_offsetof(Proto_A_A, unk3, 32);

	struct Proto_A_B_A
	{
		int __pad0[2];
	}; assert_sizeof(Proto_A_B_A, 8);

	struct Proto_A_B
	{
		Proto_A_B_A* unk1;
		int unk1_count;
	}; assert_sizeof(Proto_A_B, 16);
	assert_offsetof(Proto_A_B, unk1, 0);
	assert_offsetof(Proto_A_B, unk1_count, 8);

	struct Proto_A
	{
		const char* unk1;
		Proto_A_A* unk2;
		int unk2_count;
		Proto_A_B unk3;
	}; assert_sizeof(Proto_A, 40);
	assert_offsetof(Proto_A, unk2, 8);
	assert_offsetof(Proto_A, unk2_count, 16);
	assert_offsetof(Proto_A, unk3, 24);

	struct Proto_C
	{
		const char* unk1;
		Proto_A_A_B_A* unk2;
		int unk2_count;
	}; assert_sizeof(Proto_C, 24);
	assert_offsetof(Proto_A, unk2, 8);
	assert_offsetof(Proto_A, unk2_count, 16);

	struct Proto
	{
		const char* name;
		const char* checksum;
		Proto_A* unk2;
		int unk2_count;
		Proto_B unk3;
		Proto_C* unk4;
		int unk4_count;
		Proto_B unk5;
	}; assert_sizeof(Proto, 0x50);
	assert_offsetof(Proto, unk2, 16);
	assert_offsetof(Proto, unk2_count, 24);
	assert_offsetof(Proto, unk3, 32);
	assert_offsetof(Proto, unk4, 48);
	assert_offsetof(Proto, unk4_count, 56);
	assert_offsetof(Proto, unk5, 64);

	struct SndSubmix
	{
		const char* name;
		short volModIndex;
		float value;
		int fadeInTime;
		int fadeOutTime;
	}; assert_sizeof(SndSubmix, 24);

	struct SndSubmixList
	{
		union
		{
			const char* submixName;
			const char* name;
		};
		SndSubmix* head;
		int count;
	}; assert_sizeof(SndSubmixList, 0x18);

	struct ReverbPreset
	{
		union
		{
			const char* p_name;
			const char* name;
		};
		float earlyTime;
		float lateTime;
		float earlyGain;
		float lateGain;
		float lateGainProx;
		float returnGain;
		float earlyLpf;
		float lateLpf;
		float inputLpf;
		float dampLpf;
		float wallReflect;
		float dryGain;
		float earlySize;
		float lateSize;
		float diffusion;
		float rearLevel;
	}; assert_sizeof(ReverbPreset, 0x48);

	struct EquipmentClothData
	{
		char* szName;
	};

	struct EquipmentWeaponRattleData
	{
		char* szName;
		float priority;
	};

	struct EquipmentSndChance
	{
		float rattleChance;
		float accentChance;
		float silentChance;
	};

	struct EquipmentChanceMoveTypes
	{
		EquipmentSndChance* chances;
	};

	struct EquipmentChanceRattleTypes
	{
		EquipmentChanceMoveTypes* chances;
	};

	struct EquipmentSoundSet
	{
		snd_alias_list_t* soundPLR;
		snd_alias_list_t* soundNPC;
	};

	struct EquipSoundSetMoveTypes
	{
		EquipmentSoundSet* soundSets;
	};

	struct EquipSoundSetMantleTypes
	{
		EquipmentSoundSet soundSets[14];
	};

	struct EquipmentSoundTable
	{
		union
		{
			const char* szName;
			const char* name;
		};
		unsigned int numClothTypes;
		unsigned int numWeaponRattleTypes;
		unsigned int numMoveTypes;
		EquipmentClothData* clothTypes;
		EquipmentWeaponRattleData* weaponRattleTypes;
		EquipmentChanceRattleTypes* chancesPLR;
		EquipmentChanceRattleTypes* chancesNPC;
		EquipSoundSetMoveTypes* mvmtClothSoundSets;
		EquipSoundSetMoveTypes* mvmtRattleSoundSets;
		EquipSoundSetMoveTypes mvmtAccentSoundSets;
		EquipSoundSetMantleTypes* mvmtMantleSoundSets;
	};

	struct SndGlobalSettings_t
	{
		float globalVolumeModifier;
		float unk[9];
		//char __pad0[36];
	};

	struct XaReverbSettings
	{
		int presetOverridden;
		XAUDIO2FX_REVERB_I3DL2_PARAMETERS reverbSettings;
	};

	struct SndDriverGlobals
	{
		const char* name;
		SndGlobalSettings_t settings;
		XaReverbSettings* reverbSettings;  // array: 26
	}; assert_sizeof(SndDriverGlobals, 0x38);
	assert_offsetof(SndDriverGlobals, reverbSettings, 48);

	enum VectorFieldType : std::int32_t
	{
		VECTOR_FIELD_TYPE_NONE = 0x0,
		VECTOR_FIELD_TYPE_FORCE = 0x1,
		VECTOR_FIELD_TYPE_VELOCITY = 0x2,
		VECTOR_FIELD_NUM_TYPES = 0x3,
	};

	struct VectorFieldSubField
	{
		vec4_t* linearData;
		ExtentBounds worldBounds;
		float ds[3];
		unsigned int numEntries[3];
		unsigned int flags;
		VectorFieldType type;
		unsigned int pad[4];
	}; assert_sizeof(VectorFieldSubField, 80);
	assert_offsetof(VectorFieldSubField, linearData, 0);
	assert_offsetof(VectorFieldSubField, numEntries, 44);

	struct VectorField
	{
		const char* name;
		VectorFieldSubField* fields;
		ExtentBounds bounds;
		int fieldsCount;
		int pad;
	}; assert_sizeof(VectorField, 48);
	assert_offsetof(VectorField, fields, 8);
	assert_offsetof(VectorField, fieldsCount, 40);

	struct AnimationAimSet
	{
		scr_string_t name;
		scr_string_t rootName;
		scr_string_t animName[8];
		unsigned __int64 rootIndex;
		unsigned __int64 animIndices[8];
	};

	struct AnimationEntry
	{
		scr_string_t alias;
		scr_string_t animName;
	};

	struct AnimationState
	{
		scr_string_t name;
		scr_string_t notify;
		float blendTime;
		unsigned char flags;
		unsigned char entryCount;
		AnimationAimSet* aimSet;
		AnimationEntry* animEntries;
		unsigned __int64* animIndices;
	};

	struct AnimationStateMachine
	{
		scr_string_t name;
		unsigned short stateCount;
		unsigned short aimSetCount;
		AnimationState* states;
		AnimationAimSet* aimSets;
	};

	enum AnimationController : std::int32_t
	{
		ANIMCTRL_NONE = 0x0,
		ANIMCTRL_PLAYER = 0x1,
		ANIMCTRL_DOG = 0x2,
		ANIMCTRL_NUM = 0x3,
	};

	struct AnimationClass
	{
		union
		{
			const char* className;
			const char* name;
		};
		AnimationStateMachine* stateMachine;
		AnimationController animCtrl;
		scr_string_t animTree;
		ScriptableDef* scriptable;
		unsigned short soundCount;
		unsigned short effectCount;
		scr_string_t* soundNotes;
		scr_string_t* soundNames;
		scr_string_t* soundOptions;
		scr_string_t* effectNotes;
		FxEffectDef** effectDefs;
		scr_string_t* effectTags;
	};

	union XAssetHeader
	{
		void* data;
		PhysPreset* physPreset;
		PhysCollmap* physCollmap;
		PhysWaterPreset* physWaterPreset;
		PhysWorld* physWorld;
		PhysConstraint* physConstraint;
		XAnimParts* parts;
		XModelSurfs* modelSurfs;
		XModel* model;
		Material* material;
		ComputeShader* computeShader;
		MaterialVertexShader* vertexShader;
		MaterialHullShader* hullShader;
		MaterialDomainShader* domainShader;
		MaterialPixelShader* pixelShader;
		MaterialVertexDeclaration* vertexDecl;
		MaterialTechniqueSet* techniqueSet;
		GfxImage* image;
		snd_alias_list_t* sound;
		SndSubmixList* sndSubmix;
		SndCurve* sndCurve;
		SndCurve* lpfCurve;
		SndCurve* reverbCurve;
		SndContext* sndContext;
		LoadedSound* loadSnd;
		clipMap_t* clipMap;
		ComWorld* comWorld;
		GlassWorld* glassWorld;
		PathData* pathData;
		// vehicle track
		MapEnts* mapEnts;
		FxWorld* fxWorld;
		GfxWorld* gfxWorld;
		GfxLightDef* lightDef;
		// ui map
		MenuList* menuList;
		menuDef_t* menu;
		AnimationClass* animClass;
		LocalizeEntry* localize;
		WeaponAttachment* attachment;
		WeaponDef* weapon;
		SndDriverGlobals* sndDriverGlobals;
		FxEffectDef* fx;
		FxImpactTable* impactFx;
		SurfaceFxTable* surfaceFx;
		// ai type
		// mp type
		// character
		// xmodel alias
		RawFile* rawfile;
		ScriptFile* scriptfile;
		StringTable* stringTable;
		LeaderboardDef* leaderboardDef;
		VirtualLeaderboardDef* virtualLeaderboard;
		StructuredDataDefSet* structuredDataDefSet;
		DDLRoot* ddlRoot;
		Proto* proto;
		TracerDef* tracerDef;
		VehicleDef* vehDef;
		AddonMapEnts* addonMapEnts;
		NetConstStrings* netConstStrings;
		ReverbPreset* reverbPreset;
		LuaFile* luaFile;
		ScriptableDef* scriptable;
		EquipmentSoundTable* equipSndTable;
		VectorField* vectorField;
		DopplerPreset* doppler;
		FxParticleSimAnimation* particleSimAnimation;
		LaserDef* laser;
		SkeletonScript* skeletonScript;
		Clut* clut;
		TTFDef* ttfDef;
	};

	struct XAsset
	{
		XAssetType type;
		XAssetHeader header;
	};

	struct XAssetEntry
	{
		XAsset asset;
		short zoneIndex;
		volatile char inuseMask;
		unsigned int nextHash;
		unsigned int nextOverride;
		unsigned int nextPoolEntry;
	};

	struct ScriptStringList
	{
		int count;
		const char** strings;
	};

	union GfxZoneTableEntry
	{
		char* dataPtr;
		void* voidPtr;
		ID3D11Buffer* buffer;
		ID3D11DepthStencilState* depthStencilState;
		ID3D11BlendState* blendState;
	};

	typedef std::uint32_t GfxBlendStateBits[3];

	struct XGfxGlobals
	{
		unsigned int depthStencilStateCount;
		unsigned int blendStateCount;
		std::uint64_t* depthStencilStateBits;
		GfxBlendStateBits* blendStateBits;
		GfxZoneTableEntry* depthStencilStates;
		GfxZoneTableEntry* blendStates;
		unsigned int perPrimConstantBufferCount;
		unsigned int perObjConstantBufferCount;
		unsigned int stableConstantBufferCount;
		unsigned int* perPrimConstantBufferSizes;
		unsigned int* perObjConstantBufferSizes;
		unsigned int* stableConstantBufferSizes;
		GfxZoneTableEntry* perPrimConstantBuffers;
		GfxZoneTableEntry* perObjConstantBuffers;
		GfxZoneTableEntry* stableConstantBuffers;
	};

	struct XGlobals
	{
		XGfxGlobals* gfxGlobals;
	};

	struct XAssetList
	{
		ScriptStringList stringList;
		int assetCount;
		XAsset* assets;
		XGlobals* globals;
	};

	enum DBSyncMode
	{
		DB_LOAD_ASYNC = 0x0,
		DB_LOAD_SYNC = 0x1,
		DB_LOAD_ASYNC_WAIT_ALLOC = 0x2,
		DB_LOAD_ASYNC_FORCE_FREE = 0x3,
		DB_LOAD_ASYNC_NO_SYNC_THREADS = 0x4,
		DB_LOAD_SYNC_SKIP_ALWAYS_LOADED = 0x5,
	};

	enum DBAllocFlags : std::int32_t
	{
		DB_ZONE_NONE = 0x0,
		DB_ZONE_COMMON = 0x1,
		DB_ZONE_UI = 0x2,
		DB_ZONE_GAME = 0x4,
		DB_ZONE_LOAD = 0x8,
		DB_ZONE_DEV = 0x10,
		DB_ZONE_BASEMAP = 0x20,
		DB_ZONE_TRANSIENT_POOL = 0x40,
		DB_ZONE_TRANSIENT_MASK = 0x40,
		DB_ZONE_CUSTOM = 0x1000 // added for custom zone loading
	};

	struct XZoneInfo
	{
		const char* name;
		int allocFlags;
		int freeFlags;
	};

	struct XZoneInfoInternal
	{
		char name[64];
		int flags;
		int isBaseMap;
	};

	struct XZone
	{
		char __pad0[32];
		char name[64];
		char __pad1[408];
	};
}